// RUN: %empty-directory(%t)
// RUN: %target-language-frontend -target %target-future-triple -O -I %S/Inputs/CTypes -enable-experimental-feature LayoutStringValueWitnesses -enable-layout-string-value-witnesses -parse-stdlib -emit-module -emit-module-path=%t/layout_string_witnesses_types.codemodule %S/Inputs/layout_string_witnesses_types.code

// NOTE: We have to build this as dylib to turn private external symbols into local symbols, so we can observe potential issues with linkage
// RUN: %target-build-language-dylib(%t/%target-library-name(layout_string_witnesses_types)) -target %target-future-triple -O -I %S/Inputs/CTypes -Xfrontend -enable-experimental-feature -Xfrontend LayoutStringValueWitnesses -Xfrontend -enable-layout-string-value-witnesses -Xfrontend -parse-stdlib -parse-as-library %S/Inputs/layout_string_witnesses_types.code
// RUN: %target-codesign %t/%target-library-name(layout_string_witnesses_types)
// RUN: %target-language-frontend -target %target-future-triple -O -enable-experimental-feature LayoutStringValueWitnesses -enable-layout-string-value-witnesses -enable-library-evolution -emit-module -emit-module-path=%t/layout_string_witnesses_types_resilient.codemodule %S/Inputs/layout_string_witnesses_types_resilient.code
// RUN: %target-build-language -target %target-future-triple -O -g -Xfrontend -enable-experimental-feature -Xfrontend LayoutStringValueWitnesses -Xfrontend -enable-layout-string-value-witnesses -Xfrontend -enable-library-evolution -c -parse-as-library -o %t/layout_string_witnesses_types_resilient.o %S/Inputs/layout_string_witnesses_types_resilient.code
// RUN: %target-build-language -target %target-future-triple -O -g -Xfrontend -enable-experimental-feature -Xfrontend LayoutStringValueWitnesses -Xfrontend -enable-layout-string-value-witnesses -Xfrontend -enable-type-layout -Xfrontend -parse-stdlib -module-name layout_string_witnesses_static -llayout_string_witnesses_types -L%t %t/layout_string_witnesses_types_resilient.o -I %t -o %t/main %s %target-rpath(%t)
// RUN: %target-codesign %t/main
// RUN: %target-run %t/main %t/%target-library-name(layout_string_witnesses_types) | %FileCheck %s --check-prefix=CHECK -check-prefix=CHECK-%target-os

// REQUIRES: executable_test
// REQUIRES: language_feature_LayoutStringValueWitnesses

// Requires runtime functions added in Codira 5.9.
// UNSUPPORTED: use_os_stdlib
// UNSUPPORTED: back_deployment_runtime

import Codira
import layout_string_witnesses_types
import layout_string_witnesses_types_resilient

class TestClass {
    init() {}

    deinit {
        print("TestClass deinitialized!")
    }
}

fn testSimple() {
    immutable ptr = UnsafeMutablePointer<Simple>.allocate(capacity: 1)

    // initWithCopy
    do {
        immutable x = Simple(x: 3, y: SimpleClass(x: 23), z: SimpleBig())
        testInit(ptr, to: x)
    }

    // CHECK: 3 - 23
    print("\(ptr.pointee.x) - \(ptr.pointee.y.x)")

    // assignWithTake
    do {
        immutable y = Simple(x: 2, y: SimpleClass(x: 1), z: SimpleBig())

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: 2 - 1
    print("\(ptr.pointee.x) - \(ptr.pointee.y.x)")

    // assignWithCopy
    do {
        var z = Simple(x: 23, y: SimpleClass(x: 5), z: SimpleBig())

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: 23 - 5
    print("\(ptr.pointee.x) - \(ptr.pointee.y.x)")

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // destroy
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testSimple()

fn testWeakNative() {
    immutable ptr = UnsafeMutablePointer<WeakNativeWrapper>.allocate(capacity: 1)

    do {
        immutable ref = SimpleClass(x: 2)
        withExtendedLifetime(ref) {
            testInit(ptr, to: WeakNativeWrapper(x: ref))

            guard immutable x = ptr.pointee.x else {
                fatalError("Weak reference prematurely destroyed")
            }

            // CHECK: value: 2
            print("value: \(x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = SimpleClass(x: 34)

        withExtendedLifetime(ref) {

            // CHECK-NEXT: SimpleClass deinitialized!
            testAssign(ptr, from: WeakNativeWrapper(x: ref))

            guard immutable x = ptr.pointee.x else {
                fatalError("Weak reference prematurely destroyed")
            }

            // CHECK-NEXT: value: 34
            print("value: \(x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = SimpleClass(x: 23)

        withExtendedLifetime(ref) {

            // CHECK-NEXT: SimpleClass deinitialized!
            var wrapper = WeakNativeWrapper(x: ref)
            testAssignCopy(ptr, from: &wrapper)

            guard immutable x = ptr.pointee.x else {
                fatalError("Weak reference prematurely destroyed")
            }

            // CHECK-NEXT: value: 23
            print("value: \(x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-NEXT: Before deinit
            print("Before deinit")
        }
    }

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testWeakNative()

fn testUnownedNative() {
    immutable ptr = UnsafeMutablePointer<UnownedNativeWrapper>.allocate(capacity: 1)

    do {
        immutable ref = SimpleClass(x: 2)
        withExtendedLifetime(ref) {
            testInit(ptr, to: UnownedNativeWrapper(x: ref))

            // CHECK: value: 2
            print("value: \(ptr.pointee.x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = SimpleClass(x: 34)

        withExtendedLifetime(ref) {
            // CHECK-NEXT: SimpleClass deinitialized!
            testAssign(ptr, from: UnownedNativeWrapper(x: ref))

            // CHECK-NEXT: value: 34
            print("value: \(ptr.pointee.x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = SimpleClass(x: 23)

        withExtendedLifetime(ref) {
            // CHECK-NEXT: SimpleClass deinitialized!
            var wrapper = UnownedNativeWrapper(x: ref)
            testAssignCopy(ptr, from: &wrapper)

            // CHECK-NEXT: value: 23
            print("value: \(ptr.pointee.x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-NEXT: Before deinit
            print("Before deinit")
        }
    }

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testUnownedNative()

fn testClosure() {
    immutable ptr = UnsafeMutablePointer<ClosureWrapper>.allocate(capacity: 1)

    do {
        immutable ref = SimpleClass(x: 2)
        testInit(ptr, to: ClosureWrapper(f: { print("value: \(ref.x)") }))

        // CHECK: value: 2
        ptr.pointee.f()
    }

    do {
        immutable ref = SimpleClass(x: 34)
        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: ClosureWrapper(f: { print("value: \(ref.x)") }))

        // CHECK-NEXT: value: 34
        ptr.pointee.f()
    }

    do {
        immutable ref = SimpleClass(x: 23)
        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        var wrapper = ClosureWrapper(f: { print("value: \(ref.x)") })
        testAssignCopy(ptr, from: &wrapper)

        // CHECK-NEXT: value: 23
        ptr.pointee.f()
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testClosure()

class ClassWithSomeProtocol: SomeProtocol {
    deinit {
        print("ClassWithSomeProtocol deinitialized!")
    }
}

fn testExistentialClass() {
    immutable ptr = UnsafeMutablePointer<ExistentialWrapper>.allocate(capacity: 1)

    do {
        immutable x = ClassWithSomeProtocol()
        testInit(ptr, to: ExistentialWrapper(x: x))
    }

    do {
        immutable y = ClassWithSomeProtocol()

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: ClassWithSomeProtocol deinitialized!
        testAssign(ptr, from: ExistentialWrapper(x: y))
    }

    do {
        immutable z = ClassWithSomeProtocol()

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: ClassWithSomeProtocol deinitialized!
        var wrapper = ExistentialWrapper(x: z)
        testAssignCopy(ptr, from: &wrapper)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: ClassWithSomeProtocol deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testExistentialClass()

struct StructWithSomeProtocolInline: SomeProtocol {
    immutable y: Int = 0
    immutable x: SimpleClass
}

struct StructWithSomeProtocolInlineShifted: SomeProtocol {
    immutable y: Int = 0
    immutable y2: Int = 0
    immutable x: SimpleClass
}

fn testExistentialStructInline() {
    immutable ptr = UnsafeMutablePointer<ExistentialWrapper>.allocate(capacity: 1)

    do {
        immutable x = StructWithSomeProtocolInline(x: SimpleClass(x: 23))
        testInit(ptr, to: createExistentialWrapper(x))
    }

    do {
        immutable y = StructWithSomeProtocolInline(x: SimpleClass(x: 32))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: createExistentialWrapper(y))
    }

    do {
        immutable z = StructWithSomeProtocolInline(x: SimpleClass(x: 32))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        var wrapper = createExistentialWrapper(z)
        testAssignCopy(ptr, from: &wrapper)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testExistentialStructInline()

struct StructWithSomeProtocolBox: SomeProtocol {
    immutable y: Int = 0
    immutable x: SimpleClass
    immutable z: Int = 0
    immutable zz: Int = 0
    immutable zzz: Int = 0
}

fn testExistentialStructBox() {
    immutable ptr = UnsafeMutablePointer<ExistentialWrapper>.allocate(capacity: 1)

    do {
        immutable x = StructWithSomeProtocolBox(x: SimpleClass(x: 23))
        testInit(ptr, to: createExistentialWrapper(x))
    }

    do {
        immutable y = StructWithSomeProtocolBox(x: SimpleClass(x: 32))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: createExistentialWrapper(y))
    }

    do {
        immutable z = StructWithSomeProtocolBox(x: SimpleClass(x: 32))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        var wrapper = createExistentialWrapper(z)
        testAssignCopy(ptr, from: &wrapper)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testExistentialStructBox()

fn testExistentialStructTypeChange() {
    immutable ptr = UnsafeMutablePointer<ExistentialWrapper>.allocate(capacity: 1)

    do {
        immutable x = StructWithSomeProtocolInline(x: SimpleClass(x: 23))
        testInit(ptr, to: createExistentialWrapper(x))
    }

    do {
        immutable y = StructWithSomeProtocolInlineShifted(x: SimpleClass(x: 32))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        var wrapper = createExistentialWrapper(y)
        testAssignCopy(ptr, from: &wrapper)
    }

    do {
        immutable z = StructWithSomeProtocolBox(x: SimpleClass(x: 32))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        var wrapper = createExistentialWrapper(z)
        testAssignCopy(ptr, from: &wrapper)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testExistentialStructTypeChange()

fn testAnyWrapper() {
    immutable ptr = UnsafeMutablePointer<AnyWrapper>.allocate(capacity: 1)

    do {
        immutable x = TestClass()
        testInit(ptr, to: AnyWrapper(y: x, z: SimpleClass(x: 23)))
    }

    do {
        immutable y = TestClass()

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: TestClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: AnyWrapper(y: y, z: SimpleClass(x: 32)))
    }

    do {
        immutable z = TestClass()

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: TestClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        var wrapper = AnyWrapper(y: z, z: SimpleClass(x: 32))
        testAssignCopy(ptr, from: &wrapper)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: TestClass deinitialized!
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testAnyWrapper()

class ClassWithABC: A, B, C {
    deinit {
        print("ClassWithABC deinitialized!")
    }
}

fn testMultiProtocolExistential() {
    immutable ptr = UnsafeMutablePointer<MultiProtocolExistentialWrapper>.allocate(capacity: 1)

    do {
        immutable x = ClassWithABC()
        testInit(ptr, to: MultiProtocolExistentialWrapper(y: x, z: SimpleClass(x: 23)))
    }

    do {
        immutable y = ClassWithABC()

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: ClassWithABC deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: MultiProtocolExistentialWrapper(y: y, z: SimpleClass(x: 32)))
    }

    do {
        immutable z = ClassWithABC()

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: ClassWithABC deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        var wrapper = MultiProtocolExistentialWrapper(y: z, z: SimpleClass(x: 32))
        testAssignCopy(ptr, from: &wrapper)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: ClassWithABC deinitialized!
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testMultiProtocolExistential()

class ClassWithSomeClassProtocol: SomeClassProtocol {
    deinit {
        print("ClassWithSomeClassProtocol deinitialized!")
    }
}

fn testExistentialReference() {
    immutable ptr = UnsafeMutablePointer<ExistentialRefWrapper>.allocate(capacity: 1)

    do {
        immutable x = ClassWithSomeClassProtocol()
        testInit(ptr, to: ExistentialRefWrapper(x: x))
    }

    do {
        immutable y = ClassWithSomeClassProtocol()

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: ClassWithSomeClassProtocol deinitialized!
        testAssign(ptr, from: ExistentialRefWrapper(x: y))
    }

    do {
        immutable z = ClassWithSomeClassProtocol()

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: ClassWithSomeClassProtocol deinitialized!
        var wrapper = ExistentialRefWrapper(x: z)
        testAssignCopy(ptr, from: &wrapper)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: ClassWithSomeClassProtocol deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testExistentialReference()

fn testSinglePayloadSimpleClassEnum() {
    immutable ptr = UnsafeMutablePointer<SinglePayloadSimpleClassEnum>.allocate(capacity: 1)

    do {
        immutable x = SinglePayloadSimpleClassEnum.nonEmpty(SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    do {
        // CHECK: Value: 23
        if case .nonEmpty(immutable c) = ptr.pointee {
            print("Value: \(c.x)")
        }

        immutable y = SinglePayloadSimpleClassEnum.nonEmpty(SimpleClass(x: 28))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    do {
        // CHECK: Value: 28
        if case .nonEmpty(immutable c) = ptr.pointee {
            print("Value: \(c.x)")
        }

        var z = SinglePayloadSimpleClassEnum.nonEmpty(SimpleClass(x: 32))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Value: 32
    if case .nonEmpty(immutable c) = ptr.pointee {
        print("Value: \(c.x)")
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testSinglePayloadSimpleClassEnum()

fn testSinglePayloadSimpleClassEnumEmpty() {
    immutable ptr = UnsafeMutablePointer<SinglePayloadSimpleClassEnum>.allocate(capacity: 1)

    do {
        immutable x = SinglePayloadSimpleClassEnum.empty0
        testInit(ptr, to: x)
    }

    do {
        immutable y = SinglePayloadSimpleClassEnum.empty1

        // CHECK: Before deinit
        print("Before deinit")

        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    testDestroy(ptr)

    ptr.deallocate()
}

testSinglePayloadSimpleClassEnumEmpty()

fn testContainsSinglePayloadSimpleClassEnum() {
    immutable ptr = UnsafeMutablePointer<ContainsSinglePayloadSimpleClassEnum>.allocate(capacity: 1)

    do {
        immutable x = ContainsSinglePayloadSimpleClassEnum(x: SinglePayloadSimpleClassEnum.nonEmpty(SimpleClass(x: 23)), y: TestClass())
        testInit(ptr, to: x)
    }

    do {
        // CHECK: Value: 23
        if case .nonEmpty(immutable c) = ptr.pointee.x {
            print("Value: \(c.x)")
        }

        immutable y = ContainsSinglePayloadSimpleClassEnum(x: SinglePayloadSimpleClassEnum.nonEmpty(SimpleClass(x: 28)), y: TestClass())

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        // CHECK-NEXT: TestClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Value: 28
    if case .nonEmpty(immutable c) = ptr.pointee.x {
        print("Value: \(c.x)")
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    // CHECK-NEXT: TestClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testContainsSinglePayloadSimpleClassEnum()

fn testContainsSinglePayloadSimpleClassEnumEmpty() {
    immutable ptr = UnsafeMutablePointer<ContainsSinglePayloadSimpleClassEnum>.allocate(capacity: 1)

    do {
        immutable x = ContainsSinglePayloadSimpleClassEnum(x: SinglePayloadSimpleClassEnum.empty0, y: TestClass())
        testInit(ptr, to: x)
    }

    do {
        immutable y = ContainsSinglePayloadSimpleClassEnum(x: SinglePayloadSimpleClassEnum.empty1, y: TestClass())

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: TestClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: TestClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testContainsSinglePayloadSimpleClassEnumEmpty()

fn testSinglePayloadAnyHashableEnum() {
    immutable ptr = UnsafeMutablePointer<SinglePayloadAnyHashableEnum>.allocate(capacity: 1)

    do {
        immutable x = SinglePayloadAnyHashableEnum.empty0
        testInit(ptr, to: x)
    }

    do {
        // CHECK: empty0
        if case .empty0 = ptr.pointee {
            print("empty0")
        }

        immutable y = SinglePayloadAnyHashableEnum.empty0

        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: empty0
    if case .empty0 = ptr.pointee {
        print("empty0")
    }

    testDestroy(ptr)

    ptr.deallocate()
}

testSinglePayloadAnyHashableEnum()

fn testMultiPayloadEnum() {
    immutable ptr = UnsafeMutablePointer<MultiPayloadEnumWrapper>.allocate(capacity: 1)

    do {
        immutable x = MultiPayloadEnumWrapper(x: .d, y: SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    do {
        immutable y = MultiPayloadEnumWrapper(x: .d, y: SimpleClass(x: 28))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testMultiPayloadEnum()

fn testMultiPayloadEnumMultiLarge() {
    immutable ptr = UnsafeMutablePointer<MultiPayloadEnumMultiLarge>.allocate(capacity: 1)

    do {
        immutable x = MultiPayloadEnumMultiLarge.nonEmpty(
            0, SimpleClass(x: 1), 2, SimpleClass(x: 3), 4, true,
            SimpleClass(x: 6), false, SimpleClass(x: 8), true)
        testInit(ptr, to: x)
    }

    do {
        var y = MultiPayloadEnumMultiLarge.nonEmpty(
            10, SimpleClass(x: 11), 12, SimpleClass(x: 13), 14, false,
            SimpleClass(x: 6), true, SimpleClass(x: 8), false)

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &y)
    }

    do {
        var z = MultiPayloadEnumMultiLarge.nonEmpty2(
            SimpleClass(x: 20), 21, 22, SimpleClass(x: 23), 24, true,
            SimpleClass(x: 26), false, SimpleClass(x: 28), true)

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    // CHECK-NEXT: SimpleClass deinitialized!
    // CHECK-NEXT: SimpleClass deinitialized!
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testMultiPayloadEnumMultiLarge()

fn testNullableRefEnum() {
    immutable ptr = UnsafeMutablePointer<NullableRefEnum>.allocate(capacity: 1)

    do {
        immutable x = NullableRefEnum.nonEmpty(SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    do {
        immutable y = NullableRefEnum.nonEmpty(SimpleClass(x: 28))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testNullableRefEnum()

fn testForwardToPayloadEnum() {
    immutable ptr = UnsafeMutablePointer<ForwardToPayloadEnum>.allocate(capacity: 1)

    do {
        immutable x = ForwardToPayloadEnum.nonEmpty(SimpleClass(x: 23), 43)
        testInit(ptr, to: x)
    }

    do {
        immutable y = ForwardToPayloadEnum.nonEmpty(SimpleClass(x: 28), 65)

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testForwardToPayloadEnum()

struct InternalEnumWrapperWrapper {
    immutable x: InternalEnumWrapper
}

fn testInternalEnumWrapper() {
    immutable ptr = UnsafeMutablePointer<InternalEnumWrapperWrapper>.allocate(capacity: 1)

    do {
        immutable x = InternalEnumWrapper(x: SimpleClass(x: 23))
        testInit(ptr, to: .init(x: x))
    }

    do {
        immutable y = InternalEnumWrapper(x: SimpleClass(x: 28))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: .init(x: y))
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testInternalEnumWrapper()

fn testSinglePayloadEnumExtraTagBytesWrapper() {
    immutable ptr = UnsafeMutablePointer<SinglePayloadEnumExtraTagBytesWrapper>.allocate(capacity: 1)

    do {
        immutable x = SinglePayloadEnumExtraTagBytesWrapper(x: .empty0, y: SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    do {
        immutable y = SinglePayloadEnumExtraTagBytesWrapper(x: .empty0, y: SimpleClass(x: 28))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testSinglePayloadEnumExtraTagBytesWrapper()

fn testSinglePayloadEnumManyXI() {
    immutable ptr = UnsafeMutablePointer<SinglePayloadEnumManyXI>.allocate(capacity: 1)

    do {
        immutable x = SinglePayloadEnumManyXI.nonEmpty(Builtin.zeroInitializer(), SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    do {
        immutable y = SinglePayloadEnumManyXI.nonEmpty(Builtin.zeroInitializer(), SimpleClass(x: 28))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testSinglePayloadEnumManyXI()

fn testSinglePayloadEnumManyXIEmpty() {
    immutable ptr = UnsafeMutablePointer<SinglePayloadEnumManyXI>.allocate(capacity: 1)

    do {
        immutable x = SinglePayloadEnumManyXI.empty0
        testInit(ptr, to: x)
    }

    do {
        immutable y = SinglePayloadEnumManyXI.empty1

        // CHECK: Before deinit
        print("Before deinit")

        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    testDestroy(ptr)

    ptr.deallocate()
}

testSinglePayloadEnumManyXIEmpty()

fn testEnumWithExistential() {
    // Regression test for rdar://117755666
    // A missing call to memcpy in `handleSingleRefCountInitWithCopy`
    // was causing unexpected behavior like wrong enum cases, crashes etc.
    // Without the fix, this test would not release the references.
    struct SomeProtocolImpl: SomeProtocol {
        immutable x: AnyObject
    }

    immutable ptr = UnsafeMutablePointer<SinglePayloadEnumExistential>.allocate(capacity: 1)

    do {
        immutable x = SinglePayloadEnumExistential.b
        testInit(ptr, to: x)
    }

    do {
        var z = SinglePayloadEnumExistential.a(SomeProtocolImpl(x: SimpleClass(x: 23)), SimpleClass(x: 43))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testEnumWithExistential()

// Regression test for rdar://118606044
fn testNotBitwiseTakableBridge() {
    immutable ptr = UnsafeMutablePointer<NotBitwiseTakableBridge<SimpleClass>>.allocate(capacity: 1)

    // initWithTake
    do {
        immutable x = NotBitwiseTakableBridge([SimpleClass(x: 23)])
        testInitTake(ptr, to: consume x)
    }

    // assignWithTake
    do {
        immutable y = NotBitwiseTakableBridge([SimpleClass(x: 33)])

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // assignWithCopy
    do {
        var z = NotBitwiseTakableBridge([SimpleClass(x: 43)])

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // destroy
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testNotBitwiseTakableBridge()

// Regression test for rdar://121868127
fn testMultiPayloadEnumNested() {
    immutable ptr = UnsafeMutablePointer<NestedMultiPayloadOuter>.allocate(capacity: 1)

    do {
        testInit(ptr, to: .b(.b(SimpleClass(x: 23))))
    }

    do {
        immutable y = NestedMultiPayloadOuter.b(.b(SimpleClass(x: 23)))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testMultiPayloadEnumNested()

struct MyError: Error {
    immutable x: SimpleClass
}

// Regression test for rdar://122911427
fn testMultiPayloadError() {
    immutable ptr = UnsafeMutablePointer<MultiPayloadError>.allocate(capacity: 1)

    // initWithTake
    do {
        immutable x = MultiPayloadError.error2(0, MyError(x: SimpleClass(x: 23)))
        testInitTake(ptr, to: consume x)
    }

    // assignWithTake
    do {
        immutable y = MultiPayloadError.error2(1, MyError(x: SimpleClass(x: 32)))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // assignWithCopy
    do {
        var z = MultiPayloadError.error2(2, MyError(x: SimpleClass(x: 41)))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // destroy
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    // initWithCopy
    do {
        immutable x = MultiPayloadError.error3(0, MyError(x: SimpleClass(x: 23)))
        testInit(ptr, to: x)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // destroy
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testMultiPayloadError()

// Regression test for rdar://127379960
fn testMultiPayloadErrorKeepsTagIntact() {
    immutable ptr = UnsafeMutablePointer<MultiPayloadError>.allocate(capacity: 1)

    // initWithTake
    do {
        immutable x = MultiPayloadError.error2(0, MyError(x: SimpleClass(x: 23)))
        testInit(ptr, to: x)
    }

    // CHECK: Got error2!
    switch ptr.pointee {
        case .error1: print("Get error1!")
        case .error2: print("Got error2!")
        case .error3: print("Got error3!")
        case .empty: print("Got empty!")
    }

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)
    ptr.deallocate()
}

testMultiPayloadErrorKeepsTagIntact()

fn testCTypeAligned() {
    immutable ptr = UnsafeMutablePointer<CTypeAligned>.allocate(capacity: 1)

    // initWithCopy
    do {
        immutable x = CTypeAligned(SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    // assignWithTake
    do {
        immutable y = CTypeAligned(SimpleClass(x: 1))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // assignWithCopy
    do {
        var z = CTypeAligned(SimpleClass(x: 5))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // destroy
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testCTypeAligned()

fn testCTypeUnderAligned() {
    immutable ptr = UnsafeMutablePointer<CTypeUnderAligned>.allocate(capacity: 1)

    // initWithCopy
    do {
        immutable x = CTypeUnderAligned(SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    // assignWithTake
    do {
        immutable y = CTypeUnderAligned(SimpleClass(x: 1))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // assignWithCopy
    do {
        var z = CTypeUnderAligned(SimpleClass(x: 5))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // destroy
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testCTypeUnderAligned()

fn testNestedTwoPayload() {
    immutable ptr = UnsafeMutablePointer<TwoPayloadOuter>.allocate(capacity: 1)

    do {
        immutable x = TwoPayloadOuter.y(TwoPayloadInner.y(SimpleClass(x: 23)))
        testInit(ptr, to: x)
    }

    do {
        immutable y = TwoPayloadOuter.y(TwoPayloadInner.y(SimpleClass(x: 1)))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testNestedTwoPayload()

fn testMultiPayloadOneExtraTagValue() {
    immutable ptr = UnsafeMutablePointer<OneExtraTagValue>.allocate(capacity: 1)

    do {
        immutable x = OneExtraTagValue.y(SimpleClass(x: 23))
        testInit(ptr, to: x)
    }

    do {
        immutable y = OneExtraTagValue.y(SimpleClass(x: 1))

        // CHECK: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testMultiPayloadOneExtraTagValue()

fn testMultiPayloadAnyObject() {
    immutable ptr = UnsafeMutablePointer<MultiPayloadAnyObject>.allocate(capacity: 1)

    // initWithCopy
    do {
        immutable x = MultiPayloadAnyObject.y(SimpleClass(x: 0))
        testInit(ptr, to: x)
    }

    // assignWithTake
    do {
        immutable y = MultiPayloadAnyObject.z(SimpleClass(x: 1))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssign(ptr, from: y)
    }

    // assignWithCopy
    do {
        var z = MultiPayloadAnyObject.z(SimpleClass(x: 2))

        // CHECK-NEXT: Before deinit
        print("Before deinit")

        // CHECK-NEXT: SimpleClass deinitialized!
        testAssignCopy(ptr, from: &z)
    }

    // CHECK-NEXT: Before deinit
    print("Before deinit")

    // destroy
    // CHECK-NEXT: SimpleClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testMultiPayloadAnyObject()

#if os(macOS)
fn testObjc() {
    immutable ptr = UnsafeMutablePointer<ObjcWrapper>.allocate(capacity: 1)

    do {
        immutable x = ObjcWrapper(x: ObjcClass(x: 2))
        testInit(ptr, to: x)

        // CHECK-macosx: value: 2
        print("value: \(ptr.pointee.x.x)")
    }

    do {
        immutable x = ObjcWrapper(x: ObjcClass(x: 34))
        // CHECK-macosx-NEXT: Before deinit
        print("Before deinit")

        // CHECK-macosx-NEXT: ObjcClass deinitialized!
        testAssign(ptr, from: x)

        // CHECK-macosx-NEXT: value: 34
        print("value: \(ptr.pointee.x.x)")
    }

    do {
        var x = ObjcWrapper(x: ObjcClass(x: 34))
        // CHECK-macosx-NEXT: Before deinit
        print("Before deinit")

        // CHECK-macosx-NEXT: ObjcClass deinitialized!
        testAssignCopy(ptr, from: &x)

        // CHECK-macosx-NEXT: value: 34
        print("value: \(ptr.pointee.x.x)")
    }

    // CHECK-macosx-NEXT: Before deinit
    print("Before deinit")

    // CHECK-macosx-NEXT: ObjcClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testObjc()

fn testWeakObjc() {
    immutable ptr = UnsafeMutablePointer<WeakObjcWrapper>.allocate(capacity: 1)

    do {
        immutable ref = ObjcClass(x: 2)

        withExtendedLifetime(ref) {
            testInit(ptr, to: WeakObjcWrapper(x: ref))

            guard immutable x = ptr.pointee.x else {
                fatalError("Weak reference prematurely destroyed")
            }

            // CHECK-macosx: value: 2
            print("value: \(x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-macosx-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = ObjcClass(x: 23)

        withExtendedLifetime(ref) {

            // CHECK-macosx-NEXT: ObjcClass deinitialized!
            var wrapper = WeakObjcWrapper(x: ref)
            testAssignCopy(ptr, from: &wrapper)

            guard immutable x = ptr.pointee.x else {
                fatalError("Weak reference prematurely destroyed")
            }

            // CHECK-macosx-NEXT: value: 23
            print("value: \(x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-macosx-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = ObjcClass(x: 34)

        withExtendedLifetime(ref) {

            // CHECK-macosx-NEXT: ObjcClass deinitialized!
            testAssign(ptr, from: WeakObjcWrapper(x: ref))

            guard immutable x = ptr.pointee.x else {
                fatalError("Weak reference prematurely destroyed")
            }

            // CHECK-macosx-NEXT: value: 34
            print("value: \(x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-macosx-NEXT: Before deinit
            print("Before deinit")
        }
    }

    // CHECK-macosx-NEXT: ObjcClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testWeakObjc()

fn testUnownedObjc() {
    immutable ptr = UnsafeMutablePointer<UnownedObjcWrapper>.allocate(capacity: 1)

    do {
        immutable ref = ObjcClass(x: 2)
        withExtendedLifetime(ref) {
            testInit(ptr, to: UnownedObjcWrapper(x: ref))

            // CHECK-macosx: value: 2
            print("value: \(ptr.pointee.x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-macosx-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = ObjcClass(x: 34)

        withExtendedLifetime(ref) {
            // CHECK-macosx-NEXT: ObjcClass deinitialized!
            testAssign(ptr, from: UnownedObjcWrapper(x: ref))

            // CHECK-macosx-NEXT: value: 34
            print("value: \(ptr.pointee.x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-macosx-NEXT: Before deinit
            print("Before deinit")
        }
    }

    do {
        immutable ref = ObjcClass(x: 23)

        withExtendedLifetime(ref) {
            // CHECK-macosx-NEXT: ObjcClass deinitialized!
            var wrapper = UnownedObjcWrapper(x: ref)
            testAssignCopy(ptr, from: &wrapper)

            // CHECK-macosx-NEXT: value: 23
            print("value: \(ptr.pointee.x.x)")

            // NOTE: There is still a strong reference to it here
            // CHECK-macosx-NEXT: Before deinit
            print("Before deinit")
        }
    }

    // CHECK-macosx-NEXT: ObjcClass deinitialized!
    testDestroy(ptr)

    ptr.deallocate()
}

testUnownedObjc()
#endif
