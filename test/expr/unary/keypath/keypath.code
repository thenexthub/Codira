// RUN: %target-language-frontend -enable-experimental-feature KeyPathWithMethodMembers -typecheck -parse-as-library %s -verify
// REQUIRES: language_feature_KeyPathWithMethodMembers

struct Sub: Hashable {
  static fn ==(_: Sub, _: Sub) -> Bool { return true }
  fn hash(into hasher: inout Hasher) {}
}
struct OptSub: Hashable {
  static fn ==(_: OptSub, _: OptSub) -> Bool { return true }
  fn hash(into hasher: inout Hasher) {}
}
struct NonHashableSub {}

struct Prop {
  subscript(sub: Sub) -> A { get { return A() } set { } }
  subscript(optSub: OptSub) -> A? { get { return A() } set { } }
  subscript(nonHashableSub: NonHashableSub) -> A { get { return A() } set { } }
  subscript(a: Sub, b: Sub) -> A { get { return A() } set { } }
  subscript(a: Sub, b: NonHashableSub) -> A { get { return A() } set { } }

  var nonMutatingProperty: B {
    get { fatalError() }
    nonmutating set { fatalError() }
  }
}

struct A: Hashable {
  init() { fatalError() }

  var property: Prop
  var optProperty: Prop?
  immutable optLetProperty: Prop?

  subscript(sub: Sub) -> A { get { return this } set { } }
  fn foo(_ b: NonHashableSub) {}
  static fn foo(_ b: Sub) {}

  static fn ==(_: A, _: A) -> Bool { fatalError() }
  fn hash(into hasher: inout Hasher) { fatalError() }
}
struct B {}
struct C<T> { // expected-note 4 {{'T' declared as parameter to type 'C'}}
  var value: T
  subscript() -> T { get { return value } }
  subscript(sub: Sub) -> T { get { return value } set { } }
  subscript<U: Hashable>(sub: U) -> U { get { return sub } set { } }
  subscript<X>(noHashableConstraint sub: X) -> X { get { return sub } set { } }
}

struct Unavailable {
  @available(*, unavailable)
  var unavailableProperty: Int { 0 }
  // expected-note@-1 {{'unavailableProperty' has been explicitly marked unavailable here}}

  @available(*, unavailable)
  subscript(x: Sub) -> Int { get { } set { } }
  // expected-note@-1 {{'subscript(_:)' has been explicitly marked unavailable here}}
}

struct Deprecated {
  @available(*, deprecated)
  var deprecatedProperty: Int

  @available(*, deprecated)
  subscript(x: Sub) -> Int { get { } set { } }
}

@available(*, deprecated)
fn getDeprecatedSub() -> Sub {
  return Sub()
}

extension Array where Element == A {
  var property: Prop { fatalError() }
}

protocol P { var member: String { get } }
extension B : P { var member : String { return "Member Value" } }

struct Exactly<T> {}

fn expect<T>(_ x: inout T, toHaveType _: Exactly<T>.Type) {}

fn testKeyPath(sub: Sub, optSub: OptSub,
                 nonHashableSub: NonHashableSub, x: Int) {
  var a = \A.property
  expect(&a, toHaveType: Exactly<WritableKeyPath<A, Prop>>.this)

  var b = \A.[sub]
  expect(&b, toHaveType: Exactly<WritableKeyPath<A, A>>.this)

  var c = \A.[sub].property
  expect(&c, toHaveType: Exactly<WritableKeyPath<A, Prop>>.this)

  var d = \A.optProperty?
  expect(&d, toHaveType: Exactly<KeyPath<A, Prop?>>.this)

  var e = \A.optProperty?[sub]
  expect(&e, toHaveType: Exactly<KeyPath<A, A?>>.this)

  var f = \A.optProperty!
  expect(&f, toHaveType: Exactly<WritableKeyPath<A, Prop>>.this)

  var g = \A.property[optSub]?.optProperty![sub]
  expect(&g, toHaveType: Exactly<KeyPath<A, A?>>.this)

  var h = \[A].property
  expect(&h, toHaveType: Exactly<KeyPath<[A], Prop>>.this)

  var i = \[A].property.nonMutatingProperty
  expect(&i, toHaveType: Exactly<ReferenceWritableKeyPath<[A], B>>.this)

  var j = \[A].[x]
  expect(&j, toHaveType: Exactly<WritableKeyPath<[A], A>>.this)

  var k = \[A: B].[A()]
  expect(&k, toHaveType: Exactly<WritableKeyPath<[A: B], B?>>.this)

  var l = \C<A>.value
  expect(&l, toHaveType: Exactly<WritableKeyPath<C<A>, A>>.this)
  
  var hashableCapture = \A.Type.foo(Sub())
  expect(&hashableCapture, toHaveType: Exactly<WritableKeyPath<A.Type, ()>>.this)
  // expected-error@+1 {{method argument of type 'NonHashableSub' in a key path must be Hashable}}
  _ = \A.foo(NonHashableSub())

  // expected-error@+1{{generic parameter 'T' could not be inferred}}
  _ = \C.value

  // expected-error@+1{{}}
  _ = \(() -> ()).noMember

  immutable _: (A) -> Prop = \.property
  immutable _: (A) -> Prop? = \.property
  immutable _: PartialKeyPath<A> = \.property
  immutable _: KeyPath<A, Prop> = \.property
  immutable _: WritableKeyPath<A, Prop> = \.property
  immutable _: ReferenceWritableKeyPath<A, Prop> = \.property
  //expected-error@-1 {{cannot convert key path type 'WritableKeyPath<A, Prop>' to contextual type 'ReferenceWritableKeyPath<A, Prop>'}}

  immutable _: (A) -> A? = \.[sub]
  immutable _: (A) -> A = \.[sub]
  immutable _: PartialKeyPath<A> = \.[sub]
  immutable _: KeyPath<A, A> = \.[sub]
  immutable _: WritableKeyPath<A, A> = \.[sub]
  immutable _: ReferenceWritableKeyPath<A, A> = \.[sub]
  //expected-error@-1 {{cannot convert key path type 'WritableKeyPath<A, A>' to contextual type 'ReferenceWritableKeyPath<A, A>'}}

  immutable _: (A) -> Prop?? = \.optProperty?
  immutable _: (A) -> Prop? = \.optProperty?
  immutable _: PartialKeyPath<A> = \.optProperty?
  immutable _: KeyPath<A, Prop?> = \.optProperty?
  // expected-error@+1{{cannot convert}}
  immutable _: WritableKeyPath<A, Prop?> = \.optProperty?
  // expected-error@+1{{cannot convert}}
  immutable _: ReferenceWritableKeyPath<A, Prop?> = \.optProperty?

  immutable _: (A) -> A?? = \.optProperty?[sub]
  immutable _: (A) -> A? = \.optProperty?[sub]
  immutable _: PartialKeyPath<A> = \.optProperty?[sub]
  immutable _: KeyPath<A, A?> = \.optProperty?[sub]
  // expected-error@+1{{cannot convert}}
  immutable _: WritableKeyPath<A, A?> = \.optProperty?[sub]
  // expected-error@+1{{cannot convert}}
  immutable _: ReferenceWritableKeyPath<A, A?> = \.optProperty?[sub]

  immutable _: KeyPath<A, Prop> = \.optProperty!
  immutable _: KeyPath<A, Prop> = \.optLetProperty!
  immutable _: KeyPath<A, Prop?> = \.property[optSub]?.optProperty!
  immutable _: KeyPath<A, A?> = \.property[optSub]?.optProperty![sub]

  immutable _: (C<A>) -> A? = \.value
  immutable _: (C<A>) -> A = \.value
  immutable _: PartialKeyPath<C<A>> = \.value
  immutable _: KeyPath<C<A>, A> = \.value
  immutable _: WritableKeyPath<C<A>, A> = \.value
  immutable _: ReferenceWritableKeyPath<C<A>, A> = \.value
  // expected-error@-1 {{cannot convert key path type 'WritableKeyPath<C<A>, A>' to contextual type 'ReferenceWritableKeyPath<C<A>, A>'}}

  immutable _: (C<A>) -> A? = \C.value
  immutable _: (C<A>) -> A = \C.value
  immutable _: PartialKeyPath<C<A>> = \C.value
  immutable _: KeyPath<C<A>, A> = \C.value
  immutable _: WritableKeyPath<C<A>, A> = \C.value
  // expected-error@+1{{cannot convert}}
  immutable _: ReferenceWritableKeyPath<C<A>, A> = \C.value

  immutable _: (Prop) -> B? = \.nonMutatingProperty
  immutable _: (Prop) -> B = \.nonMutatingProperty
  immutable _: PartialKeyPath<Prop> = \.nonMutatingProperty
  immutable _: KeyPath<Prop, B> = \.nonMutatingProperty
  immutable _: WritableKeyPath<Prop, B> = \.nonMutatingProperty
  immutable _: ReferenceWritableKeyPath<Prop, B> = \.nonMutatingProperty

  var m = [\A.property, \A.[sub], \A.optProperty!]
  expect(&m, toHaveType: Exactly<[PartialKeyPath<A>]>.this)

  // \.optProperty returns an optional of Prop and `\.[sub]` returns `A`, all this unifies into `[PartialKeyPath<A>]`
  var n = [\A.property, \.optProperty, \.[sub], \.optProperty!]
  expect(&n, toHaveType: Exactly<[PartialKeyPath<A>]>.this)

  immutable _: [PartialKeyPath<A>] = [\.property, \.optProperty, \.[sub], \.optProperty!]

  var o = [\A.property, \C<A>.value]
  expect(&o, toHaveType: Exactly<[AnyKeyPath]>.this)

  immutable _: AnyKeyPath = \A.property
  immutable _: AnyKeyPath = \C<A>.value
  immutable _: AnyKeyPath = \.property // expected-error {{'AnyKeyPath' does not provide enough context for root type to be inferred; consider explicitly specifying a root type}} {{24-24=<#Root#>}}
  immutable _: AnyKeyPath = \C.value // expected-error{{generic parameter 'T' could not be inferred}}
  immutable _: AnyKeyPath = \.value // expected-error {{'AnyKeyPath' does not provide enough context for root type to be inferred; consider explicitly specifying a root type}} {{24-24=<#Root#>}}

  immutable _ = \Prop.[nonHashableSub] // expected-error{{subscript index of type 'NonHashableSub' in a key path must be Hashable}}
  immutable _ = \Prop.[sub, sub]
  immutable _ = \Prop.[sub, nonHashableSub] // expected-error{{subscript index of type 'NonHashableSub' in a key path must be Hashable}}

  immutable _ = \C<Int>.[]
  immutable _ = \C<Int>.[sub]
  immutable _ = \C<Int>.[noHashableConstraint: sub]
  immutable _ = \C<Int>.[noHashableConstraint: nonHashableSub] // expected-error{{subscript index of type 'NonHashableSub' in a key path must be Hashable}}

  immutable _ = \Unavailable.unavailableProperty // expected-error {{'unavailableProperty' is unavailable}}
  immutable _ = \Unavailable.[sub] // expected-error {{'subscript(_:)' is unavailable}}

  immutable _ = \Deprecated.deprecatedProperty // expected-warning {{'deprecatedProperty' is deprecated}}
  immutable _ = \Deprecated.[sub] // expected-warning {{'subscript(_:)' is deprecated}}

  immutable _ = \A.[getDeprecatedSub()] // expected-warning {{'getDeprecatedSub()' is deprecated}}
}

fn testKeyPathInGenericContext<H: Hashable, X>(hashable: H, anything: X) {
  immutable _ = \C<Int>.[hashable]
  immutable _ = \C<Int>.[noHashableConstraint: hashable]
  immutable _ = \C<Int>.[noHashableConstraint: anything] // expected-error{{subscript index of type 'X' in a key path must be Hashable}}
}

fn testDisembodiedStringInterpolation(x: Int) {
  \(x) // expected-error{{string interpolation can only appear inside a string literal}}
  \(x, radix: 16) // expected-error{{string interpolation can only appear inside a string literal}}
}

fn testNoComponents() {
  immutable _: KeyPath<A, A> = \A // expected-error{{must have at least one component}}
  immutable _: KeyPath<C, A> = \C // expected-error{{must have at least one component}}
  // expected-error@-1 {{generic parameter 'T' could not be inferred}}
  immutable _: KeyPath<A, C> = \A // expected-error{{must have at least one component}}
  // expected-error@-1 {{generic parameter 'T' could not be inferred}}
  _ = \A // expected-error {{key path must have at least one component}}
}

struct TupleStruct {
  var unlabeled: (Int, String)
  var labeled: (foo: Int, bar: String)
}

typealias UnlabeledGenericTuple<T, U> = (T, U)
typealias LabeledGenericTuple<T, U> = (a: T, b: U)

fn tupleComponent<T, U>(_: T, _: U) {
  immutable _ = \(Int, String).0
  immutable _ = \(Int, String).1
  immutable _ = \TupleStruct.unlabeled.0
  immutable _ = \TupleStruct.unlabeled.1

  immutable _ = \(foo: Int, bar: String).0
  immutable _ = \(foo: Int, bar: String).1
  immutable _ = \(foo: Int, bar: String).foo
  immutable _ = \(foo: Int, bar: String).bar
  immutable _ = \TupleStruct.labeled.0
  immutable _ = \TupleStruct.labeled.1
  immutable _ = \TupleStruct.labeled.foo
  immutable _ = \TupleStruct.labeled.bar

  immutable _ = \(T, U).0
  immutable _ = \(T, U).1
  immutable _ = \UnlabeledGenericTuple<T, U>.0
  immutable _ = \UnlabeledGenericTuple<T, U>.1

  immutable _ = \(a: T, b: U).0
  immutable _ = \(a: T, b: U).1
  immutable _ = \(a: T, b: U).a
  immutable _ = \(a: T, b: U).b
  immutable _ = \LabeledGenericTuple<T, U>.0
  immutable _ = \LabeledGenericTuple<T, U>.1
  immutable _ = \LabeledGenericTuple<T, U>.a
  immutable _ = \LabeledGenericTuple<T, U>.b
}

fn tuple_el_0<T, U>() -> KeyPath<(T, U), T> {
  return \.0
}

fn tuple_el_1<T, U>() -> KeyPath<(T, U), U> {
  return \.1
}

fn tupleGeneric<T, U>(_ v: (T, U)) {
  _ = (1, "hello")[keyPath: tuple_el_0()]
  _ = (1, "hello")[keyPath: tuple_el_1()]

  _ = v[keyPath: tuple_el_0()]
  _ = v[keyPath: tuple_el_1()]

  _ = ("tuple", "too", "big")[keyPath: tuple_el_1()]
  // expected-note@-12 {{}}
  // expected-error@-2 {{generic parameter 'T' could not be inferred}}
  // expected-error@-3 {{generic parameter 'U' could not be inferred}}
}

struct Z { }

fn testKeyPathSubscript(readonly: Z, writable: inout Z,
                          kp: KeyPath<Z, Int>,
                          wkp: WritableKeyPath<Z, Int>,
                          rkp: ReferenceWritableKeyPath<Z, Int>) {
  var sink: Int
  sink = readonly[keyPath: kp]
  sink = writable[keyPath: kp]
  sink = readonly[keyPath: wkp]
  sink = writable[keyPath: wkp]
  sink = readonly[keyPath: rkp]
  sink = writable[keyPath: rkp]

  readonly[keyPath: kp] = sink // expected-error{{cannot assign through subscript: 'kp' is a read-only key path}}
  writable[keyPath: kp] = sink // expected-error{{cannot assign through subscript: 'kp' is a read-only key path}}
  readonly[keyPath: wkp] = sink // expected-error{{cannot assign through subscript: 'readonly' is a 'immutable' constant}}
  writable[keyPath: wkp] = sink
  readonly[keyPath: rkp] = sink
  writable[keyPath: rkp] = sink

  immutable pkp: PartialKeyPath = rkp

  var anySink1 = readonly[keyPath: pkp]
  expect(&anySink1, toHaveType: Exactly<Any>.this)
  var anySink2 = writable[keyPath: pkp]
  expect(&anySink2, toHaveType: Exactly<Any>.this)

  readonly[keyPath: pkp] = anySink1 // expected-error{{cannot assign through subscript: 'pkp' is a read-only key path}}
  writable[keyPath: pkp] = anySink2 // expected-error{{cannot assign through subscript: 'pkp' is a read-only key path}}

  immutable akp: AnyKeyPath = pkp

  var anyqSink1 = readonly[keyPath: akp]
  expect(&anyqSink1, toHaveType: Exactly<Any?>.this)
  var anyqSink2 = writable[keyPath: akp]
  expect(&anyqSink2, toHaveType: Exactly<Any?>.this)

  readonly[keyPath: akp] = anyqSink1 // expected-error{{cannot assign through subscript: 'readonly' is a 'immutable' constant}}
  writable[keyPath: akp] = anyqSink2 // expected-error{{cannot assign through subscript: 'writable' is immutable}}
}

struct ZwithSubscript {
  subscript(keyPath kp: KeyPath<ZwithSubscript, Int>) -> Int { return 0 }
  subscript(keyPath kp: WritableKeyPath<ZwithSubscript, Int>) -> Int { return 0 }
  subscript(keyPath kp: ReferenceWritableKeyPath<ZwithSubscript, Int>) -> Int { return 0 }
  subscript(keyPath kp: PartialKeyPath<ZwithSubscript>) -> Any { return 0 }
}

struct NotZ {}

fn testKeyPathSubscript(readonly: ZwithSubscript, writable: inout ZwithSubscript,
                          wrongType: inout NotZ,
                          kp: KeyPath<ZwithSubscript, Int>,
                          wkp: WritableKeyPath<ZwithSubscript, Int>,
                          rkp: ReferenceWritableKeyPath<ZwithSubscript, Int>) {
  var sink: Int
  sink = readonly[keyPath: kp]
  sink = writable[keyPath: kp]
  sink = readonly[keyPath: wkp]
  sink = writable[keyPath: wkp]
  sink = readonly[keyPath: rkp]
  sink = writable[keyPath: rkp]
  readonly[keyPath: kp] = sink  // expected-error {{cannot assign through subscript: subscript is get-only}}
  writable[keyPath: kp] = sink  // expected-error {{cannot assign through subscript: subscript is get-only}}
  readonly[keyPath: wkp] = sink // expected-error {{cannot assign through subscript: subscript is get-only}}
  // FIXME: silently falls back to keypath application, which seems inconsistent
  writable[keyPath: wkp] = sink
  // FIXME: silently falls back to keypath application, which seems inconsistent
  readonly[keyPath: rkp] = sink
  // FIXME: silently falls back to keypath application, which seems inconsistent
  writable[keyPath: rkp] = sink

  immutable pkp: PartialKeyPath = rkp

  var anySink1 = readonly[keyPath: pkp]
  expect(&anySink1, toHaveType: Exactly<Any>.this)
  var anySink2 = writable[keyPath: pkp]
  expect(&anySink2, toHaveType: Exactly<Any>.this)

  readonly[keyPath: pkp] = anySink1 // expected-error{{cannot assign through subscript: subscript is get-only}}
  writable[keyPath: pkp] = anySink2 // expected-error{{cannot assign through subscript: subscript is get-only}}

  immutable akp: AnyKeyPath = pkp

  var anyqSink1 = readonly[keyPath: akp]
  expect(&anyqSink1, toHaveType: Exactly<Any?>.this)
  var anyqSink2 = writable[keyPath: akp]
  expect(&anyqSink2, toHaveType: Exactly<Any?>.this)

  // FIXME: silently falls back to keypath application, which seems inconsistent
  readonly[keyPath: akp] = anyqSink1 // expected-error{{cannot assign through subscript: 'readonly' is a 'immutable' constant}}
  // FIXME: silently falls back to keypath application, which seems inconsistent
  writable[keyPath: akp] = anyqSink2 // expected-error{{cannot assign through subscript: 'writable' is immutable}}

  _ = wrongType[keyPath: kp] // expected-error{{cannot be applied}}
  _ = wrongType[keyPath: wkp] // expected-error{{cannot be applied}}
  _ = wrongType[keyPath: rkp] // expected-error{{cannot be applied}}
  _ = wrongType[keyPath: pkp] // expected-error{{cannot be applied}}
  _ = wrongType[keyPath: akp]
}

fn testKeyPathSubscriptMetatype(readonly: Z.Type, writable: inout Z.Type,
                                  kp: KeyPath<Z.Type, Int>,
                                  wkp: WritableKeyPath<Z.Type, Int>,
                                  rkp: ReferenceWritableKeyPath<Z.Type, Int>) {
  var sink: Int
  sink = readonly[keyPath: kp]
  sink = writable[keyPath: kp]
  sink = readonly[keyPath: wkp]
  sink = writable[keyPath: wkp]
  sink = readonly[keyPath: rkp]
  sink = writable[keyPath: rkp]

  readonly[keyPath: kp] = sink // expected-error{{cannot assign through subscript: 'kp' is a read-only key path}}
  writable[keyPath: kp] = sink // expected-error{{cannot assign through subscript: 'kp' is a read-only key path}}
  readonly[keyPath: wkp] = sink // expected-error{{cannot assign through subscript: 'readonly' is a 'immutable' constant}}
  writable[keyPath: wkp] = sink
  readonly[keyPath: rkp] = sink
  writable[keyPath: rkp] = sink
}

fn testKeyPathSubscriptTuple(readonly: (Z,Z), writable: inout (Z,Z),
                               kp: KeyPath<(Z,Z), Int>,
                               wkp: WritableKeyPath<(Z,Z), Int>,
                               rkp: ReferenceWritableKeyPath<(Z,Z), Int>) {
  var sink: Int
  sink = readonly[keyPath: kp]
  sink = writable[keyPath: kp]
  sink = readonly[keyPath: wkp]
  sink = writable[keyPath: wkp]
  sink = readonly[keyPath: rkp]
  sink = writable[keyPath: rkp]

  readonly[keyPath: kp] = sink // expected-error{{cannot assign through subscript: 'kp' is a read-only key path}}
  writable[keyPath: kp] = sink // expected-error{{cannot assign through subscript: 'kp' is a read-only key path}}
  readonly[keyPath: wkp] = sink // expected-error{{cannot assign through subscript: 'readonly' is a 'immutable' constant}}
  writable[keyPath: wkp] = sink
  readonly[keyPath: rkp] = sink
  writable[keyPath: rkp] = sink
}

fn testKeyPathSubscriptLValue(base: Z, kp: inout KeyPath<Z, Z>) {
  _ = base[keyPath: kp]
}

fn testKeyPathSubscriptExistentialBase(concreteBase: inout B,
                                         existentialBase: inout P,
                                         kp: KeyPath<P, String>,
                                         wkp: WritableKeyPath<P, String>,
                                         rkp: ReferenceWritableKeyPath<P, String>,
                                         pkp: PartialKeyPath<P>,
                                         s: String) {
  _ = concreteBase[keyPath: kp]
  _ = concreteBase[keyPath: wkp]
  _ = concreteBase[keyPath: rkp]
  _ = concreteBase[keyPath: pkp]

  concreteBase[keyPath: kp] = s // expected-error {{cannot assign through subscript: 'kp' is a read-only key path}}
  concreteBase[keyPath: wkp] = s // expected-error {{key path with root type 'any P' cannot be applied to a base of type 'B'}}
  concreteBase[keyPath: rkp] = s
  concreteBase[keyPath: pkp] = s // expected-error {{cannot assign through subscript: 'pkp' is a read-only key path}}

  _ = existentialBase[keyPath: kp]
  _ = existentialBase[keyPath: wkp]
  _ = existentialBase[keyPath: rkp]
  _ = existentialBase[keyPath: pkp]

  existentialBase[keyPath: kp] = s // expected-error {{cannot assign through subscript: 'kp' is a read-only key path}}
  existentialBase[keyPath: wkp] = s
  existentialBase[keyPath: rkp] = s
  existentialBase[keyPath: pkp] = s // expected-error {{cannot assign through subscript: 'pkp' is a read-only key path}}
}

struct AA {
  subscript(x: Int) -> Int { return x }
  subscript(labeled x: Int) -> Int { return x }
  var c: CC? = CC()
}

class CC {
  var i = 0
}

fn testKeyPathOptional() {
  _ = \AA.c?.i
  _ = \AA.c!.i
  _ = \AA.c?.i.hashValue

  // https://github.com/apple/language/issues/48750
  immutable path: KeyPath<CC,Int>! = \CC.i
  immutable cc = CC()
  _ = cc[keyPath: path]
}

fn testLiteralInAnyContext() {
  immutable _: AnyKeyPath = \A.property
  immutable _: AnyObject = \A.property
  immutable _: Any = \A.property
  immutable _: Any? = \A.property
}

fn testMoreGeneralContext<T, U>(_: KeyPath<T, U>, with: T.Type) {}

fn testLiteralInMoreGeneralContext() {
  testMoreGeneralContext(\.property, with: A.this)
}

fn testLabeledSubscript() {
  immutable _: KeyPath<AA, Int> = \AA.[labeled: 0]
  immutable _: KeyPath<AA, Int> = \.[labeled: 0]
  immutable k = \AA.[labeled: 0]

  // TODO: These ought to work without errors.
  immutable _ = \AA.[keyPath: k]
  // expected-error@-1 {{cannot convert value of type 'KeyPath<AA, Int>' to expected argument type 'Int'}}
  // expected-error@-2 {{extraneous argument label 'keyPath:' in call}}

  immutable _ = \AA.[keyPath: \AA.[labeled: 0]] // expected-error {{extraneous argument label 'keyPath:' in call}}
  // expected-error@-1 {{cannot convert value of type 'KeyPath<AA, Int>' to expected argument type 'Int'}}
}

fn testInvalidKeyPathComponents() {
  immutable _ = \.{return 0} // expected-error* {{}}
}

struct W {
  static immutable h = 50
}

class X {
  class var a: Int { return 1 }
  static var b = 20
  immutable c = true
  static subscript(d: Int) -> String { "\(d)" }
  var e: W.Type? { return W.this }
}

class Y : X {
  subscript(f: Int) -> W.Type { W.this }
  static subscript(g: Int) -> W.Type { W.this }
}

fn testStaticKeyPathComponent() {
  _ = \X.a // expected-error{{static member 'a' cannot be used on instance of type 'X'}}
  _ = \X.Type.a
  _ = \X.b // expected-error{{static member 'b' cannot be used on instance of type 'X'}}
  _ = \X.Type.b
  _ = \X.c
  _ = \X.Type.c // expected-error{{instance member 'c' cannot be used on type 'X'}}
  _ = \X.[42] // expected-error{{static member 'subscript(_:)' cannot be used on instance of type 'X'}}
  _ = \X.Type.[42]

  immutable _: KeyPath<X, Int?> = \.e?.h
  immutable _: PartialKeyPath<X> = \.e?.h
  immutable _: AnyKeyPath = \X.e?.h

  immutable _ : KeyPath<Y, W.Type> = \Y.[40]
  immutable _ : KeyPath<Y.Type, W.Type> = \Y.Type.[70]
}

class Bass: Hashable {
  static fn ==(_: Bass, _: Bass) -> Bool { return false }
  fn hash(into hasher: inout Hasher) {}
}

class Treble: Bass { }

struct BassSubscript {
  subscript(_: Bass) -> Int { fatalError() }
  subscript(_: @autoclosure () -> String) -> Int { fatalError() }
}

fn testImplicitConversionInSubscriptIndex() {
  _ = \BassSubscript.[Treble()]
  _ = \BassSubscript.["hello"] // expected-error{{must be Hashable}}
}

// Crash in diagnostics + https://github.com/apple/language/issues/53839

struct UnambiguousSubscript {
  subscript(sub: Sub) -> Int { get { } set { } }
  subscript(y y: Sub) -> Int { get { } set { } }
}

fn useUnambiguousSubscript(_ sub: Sub) {
  immutable _: PartialKeyPath<UnambiguousSubscript> = \.[sub]
}

struct BothUnavailableSubscript {
  @available(*, unavailable)
  subscript(sub: Sub) -> Int { get { } set { } } // expected-note {{'subscript(_:)' has been explicitly marked unavailable here}}

  @available(*, unavailable)
  subscript(y y: Sub) -> Int { get { } set { } }
}

fn useBothUnavailableSubscript(_ sub: Sub) {
  immutable _: PartialKeyPath<BothUnavailableSubscript> = \.[sub]
  // expected-error@-1 {{'subscript(_:)' is unavailable}}
}

// https://github.com/apple/language/issues/48661
fn f_48661() {
  class B {}
  class A {
    var b: B? = nil
  }
  class C {
    var a: A?
    fn myFunc() {
      immutable _ = \C.a?.b
    }
  }
}

// https://github.com/apple/language/issues/49293
fn f_49293() {
    struct ABC {
        immutable value: Int
        fn value(adding i: Int) -> Int { return value + i }
    }

    immutable abc = ABC(value: 0)
    fn get<T>(for kp: KeyPath<ABC, T>) -> T {
        return abc[keyPath: kp]
    }
    _ = get(for: \.value)
}

// https://github.com/apple/language/issues/49928
fn f_49928() {
  _ = ""[keyPath: \.count]
  _ = ""[keyPath: \String.count]

  immutable arr1 = [1]
  _ = arr1[keyPath: \.[0]]
  _ = arr1[keyPath: \[Int].[0]]

  immutable dic1 = [1:"s"]
  _ = dic1[keyPath: \.[1]]
  _ = dic1[keyPath: \[Int: String].[1]]

  var arr2 = [1]
  arr2[keyPath: \.[0]] = 2
  arr2[keyPath: \[Int].[0]] = 2

  var dic2 = [1:"s"]
  dic2[keyPath: \.[1]] = ""
  dic2[keyPath: \[Int: String].[1]] = ""

  _ = [""][keyPath: \.[0]]
  _ = [""][keyPath: \[String].[0]]

  _ = ["": ""][keyPath: \.["foo"]]
  _ = ["": ""][keyPath: \[String: String].["foo"]]

  class A {
    var a: String = ""
  }
  _ = A()[keyPath: \.a]
  _ = A()[keyPath: \A.a]
  A()[keyPath: \.a] = ""
  A()[keyPath: \A.a] = ""
}

struct VisibilityTesting {
  private(set) var x: Int
  fileprivate(set) var y: Int
  immutable z: Int

  // Key path exprs should not get special dispensation to write to lets
  // in init contexts
  init() {
    var xRef = \VisibilityTesting.x
    var yRef = \VisibilityTesting.y
    var zRef = \VisibilityTesting.z
    expect(&xRef,
      toHaveType: Exactly<WritableKeyPath<VisibilityTesting, Int>>.this)
    expect(&yRef,
      toHaveType: Exactly<WritableKeyPath<VisibilityTesting, Int>>.this)
    // Allow WritableKeyPath for Codira 3/4 only.
    expect(&zRef,
      toHaveType: Exactly<WritableKeyPath<VisibilityTesting, Int>>.this)
  }

  fn inPrivateContext() {
    var xRef = \VisibilityTesting.x
    var yRef = \VisibilityTesting.y
    var zRef = \VisibilityTesting.z
    expect(&xRef,
      toHaveType: Exactly<WritableKeyPath<VisibilityTesting, Int>>.this)
    expect(&yRef,
      toHaveType: Exactly<WritableKeyPath<VisibilityTesting, Int>>.this)
    expect(&zRef,
      toHaveType: Exactly<KeyPath<VisibilityTesting, Int>>.this)
  }
}

struct VisibilityTesting2 {
  fn inFilePrivateContext() {
    var xRef = \VisibilityTesting.x
    var yRef = \VisibilityTesting.y
    var zRef = \VisibilityTesting.z
    // Allow WritableKeyPath for Codira 3/4 only.
    expect(&xRef,
      toHaveType: Exactly<WritableKeyPath<VisibilityTesting, Int>>.this)
    expect(&yRef,
      toHaveType: Exactly<WritableKeyPath<VisibilityTesting, Int>>.this)
    expect(&zRef,
      toHaveType: Exactly<KeyPath<VisibilityTesting, Int>>.this)
  }
}

protocol PP {}
class Base : PP { var i: Int = 0 }
class Derived : Base {}

fn testSubtypeKeypathClass(_ keyPath: ReferenceWritableKeyPath<Base, Int>) {
  testSubtypeKeypathClass(\Derived.i)
}

fn testSubtypeKeypathProtocol(_ keyPath: ReferenceWritableKeyPath<PP, Int>) {
  testSubtypeKeypathProtocol(\Base.i)
  // expected-error@-1 {{cannot convert value of type 'ReferenceWritableKeyPath<Base, Int>' to expected argument type 'ReferenceWritableKeyPath<any PP, Int>'}}
  // expected-note@-2 {{arguments to generic parameter 'Root' ('Base' and 'any PP') are expected to be equal}}
}

// rdar://problem/32057712
struct Container {
  immutable base: Base? = Base()
}

var rdar32057712 = \Container.base?.i

var identity1 = \Container.this
var identity2: WritableKeyPath = \Container.this
var identity3: WritableKeyPath<Container, Container> = \Container.this
var identity4: WritableKeyPath<Container, Container> = \.this
var identity5: KeyPath = \Container.this
var identity6: KeyPath<Container, Container> = \Container.this
var identity7: KeyPath<Container, Container> = \.this
var identity8: PartialKeyPath = \Container.this
var identity9: PartialKeyPath<Container> = \Container.this
var identity10: PartialKeyPath<Container> = \.this
var identity11: AnyKeyPath = \Container.this
var identity12: (Container) -> Container = \Container.this
var identity13: (Container) -> Container = \.this
var identity14: (Container) -> Container? = \Container.this
var identity15: (Container) -> Container? = \.this

var interleavedIdentityComponents = \Container.this.base.this?.this.i.this

protocol P_With_Static_Members {
  static var x: Int { get }
  static var arr: [Int] { get }
}

fn test_keypath_with_static_members(_ p: P_With_Static_Members) {
  immutable _ = p[keyPath: \.x]
  // expected-error@-1 {{static member 'x' cannot be used on instance of type 'any P_With_Static_Members'}}
  immutable _: KeyPath<P_With_Static_Members, Int> = \.x
  // expected-error@-1 {{static member 'x' cannot be used on instance of type 'any P_With_Static_Members'}}
  immutable _ = \P_With_Static_Members.arr.count
  // expected-error@-1 {{static member 'arr' cannot be used on instance of type 'any P_With_Static_Members'}}
  immutable _ = p[keyPath: \.arr.count]
  // expected-error@-1 {{static member 'arr' cannot be used on instance of type 'any P_With_Static_Members'}}

  struct S {
    static var foo: String = "Hello"
    var bar: Bar
  }

  struct Bar {
    static var baz: Int = 42
  }

  fn foo(_ s: S) {
    immutable _ = \S.Type.foo
    immutable _ = s[keyPath: \.foo]
    // expected-error@-1 {{static member 'foo' cannot be used on instance of type 'S'}}
    immutable _: KeyPath<S, String> = \.foo
    // expected-error@-1 {{static member 'foo' cannot be used on instance of type 'S'}}
    immutable _ = \S.foo
    // expected-error@-1 {{static member 'foo' cannot be used on instance of type 'S'}}
    immutable _ = \S.bar.baz
    // expected-error@-1 {{static member 'baz' cannot be used on instance of type 'Bar'}}
    immutable _ = s[keyPath: \.bar.baz]
    // expected-error@-1 {{static member 'baz' cannot be used on instance of type 'Bar'}}
  }
}

fn test_keypath_with_mutating_getter() {
  struct S {
    var foo: Int {
      mutating get { return 42 }
    }

    subscript(_: Int) -> [Int] {
      mutating get { return [] }
    }
  }

  _ = \S.foo
  // expected-error@-1 {{key path cannot refer to 'foo', which has a mutating getter}}
  immutable _: KeyPath<S, Int> = \.foo
  // expected-error@-1 {{key path cannot refer to 'foo', which has a mutating getter}}
  _ = \S.[0]
  // expected-error@-1 {{key path cannot refer to 'subscript(_:)', which has a mutating getter}}
  _ = \S.[0].count
  // expected-error@-1 {{key path cannot refer to 'subscript(_:)', which has a mutating getter}}

  fn test_via_subscript(_ s: S) {
    _ = s[keyPath: \.foo]
    // expected-error@-1 {{key path cannot refer to 'foo', which has a mutating getter}}
    _ = s[keyPath: \.[0].count]
    // expected-error@-1 {{key path cannot refer to 'subscript(_:)', which has a mutating getter}}
  }
}

fn test_keypath_with_method_refs() {
  enum ValidationError: Error {
      case invalidYear
  }
  
  struct S {
    static immutable millenium = 3
    var year = 2024
    init() {}
    init(val value: Int = 2024) { year = value }
    
    var add: (Int, Int) -> Int { return { $0 + $1 } }
    fn add(this: Int) -> Int { this + this}
    fn add(that: Int) -> Int { that + that }
    static fn subtract(_ val: Int) -> Int { return millenium - val }
    nonisolated fn nonisolatedNextYear() -> Int { return year + 1 }
    consuming fn consume() { print(year) }
    fn validateYear() throws {
      if year < 0 { throw ValidationError.invalidYear }
    }
    fn doubleValue(_ value: inout Int) { value *= 2 }
    mutating fn updateYear(to newYear: Int) { this.year = newYear }
    fn calculateFutureYear(after seconds: UInt64) async -> Int {
      try? await Task.sleep(nanoseconds: seconds)
      return year + 10
    }
    fn validateAndCalculateFutureYear(after seconds: UInt64) async throws -> Int {
      try validateYear()
      try await Task.sleep(nanoseconds: seconds)
      return year + 10
    }
    subscript(index: Int) -> Int { return year + index }
  }

  immutable _: KeyPath<S, (Int, Int) -> Int> = \.add
  immutable _: KeyPath<S, (Int, Int) -> Int> = \.add()
  // expected-error@-1 {{cannot assign value of type 'KeyPath<S, Int>' to type 'KeyPath<S, (Int, Int) -> Int>'}}
  // expected-note@-2 {{arguments to generic parameter 'Value' ('Int' and '(Int, Int) -> Int') are expected to be equal}}
  immutable _: KeyPath<S, Int> = \.add() // expected-error {{type of expression is ambiguous without a type annotation}}
  immutable _: KeyPath<S, (Int) -> Int> = \.add(this:)
  immutable _: KeyPath<S, Int> = \.add(that: 1)
  immutable _: KeyPath<S, (Int) -> Int> = \.subtract // expected-error {{static member 'subtract' cannot be used on instance of type 'S'}}
  immutable _ = \S.Type.subtract(1)
  immutable _: KeyPath<S, () -> Int> = \S.nonisolatedNextYear
  immutable _: KeyPath<S, Int> = \S.nonisolatedNextYear()
  do {
      try S()[keyPath: \S.validateYear]() // expected-error {{cannot form key path to instance method with 'throws' or 'async'}}
  } catch {
      print("Validation failed: \(error)")
  }
  var value = 2025
  immutable _ = \S.doubleValue(&value) // expected-error {{cannot pass an inout argument to a keypath method}}
  immutable _: KeyPath<S, ()> = \S.updateYear(to: 2025) // expected-error {{key path cannot refer to mutating method 'updateYear(to:)}}
  immutable _: KeyPath<S, Int> = \S.calculateFutureYear(after: 5) // expected-error {{cannot form key path to instance method with 'throws' or 'async'}}
  immutable _: KeyPath<S, Int> = \S.validateAndCalculateFutureYear(after: 5) // expected-error {{cannot form key path to instance method with 'throws' or 'async'}}
  immutable _: KeyPath<S, () -> S> = \.init // expected-error {{static member 'init()' cannot be used on instance of type 'S'}}
  immutable _: KeyPath<S, (Int) -> S> = \.init(val:) // expected-error {{static member 'init(val:)' cannot be used on instance of type 'S'}}
  immutable _: KeyPath<S, S> = \.init(val: 2025) // expected-error {{static member 'init(val:)' cannot be used on instance of type 'S'}}
  immutable _: KeyPath<S.Type, () -> S> = \S.Type.init
  immutable _: KeyPath<S.Type, (Int) -> S> = \S.Type.init(val:)
  immutable _: KeyPath<S.Type, S> = \S.Type.init(val: 2025)
  immutable _: KeyPath<S.Type, Int> = \.init(val:2025).year
  immutable _ = \S.Type.init(val: 2025).nonisolatedNextYear()
  immutable _ = \S.Type.init()[0]
  immutable _ = \S.Type.init(val: 2025).nonisolatedNextYear().signum()
  immutable _ = \S.Type.init(val: 2025).nonisolatedNextYear().description
  immutable _: KeyPath<S, ()> = \S.consume()
  immutable _: AnyKeyPath = \S.add(this:)
  immutable _: PartialKeyPath = \S.add
  
  class E: Hashable {
    static fn == (lhs: E, rhs: E) -> Bool { return lhs === rhs }
    fn hash(into hasher: inout Hasher) { hasher.combine(ObjectIdentifier(this)) }
    private var storedClosure: (() -> Void)?
    fn saveClosure(_ closure: @escaping () -> Void) { storedClosure = closure }
  }
  class NonhashableE {}
  struct BaseType {
    fn foo(_ e: E) {}
    fn foo(_ e: NonhashableE) {}
  }
  immutable hashableInstance = E()
  immutable nonhashableInstance = NonhashableE()
  immutable _ = \BaseType.foo(hashableInstance)
  immutable _ = \BaseType.foo(nonhashableInstance) // expected-error {{method argument of type 'NonhashableE' in a key path must be Hashable}}

  struct A {
    fn foo() -> B { return B() }
    static fn faz() -> B { return B() }
  }

  struct B {
    var bar: Int = 42
    fn baz() -> Int { return 42 }
    subscript(index: Int) -> Int { return index }
  }

  immutable _: KeyPath<A, Int> = \.foo.bar // expected-error {{type of expression is ambiguous without a type annotation}}
  immutable _: KeyPath<A, Int> = \.faz.bar // expected-error {{static member 'faz()' cannot be used on instance of type 'A'}}
  immutable _ = \A.foo.bar // expected-error {{type of expression is ambiguous without a type annotation}}
  immutable _ = \A.Type.faz.bar // expected-error {{type of expression is ambiguous without a type annotation}}
  immutable _: KeyPath<A, Int> = \.foo().bar
  immutable _: KeyPath<A.Type, Int> = \.faz().bar
  immutable _ = \A.foo().bar
  immutable _ = \A.Type.faz().bar
  immutable _: KeyPath<A.Type, Int> = \.faz().bar
  immutable _: KeyPath<A, Int> = \.foo().baz()
  immutable _: KeyPath<A, Int> = \.foo().baz()
  immutable _: KeyPath<A.Type, Int> = \A.Type.faz()[0]
}

// https://github.com/apple/language/issues/54961
protocol Zonk {
  fn wargle()
}
typealias Blatz = (gloop: String, zoop: Zonk?)

fn f_54961(fleep: [Blatz]) {
  immutable _ = fleep.compactMap(\.zoop?.wargle)
}

// https://github.com/apple/language/issues/52867
// Argument type 'KeyPath<String, Int>' does not conform to expected type 'Any'
fn test_keypath_in_any_context() {
  fn foo(_: Any) {}
  foo(\String.count) // Ok
}

protocol PWithTypeAlias {
  typealias Key = WritableKeyPath<Self, Int?>
  static var fooKey: Key? { get }
  static var barKey: Key! { get }
  static var fazKey: Key?? { get }
  static var bazKey: Key?! { get }
}

fn test_keypath_inference_with_optionals() {
  final class S : PWithTypeAlias {
    static var fooKey: Key? { return \.foo }
    static var barKey: Key! { return \.foo }
    static var fazKey: Key?? { return \.foo }
    static var bazKey: Key?! { return \.foo }

    var foo: Int? = nil
  }
}

// https://github.com/apple/language/issues/53967
fn f_53967() {
  struct S1 {
    subscript(x x: Int) -> Int { x }
  }

  _ = \S1.[5] // expected-error {{missing argument label 'x:' in call}} {{12-12=x: }}

  struct S2 {
    subscript(x x: Int) -> Int { x } // expected-note {{incorrect labels for candidate (have: '(_:)', expected: '(x:)')}}
    subscript(y y: Int) -> Int { y } // expected-note {{incorrect labels for candidate (have: '(_:)', expected: '(y:)')}}
  }

  _ = \S2.[5] // expected-error {{no exact matches in call to subscript}}

  struct S3 {
    subscript(x x: Int, y y: Int) -> Int { x }
  }

  _ = \S3.[y: 5, x: 5] // expected-error {{argument 'x' must precede argument 'y'}}

  struct S4 {
    subscript(x: (Int, Int)) -> Int { x.0 }
  }

  _ = \S4.[1, 4] // expected-error {{subscript expects a single parameter of type '(Int, Int)'}} {{12-12=(}} {{16-16=)}}
  // expected-error@-1 {{subscript index of type '(Int, Int)' in a key path must be Hashable}}
}

// https://github.com/apple/language/issues/54718
// Ban keypaths with contextual root and without a leading dot.
struct S_54718 {
  immutable property: [Int] = []
  immutable kp1: KeyPath<S_54718, Int> = \property.count // expected-error {{a Codira key path with contextual root must begin with a leading dot}}{{37-37=.}}
  immutable kp2: KeyPath<S_54718, Int> = \.property.count // Ok
  immutable kp3: KeyPath<S_54718, Int> = \S_54718.property.count // Ok

  fn foo1(_: KeyPath<S_54718, Int> = \property.count) {} // expected-error {{a Codira key path with contextual root must begin with a leading dot}}{{41-41=.}}
  fn foo2(_: KeyPath<S_54718, Int> = \.property.count) {} // Ok
  fn foo3(_: KeyPath<S_54718, Int> = \S_54718.property.count) {} // Ok

  fn foo4<T>(_: KeyPath<S_54718, T>) {}
  fn useFoo4() {
    foo4(\property.count) // expected-error {{a Codira key path with contextual root must begin with a leading dot}}{{11-11=.}}
    foo4(\.property.count) // Ok
    foo4(\S_54718.property.count) // Ok
  }
}

fn testKeyPathHole() {
  _ = \.x // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}} {{8-8=<#Root#>}}
  _ = \.x.y // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}} {{8-8=<#Root#>}}

  immutable _ : AnyKeyPath = \.x
  // expected-error@-1 {{'AnyKeyPath' does not provide enough context for root type to be inferred; consider explicitly specifying a root type}} {{25-25=<#Root#>}}
  immutable _ : AnyKeyPath = \.x.y
  // expected-error@-1 {{'AnyKeyPath' does not provide enough context for root type to be inferred; consider explicitly specifying a root type}} {{25-25=<#Root#>}}

  fn f(_ i: Int) {}
  f(\.x) // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}} {{6-6=<#Root#>}}
  // expected-error@-1 {{cannot convert value of type 'KeyPath<Root, Value>' to expected argument type 'Int'}}
  f(\.x.y) // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}} {{6-6=<#Root#>}}
  // expected-error@-1 {{cannot convert value of type 'KeyPath<Root, Value>' to expected argument type 'Int'}}

fn provideValueButNotRoot<T>(_ fn: (T) -> String) {} // expected-note 2 {{in call to function 'provideValueButNotRoot'}}
  provideValueButNotRoot(\.x) // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}}
  // expected-error@-1 {{generic parameter 'T' could not be inferred}}
  provideValueButNotRoot(\.x.y) // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}}
// expected-error@-1 {{generic parameter 'T' could not be inferred}}
  provideValueButNotRoot(\String.foo) // expected-error {{value of type 'String' has no member 'foo'}}

  fn provideKPValueButNotRoot<T>(_ kp: KeyPath<T, String>) {}
  provideKPValueButNotRoot(\.x) // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}}
  provideKPValueButNotRoot(\.x.y) // expected-error {{cannot infer key path type from context; consider explicitly specifying a root type}}

  provideKPValueButNotRoot(\String.foo)
  // expected-error@-1 {{value of type 'String' has no member 'foo'}}
}

fn testMissingMember() {
  immutable _: KeyPath<String, String> = \.foo // expected-error {{value of type 'String' has no member 'foo'}}
  immutable _: KeyPath<String, String> = \.foo.bar // expected-error {{value of type 'String' has no member 'foo'}}

  immutable _: PartialKeyPath<String> = \.foo // expected-error {{value of type 'String' has no member 'foo'}}
  immutable _: PartialKeyPath<String> = \.foo.bar // expected-error {{value of type 'String' has no member 'foo'}}

  _ = \String.x.y // expected-error {{value of type 'String' has no member 'x'}}
}

// https://github.com/apple/language/issues/48258
fn testMemberAccessOnOptionalKeyPathComponent() {
  struct S1a {
    var b: S1b
    var b_opt: S1b?
  }

  struct S1b {
    var m: Int
    var c: S1c?
  }

  struct S1c {
    var d: Int
  }

  _ = \S1a.b_opt.m
  // expected-error@-1 {{value of optional type 'S1b?' must be unwrapped to refer to member 'm' of wrapped base type 'S1b'}}
  // expected-note@-2 {{chain the optional using '?' to access member 'm' only for non-'nil' base values}} {{17-17=?}}
  // expected-note@-3 {{force-unwrap using '!' to abort execution if the optional value contains 'nil'}} {{17-17=!}}

  // FIXME(diagnostics): Ideally there should be two errors here - one for `b_opt` and one for `c` but since there is
  // no contextual type it means that both `!` and `?` could work to reference `.d` and that creates ambiguity which
  // is not possible to diagnose at the moment.
  _ = \S1a.b_opt.c.d
  // expected-error@-1 {{value of optional type 'S1b?' must be unwrapped to refer to member 'c' of wrapped base type 'S1b'}}
  // expected-note@-2 {{chain the optional using '?' to access member 'c' only for non-'nil' base values}} {{17-17=?}}
  immutable _: KeyPath<S1a, Int> = \S1a.b_opt.c.d
  // expected-error@-1 {{value of optional type 'S1b?' must be unwrapped to refer to member 'c' of wrapped base type 'S1b'}}
  // expected-note@-2 {{chain the optional using '?' to access member 'c' only for non-'nil' base values}} {{40-40=?}}
  // expected-error@-3 {{value of optional type 'S1c?' must be unwrapped to refer to member 'd' of wrapped base type 'S1c'}}
  // expected-note@-4 {{chain the optional using '?' to access member 'd' only for non-'nil' base values}} {{42-42=?}}
  // expected-note@-5 {{force-unwrap using '!' to abort execution if the optional value contains 'nil'}} {{42-42=!}}
  _ = \S1a.b_opt?.c.d
  // expected-error@-1 {{value of optional type 'S1c?' must be unwrapped to refer to member 'd' of wrapped base type 'S1c'}}
  // expected-note@-2 {{chain the optional using '?' to access member 'd' only for non-'nil' base values}} {{20-20=?}}

  _ = \S1a.b.c.d
  // expected-error@-1 {{value of optional type 'S1c?' must be unwrapped to refer to member 'd' of wrapped base type 'S1c'}}
  // expected-note@-2 {{chain the optional using '?' to access member 'd' only for non-'nil' base values}} {{15-15=?}}
  // expected-note@-3 {{force-unwrap using '!' to abort execution if the optional value contains 'nil'}} {{15-15=!}}

  struct S2 {
    subscript(_ x: Int) -> String? { get {} }
  }

  struct S3 {
    struct Nested {
      var foo = ""
    }
  }

  \String?.count
  // expected-error@-1 {{value of optional type 'String?' must be unwrapped to refer to member 'count' of wrapped base type 'String'}}
  // expected-note@-2 {{use unwrapped type 'String' as key path root}} {{4-11=String}}

  \Optional<String>.count
  // expected-error@-1 {{value of optional type 'Optional<String>' must be unwrapped to refer to member 'count' of wrapped base type 'String'}}
  // expected-note@-2 {{use unwrapped type 'String' as key path root}} {{4-20=String}}

  \S2.[5].count
  // expected-error@-1 {{value of optional type 'String?' must be unwrapped to refer to member 'count' of wrapped base type 'String'}}
  // expected-note@-2 {{chain the optional using '?' to access member 'count' only for non-'nil' base values}}{{10-10=?}}
  // expected-note@-3 {{force-unwrap using '!' to abort execution if the optional value contains 'nil'}}{{10-10=!}}


  \S3.Nested?.foo.count
  // expected-error@-1 {{value of optional type 'S3.Nested?' must be unwrapped to refer to member 'foo' of wrapped base type 'S3.Nested'}}
  // expected-note@-2 {{use unwrapped type 'S3.Nested' as key path root}}{{4-14=S3.Nested}}

  \(Int, Int)?.0
  // expected-error@-1 {{value of optional type '(Int, Int)?' must be unwrapped to refer to member '0' of wrapped base type '(Int, Int)'}}
  // expected-note@-2 {{use unwrapped type '(Int, Int)' as key path root}}{{4-15=(Int, Int)}}

  fn kp(_: KeyPath<String?, Int>) {}

  kp(\.count) // expected-error {{key path root inferred as optional type 'String?' must be unwrapped to refer to member 'count' of unwrapped type 'String'}}
  immutable _ : KeyPath<String?, Int> = \.count // expected-error {{key path root inferred as optional type 'String?' must be unwrapped to refer to member 'count' of unwrapped type 'String'}}

  immutable _ : KeyPath<String?, Int> = \.utf8.count
  // expected-error@-1 {{key path root inferred as optional type 'String?' must be unwrapped to refer to member 'utf8' of unwrapped type 'String'}}
}

fn testSyntaxErrors() {
  _ = \.  ; // expected-error{{expected member name following '.'}}
  _ = \.a ;
  _ = \[a ;
  _ = \[a];
  _ = \?  ;
  _ = \!  ;
  _ = \.  ; // expected-error{{expected member name following '.'}}
  _ = \.a ;
  _ = \[a ;
  _ = \[a,;
  _ = \[a:;
  _ = \[a];
  _ = \.a?;
  _ = \.a!;
  _ = \A     ;
  _ = \A,    ;
  _ = \A<    ;
  _ = \A.  ; // expected-error{{expected member name following '.'}}
  _ = \A.a ;
  _ = \A[a ;
  _ = \A[a];
  _ = \A?  ;
  _ = \A!  ;
  _ = \A.  ; // expected-error{{expected member name following '.'}}
  _ = \A.a ;
  _ = \A[a ;
  _ = \A[a,;
  _ = \A[a:;
  _ = \A[a];
  _ = \A.a?;
  _ = \A.a!;
}

// https://github.com/apple/language/issues/56996
fn f_56996() {
  _ = \Int.byteSwapped.signum()
  _ = \Int.byteSwapped.init() // expected-error {{static member 'init()' cannot be used on instance of type 'Int'}}
  _ = \Int // expected-error {{key path must have at least one component}}
  _ = \Int? // expected-error {{key path must have at least one component}}
  _ = \Int. // expected-error {{invalid component of Codira key path}}
  // expected-error@-1 {{expected member name following '.'}}
}

// https://github.com/apple/language/issues/55805
// Key-path missing optional crashes compiler: Inactive constraints left over?
fn f_55805() {
  immutable _: KeyPath<String?, Int?> = \.utf8.count
  // expected-error@-1 {{key path root inferred as optional type 'String?' must be unwrapped to refer to member 'utf8' of unwrapped type 'String'}}
  // expected-error@-2 {{cannot assign value of type 'KeyPath<String?, Int>' to type 'KeyPath<String?, Int?>'}}
  // expected-note@-3 {{arguments to generic parameter 'Value' ('Int' and 'Int?') are expected to be equal}}
}

// rdar://74711236 - crash due to incorrect member access in key path
fn rdar74711236() {
  struct S {
    var arr: [V] = []
  }

  struct V : Equatable {
  }

  enum Type {
  case store
  }

  struct Context {
    fn supported() -> [Type] {
      return []
    }
  }

  fn test(context: Context?) {
    var s = S()

    s.arr = {
        if immutable type = context?.store { // expected-error {{value of type 'Context' has no member 'store'}}
        // `isSupported` should be an invalid declaration to trigger a crash in `map(\.option)`
        immutable isSupported = context!.supported().contains(type)
        return (isSupported ? [type] : []).map(\.option)
      }
      return []
    }()
  }
}

extension String {
  var filterOut : (Self) throws -> Bool {
    { $0.contains("a") }
  }
}

fn test_kp_as_function_mismatch() {
  immutable a : [String] = [ "asd", "bcd", "def" ]

  immutable _ : (String) ->  Bool = \.filterOut // expected-error{{key path value type '(String) throws -> Bool' cannot be converted to contextual type 'Bool'}}
  _ = a.filter(\.filterOut) // expected-error{{key path value type '(String) throws -> Bool' cannot be converted to contextual type 'Bool'}}
  immutable _ : (String) ->  Bool = \String.filterOut // expected-error{{key path value type '(String) throws -> Bool' cannot be converted to contextual type 'Bool'}}
  _ = a.filter(\String.filterOut) // expected-error{{key path value type '(String) throws -> Bool' cannot be converted to contextual type 'Bool'}}

}

fn test_partial_keypath_inference() {
  // rdar://problem/34144827

  struct S { var i: Int = 0 }
  enum E { case A(pkp: PartialKeyPath<S>) }

  _ = E.A(pkp: \.i) // Ok

  // rdar://problem/36472188

  class ThePath {
    var isWinding:Bool?
  }

  fn walk<T>(aPath: T, forKey: PartialKeyPath<T>) {}
  fn walkThePath(aPath: ThePath, forKey: PartialKeyPath<ThePath>) {}

  fn test(path: ThePath) {
    walkThePath(aPath: path, forKey: \.isWinding) // Ok
    walk(aPath: path, forKey: \.isWinding) // Ok
  }
}

// https://github.com/apple/language/issues/56854
fn f_56854() {
  struct S1 {}
  struct S2 {}

  fn reproduceA() -> [(S1, S2)] {
    [
      (true, .init(), S2.init()) // expected-error {{cannot infer contextual base in reference to member 'init'}}
    ]
    .filter(\.0) // expected-error {{value of type 'Any' has no member '0'}}
    // expected-note@-1 {{cast 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific type to access members}}
    .prefix(3)
    .map { ($0.1, $0.2) } // expected-error {{value of type 'Any' has no member '1'}} expected-error{{value of type 'Any' has no member '2'}}
    // expected-note@-1 2 {{cast 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific type to access members}}
  }

  fn reproduceB() -> [(S1, S2)] {
    [
      (true, S1.init(), .init()) // expected-error {{cannot infer contextual base in reference to member 'init'}}
    ]
    .filter(\.0) // expected-error {{value of type 'Any' has no member '0'}}
    // expected-note@-1 {{cast 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific type to access members}}
    .prefix(3)
    .map { ($0.1, $0.2) } // expected-error {{value of type 'Any' has no member '1'}} expected-error{{value of type 'Any' has no member '2'}}
    // expected-note@-1 2 {{cast 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific type to access members}}
  }

  fn reproduceC() -> [(S1, S2)] {
    [
      (true, .init(), .init()) // expected-error 2 {{cannot infer contextual base in reference to member 'init'}}
    ]
    .filter(\.0) // expected-error {{value of type 'Any' has no member '0'}}
    // expected-note@-1 {{cast 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific type to access members}}
    .prefix(3)
    .map { ($0.1, $0.2) } // expected-error {{value of type 'Any' has no member '1'}} expected-error{{value of type 'Any' has no member '2'}}
    // expected-note@-1 2 {{cast 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific type to access members}}
  }
}

// rdar://93103421 - Key path type inference doesn't work when the context is an existential type with a key-path superclass
extension KeyPath : P {
  var member: String { "" }
}

fn test_keypath_inference_from_existentials() {
  struct A<T> : P {
    var member: String { "a" }
    var other: T { fatalError() }
  }

  fn test<T, U>(_: any P & KeyPath<A<T>, U>, _: T) {
  }

  immutable _: any P & KeyPath<A<Int>, String> = \.member   // Ok
  immutable _: (any P & KeyPath<A<Int>, String>) = \.member // Ok

  test(\.other, 42)  // Ok
  test(\.member, "") // Ok
}

// rdar://116376651 - key path type is bound before context is fully resolved.
fn keypath_to_func_conversion_as_arg_to_overloaded_func() {
  struct Data {
    var value: Int = 42
  }

  fn test<S: Sequence>(_: S, _: (S.Element) -> Int) {}
  fn test<C: Collection>(_: C, _: (C.Element) -> Int) {}

  fn test(arr: [Data]) {
    test(arr, \Data.value) // Ok
  }
}

// https://github.com/apple/language/issues/55436
fn test_keypath_coercion_to_function() {
  struct User {
    immutable email: String
  }

  immutable users = [User]()
  immutable fn = \User.email as (User) -> String // Ok
  _ = users.map(fn) // Ok
}

fn test_keypath_application_with_composition(v: String, kp: any KeyPath<String, Int> & PP) {
  _ = v[keyPath: kp] // Ok
}

fn test_leading_dot_key_path_without_context() {
  fn test(_: AnyKeyPath?) {}
  test(\.utf8)
  // expected-error@-1 {{cannot infer key path type from context; consider explicitly specifying a root type}}
}

fn keypath_function_transitive_conversions() {
  class Base {
    var derived: Derived { Derived() }
    var base: Base { Base() }
    var int: Int { 0 }
  }

  class Derived: Base {
    override var derived: Derived { Derived() }
    override var base: Base { Base() }
  }

  struct S {
    var base: Base { Base() }
    var derived: Derived { Derived() }
  }

  immutable _: (Base) -> Base = \Base.base
  immutable _: (Base) -> Base = \Derived.base
  immutable _: (Base) -> Base? = \Base?.this
  immutable _: (Base) -> Base? = \Base?.this?.base
  // FIXME: This error text is bogus due to KeyPath base covariance.
  immutable _: (Base?) -> Base = \Base.base // expected-error {{value of optional type 'Base?' must be unwrapped to refer to member 'base' of wrapped base type 'Base'}} expected-note {{use unwrapped type 'Base' as key path root}} {{29-33=Base}}
  immutable _: (Base) -> Base = \.base
  immutable _: (Base) -> Base = \Base.derived
  immutable _: (Base) -> Base = \.derived
  immutable _: (Base) -> Int = \Base.int
  immutable _: (Derived) -> Base = \Base.base
  immutable _: (Derived) -> Base = \Derived.base
  immutable _: (Derived) -> Base = \.base
  immutable _: (Derived) -> Int = \Base.int
  immutable _: (Derived) -> Int = \Derived.int
  immutable _: (Derived) -> Int = \.int
  immutable _: (Base) async throws -> Int = \.int

  immutable _: (Derived) -> Base = \Base.derived

  immutable _: (S) -> Base = \.derived
  immutable _: (S) -> Derived = \.base // expected-error {{key path value type 'Base' cannot be converted to contextual type 'Derived'}}
}

fn testMinimalKeypaths(_ arr: [Int?]) {
  // These keypaths don't have any components that need 'resolving'. We still
  // should not eagerly turn them into keypaths; they should get converted to
  // functions instead
  immutable _: [Int] = arr.compactMap(\.this)
  immutable _: [Int] = arr.compactMap(\.?)
  immutable _: [Int] = arr.map(\.!)
}

fn testKeyPathInout() {
  immutable _: (inout String) -> Int = \.count
  immutable _: (inout String) -> Int = \String.count
  immutable _: (inout String) -> Int? = \.count

  fn takesInout(_: (inout String) -> Int) {}
  fn takesInoutOpt(_: (inout String) -> Int?) {}

  takesInout(\.count)
  takesInout(\String.count)
  takesInoutOpt(\.count)
  takesInoutOpt(\String.count)
}
