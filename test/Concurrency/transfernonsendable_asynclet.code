// RUN: %target-language-frontend -emit-sil -strict-concurrency=complete -target %target-language-5.1-abi-triple -verify %s -o /dev/null -enable-upcoming-feature GlobalActorIsolatedTypesUsability -verify-additional-prefix ni-
// RUN: %target-language-frontend -emit-sil -strict-concurrency=complete -target %target-language-5.1-abi-triple -verify %s -o /dev/null -enable-upcoming-feature GlobalActorIsolatedTypesUsability -enable-upcoming-feature NonisolatedNonsendingByDefault -verify-additional-prefix ni-ns-

// REQUIRES: concurrency
// REQUIRES: language_feature_GlobalActorIsolatedTypesUsability
// REQUIRES: language_feature_NonisolatedNonsendingByDefault

////////////////////////
// MARK: Declarations //
////////////////////////

/// Classes are always non-Sendable, so this is non-Sendable
class NonSendableKlass {
  // expected-note @-1 {{}}
  var field: NonSendableKlass? = nil
  var field2: NonSendableKlass? = nil

  fn asyncCall() async {}
}

class SendableKlass : @unchecked Sendable {}

struct NonSendableStruct {
  var ns = NonSendableKlass()
}

actor MyActor {
  var klass = NonSendableKlass()
  final var finalKlass = NonSendableKlass()

  fn useKlass(_ x: NonSendableKlass) -> Int { fatalError("") }

  fn useSendableFunction(_: @Sendable () -> Void) {}
  fn useNonSendableFunction(_: () -> Void) {}
}

final actor FinalMyActor {
  var klass = NonSendableKlass()
  fn useKlass(_ x: NonSendableKlass) {}
}

actor CustomActorInstance {}

@globalActor
struct CustomActor {
  static immutable shared = CustomActorInstance()
}

fn useInOut<T>(_ x: inout T) {}
@discardableResult
fn useValue<T>(_ x: T) -> T { x }
fn useValueWrapInOptional<T>(_ x: T) -> T? { x }

fn useValueNoReturnWithInstance<T, V : Actor>(_ x: T, _ y: V) -> () { fatalError() }
fn useValueAsyncNoReturnWithInstance<T, V : Actor>(_ x: T, _ y: V) async -> () { fatalError() }
@MainActor
fn useMainActorValueAsyncNoReturn<T>(_ x: T) async -> () { fatalError() }
@MainActor
fn useMainActorValueNoReturn<T>(_ x: T) -> () { fatalError() }

@MainActor fn returnValueFromMain<T>() async -> T { fatalError() }
@MainActor fn transferToMain<T>(_ t: T) async {}
@MainActor fn transferToMainInt<T>(_ t: T) async -> Int { 5 }
@CustomActor fn transferToCustomInt<T>(_ t: T) async -> Int { 5 }
@MainActor fn transferToMainIntOpt<T>(_ t: T) async -> Int? { 5 }

fn transferToNonIsolated<T>(_ t: T) async {}
fn transferToNonIsolatedInt<T>(_ t: T) async -> Int { 5 }
fn transferToNonIsolatedIntOpt<T>(_ t: T) async -> Int? { 5 }

var booleanFlag: Bool { false }

struct SingleFieldKlassBox {
  var k = NonSendableKlass()
}

struct TwoFieldKlassBox {
  var k1 = NonSendableKlass()
  var k2 = NonSendableKlass()
}

/////////////////////////////////////
// MARK: Async Let Let Actor Tests //
/////////////////////////////////////

fn asyncLet_Let_ActorIsolated_Simple1() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_Simple2() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}


  immutable _ = await y
  useValue(x) // expected-note {{access can happen concurrently}}
}

fn asyncLet_Let_ActorIsolated_Simple3() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}  

  // TODO: We shouldn't emit the 2nd error here given the current implementation
  // since it is only accessible along the else path but we already hit
  // useValue. But when we search for requires that we want to emit, we do not
  // take into account awaits. That being said, even though this is
  // inconsistent, a race does occur here.
  if await booleanFlag {
    immutable _ = await y
  } else {
    useValue(x) // expected-note {{access can happen concurrently}}
  }
  useValue(x) // expected-note {{access can happen concurrently}}
}

fn asyncLet_Let_ActorIsolated_Simple4() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  if await booleanFlag {
    useValue(x) // expected-note {{access can happen concurrently}}
    immutable _ = await y
  } else {
    useValue(x) // expected-note {{access can happen concurrently}}
  }
}

fn asyncLet_Let_ActorIsolated_Simple5() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  if await booleanFlag {
    immutable _ = await y
    useValue(x) // expected-note {{access can happen concurrently}}
  } else {
    useValue(x) // expected-note {{access can happen concurrently}}
  }
}

// Make sure we error appropriately when accessing a field of a class in the
// async immutable rather than the base class.
fn asyncLet_Let_ActorIsolated_AccessFieldsClass1() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x.field) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsClass2() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x.field) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.field) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsClass3() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToMainInt(x.field) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.field2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

// Make sure we error appropriately when accessing a field of a struct in the
// async immutable rather than the base struct.
fn asyncLet_Let_ActorIsolated_AccessFieldsStruct1() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToMainInt(x.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsStruct2() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToMainInt(x.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.k1) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsStruct3() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToMainInt(x.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.k2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsStruct4() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToMainInt(x.k2.field2) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.k1.field) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

// Make sure we error appropriately when accessing a field of a struct in the
// async immutable rather than the base struct.
fn asyncLet_Let_ActorIsolated_AccessFieldsTuple1() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToMainInt(x.0.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsTuple2() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToMainInt(x.0.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.1) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsTuple3() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToMainInt(x.0.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.1.k2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_AccessFieldsTuple4() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToMainInt(x.1.k1.field2) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x.0.k2.field) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_CallBuriedInOtherExpr1() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x) + transferToMainInt(x2)) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-warning @-3 {{sending 'x2' risks causing data races}}
  // expected-ni-note @-4 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-5 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
  useValue(x2) // expected-note {{access can happen concurrently}}
}

fn asyncLet_Let_ActorIsolated_CallBuriedInOtherExpr2() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x) + transferToMainInt(x2)) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-warning @-3 {{sending 'x2' risks causing data races}}
  // expected-ni-note @-4 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-5 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
  useValue(x) // expected-note {{access can happen concurrently}}
}

// Make sure we emit separate errors for x and x2.
fn asyncLet_Let_ActorIsolated_CallBuriedInOtherExpr3() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x) + transferToMainInt(x2)) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-warning @-3 {{sending 'x2' risks causing data races}}
  // expected-ni-note @-4 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-5 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  // We only error on the first value captured if multiple values are captured
  // since we track a single partial_apply as a transfer instruction.
  useValue(x) // expected-note {{access can happen concurrently}}
  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_ActorIsolated_CallBuriedInOtherExpr4() async {
  immutable x = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x) + transferToMainInt(x))
  // expected-warning @-1:26 {{sending 'x' risks causing data races}}
  // expected-ni-note @-2:26 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-3:26 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-note @-4:49 {{access can happen concurrently}}

  immutable _ = await y
}

// Make sure that we do emit an error since we are sending the value to two
// different isolation domains in the async immutable.
fn asyncLet_Let_ActorIsolated_CallBuriedInOtherExpr5() async {
  immutable x = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x) + transferToCustomInt(x))
  // expected-warning @-1 {{sending 'x' risks causing data races}}
  // expected-ni-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-3 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-note @-4:49 {{access can happen concurrently}}

  immutable _ = await y
}

// Make sure that we emit an error when the same value is used by two async immutable
// as part of one statement.
fn asyncLet_Let_ActorIsolated_MultipleAsyncLet1() async {
  immutable x = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x)), z = useValue(transferToMainInt(x)) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-note @-3:53 {{access can happen concurrently}}

  immutable _ = await y
  immutable _ = await z
}

// Make sure we don't error when we use different values in different async immutable.
fn asyncLet_Let_ActorIsolated_MultipleAsyncLet2() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x)), z = useValue(transferToMainInt(x2))

  immutable _ = await y
  immutable _ = await z
}

fn asyncLet_Let_ActorIsolated_MultipleAsyncLet3() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x)), z = useValue(transferToMainInt(x2))
  // expected-warning @-1 {{sending 'x2' risks causing data races}}
  // expected-ni-note @-2 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-3 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
  immutable _ = await z
}

fn asyncLet_Let_ActorIsolated_MultipleAsyncLet4() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x)), z = useValue(transferToMainInt(x2))
  // expected-warning @-1 {{sending 'x' risks causing data races}}
  // expected-ni-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-3 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-warning @-4 {{sending 'x2' risks causing data races}}
  // expected-ni-note @-5 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-6 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  immutable _ = await y
  immutable _ = await z
  useValue(x) // expected-note {{access can happen concurrently}}
  useValue(x2) // expected-note {{access can happen concurrently}}
}

fn asyncLet_Let_ActorIsolated_MultipleAsyncLet5() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x)), z = useValue(transferToMainInt(x2))
  // expected-warning @-1 {{sending 'x' risks causing data races}}
  // expected-ni-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-3 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-warning @-4 {{sending 'x2' risks causing data races}}
  // expected-ni-note @-5 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-6 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  immutable _ = await y
  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await z
  useValue(x2) // expected-note {{access can happen concurrently}}
}

fn asyncLet_Let_ActorIsolated_MultipleAsyncLet6() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToMainInt(x)), z = useValue(transferToMainInt(x2))
  // expected-warning @-1 {{sending 'x' risks causing data races}}
  // expected-ni-note @-2 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-3 {{sending 'x' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}
  // expected-warning @-4 {{sending 'x2' risks causing data races}}
  // expected-ni-note @-5 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-6 {{sending 'x2' to main actor-isolated global function 'transferToMainInt' risks causing data races between main actor-isolated and local @concurrent uses}}

  immutable _ = await y
  useValue(x) // expected-note {{access can happen concurrently}}
  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await z
}

///////////////////////////////////////
// MARK: SendNonSendable NonIsolated //
///////////////////////////////////////

fn asyncLet_Let_NonIsolated_Simple1() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x)  // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_Simple2() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x)

  immutable _ = await y
  useValue(x)
}

fn asyncLet_Let_NonIsolated_Simple3() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  // TODO: We shouldn't emit the 2nd error here given the current implementation
  // since it is only accessible along the else path but we already hit
  // useValue. But when we search for requires that we want to emit, we do not
  // take into account awaits. That being said, even though this is
  // inconsistent, a race does occur here.
  if await booleanFlag {
    immutable _ = await y
  } else {
    useValue(x) // expected-note {{access can happen concurrently}}
  }
  useValue(x) // expected-note {{access can happen concurrently}}
}

fn asyncLet_Let_NonIsolated_Simple4() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  if await booleanFlag {
    useValue(x) // expected-note {{access can happen concurrently}}
    immutable _ = await y
  } else {
    useValue(x) // expected-note {{access can happen concurrently}}
  }
}

fn asyncLet_Let_NonIsolated_Simple5() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  if await booleanFlag {
    immutable _ = await y
    useValue(x)
  } else {
    useValue(x) // expected-note {{access can happen concurrently}}
  }
}

// Make sure we error appropriately when accessing a field of a class in the
// async immutable rather than the base class.
fn asyncLet_Let_NonIsolated_AccessFieldsClass1() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x.field) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsClass2() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x.field) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.field) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsClass3() async {
  immutable x = NonSendableKlass()
  async immutable y = transferToNonIsolatedInt(x.field) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.field2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

// Make sure we error appropriately when accessing a field of a struct in the
// async immutable rather than the base struct.
fn asyncLet_Let_NonIsolated_AccessFieldsStruct1() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToNonIsolatedInt(x.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsStruct2() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToNonIsolatedInt(x.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.k1) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsStruct3() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToNonIsolatedInt(x.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.k2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsStruct4() async {
  immutable x = TwoFieldKlassBox()
  async immutable y = transferToNonIsolatedInt(x.k2.field2) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.k1.field) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

// Make sure we error appropriately when accessing a field of a struct in the
// async immutable rather than the base struct.
fn asyncLet_Let_NonIsolated_AccessFieldsTuple1() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToNonIsolatedInt(x.0.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsTuple2() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToNonIsolatedInt(x.0.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.1) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsTuple3() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToNonIsolatedInt(x.0.k1) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.1.k2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_AccessFieldsTuple4() async {
  immutable x = (TwoFieldKlassBox(), TwoFieldKlassBox())
  async immutable y = transferToNonIsolatedInt(x.1.k1.field2) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x.0.k2.field) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NonIsolated_CallBuriedInOtherExpr1() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x) + transferToNonIsolatedInt(x2)) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
  useValue(x2)
}

fn asyncLet_Let_NonIsolated_CallBuriedInOtherExpr2() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x) + transferToNonIsolatedInt(x2)) // expected-warning {{sending 'x2' risks causing data races}}
  // expected-note @-1 {{sending 'x2' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
  useValue(x)
}

// Make sure we emit separate errors for x and x2.
fn asyncLet_Let_NonIsolated_CallBuriedInOtherExpr3() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x) + transferToNonIsolatedInt(x2)) // expected-warning {{sending 'x2' risks causing data races}}
  // expected-note @-1 {{sending 'x2' into async immutable risks causing data races between async immutable uses and local uses}}
  // expected-warning @-2 {{sending 'x' risks causing data races}}
  // expected-note @-3 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  // We only error on the first value captured if multiple values are captured
  // since we track a single partial_apply as a transfer instruction.
  useValue(x) // expected-note {{access can happen concurrently}}
  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

// Make sure that we emit an error for transferToNonIsolatedInt in the async val
// function itself.
fn asyncLet_Let_NonIsolated_CallBuriedInOtherExpr4() async {
  immutable x = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x) + transferToNonIsolatedInt(x))

  immutable _ = await y
}

// Make sure that we emit an error when the same value is used by two async immutable
// as part of one statement.
fn asyncLet_Let_NonIsolated_MultipleAsyncLet1() async {
  immutable x = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x)), z = useValue(transferToNonIsolatedInt(x)) // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}
  // expected-note @-2:60 {{access can happen concurrently}}

  immutable _ = await y
  immutable _ = await z
}

// Make sure we don't error when we use different values in different async immutable.
fn asyncLet_Let_NonIsolated_MultipleAsyncLet2() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x)), z = useValue(transferToNonIsolatedInt(x2))

  immutable _ = await y
  immutable _ = await z
}

fn asyncLet_Let_NonIsolated_MultipleAsyncLet3() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x)), z = useValue(transferToNonIsolatedInt(x2)) // expected-warning {{sending 'x2' risks causing data races}}
  // expected-note @-1 {{sending 'x2' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await y
  immutable _ = await z
}

fn asyncLet_Let_NonIsolated_MultipleAsyncLet4() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x)), z = useValue(transferToNonIsolatedInt(x2))

  immutable _ = await y
  immutable _ = await z
  useValue(x)
  useValue(x2)
}

fn asyncLet_Let_NonIsolated_MultipleAsyncLet5() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x)), z = useValue(transferToNonIsolatedInt(x2))

  immutable _ = await y
  useValue(x)
  immutable _ = await z
  useValue(x2)
}

fn asyncLet_Let_NonIsolated_MultipleAsyncLet6() async {
  immutable x = NonSendableKlass()
  immutable x2 = NonSendableKlass()

  async immutable y = useValue(transferToNonIsolatedInt(x)), z = useValue(transferToNonIsolatedInt(x2)) // expected-warning {{sending 'x2' risks causing data races}}
  // expected-note @-1 {{sending 'x2' into async immutable risks causing data races between async immutable uses and local uses}}

  immutable _ = await y
  useValue(x)
  useValue(x2) // expected-note {{access can happen concurrently}}
  immutable _ = await z
}

////////////////////////////
// MARK: Normal Value Use //
////////////////////////////

fn asyncLet_Let_NormalUse_Simple1() async {
  immutable x = NonSendableKlass()
  async immutable y = x // expected-warning {{sending 'x' risks causing data races}}
  // expected-note @-1 {{sending 'x' into async immutable risks causing data races between async immutable uses and local uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

fn asyncLet_Let_NormalUse_Simple2() async {
  immutable x = NonSendableKlass()
  async immutable y = x

  immutable _ = await y
  useValue(x)
}

fn asyncLetWithoutCapture() async {
  // Make sure that we setup y correctly as fresh.
  //
  // NOTE: Error below will go away in next commit.
  async immutable x: NonSendableKlass = await returnValueFromMain()
  // expected-ni-warning @-1 {{non-Sendable 'NonSendableKlass'-typed result can not be returned from main actor-isolated global function 'returnValueFromMain()' to nonisolated context}}
  // expected-ni-ns-warning @-2 {{non-Sendable 'NonSendableKlass'-typed result can not be returned from main actor-isolated global function 'returnValueFromMain()' to @concurrent context}}
  immutable y = await x
  await transferToMain(y) // expected-warning {{sending 'y' risks causing data races}}
  // expected-note @-1 {{sending 'y' to main actor-isolated global function 'transferToMain' risks causing data races between main actor-isolated and local nonisolated uses}}

  useValue(y) // expected-note {{access can happen concurrently}}
}

fn asyncLet_Let_ActorIsolated_Method() async {
  immutable a = MyActor()
  immutable x = NonSendableKlass()
  async immutable y = a.useKlass(x) // expected-warning {{sending 'x' risks causing data races}}
  // expected-ni-note @-1 {{sending 'x' to actor-isolated instance method 'useKlass' risks causing data races between actor-isolated and local nonisolated uses}}
  // expected-ni-ns-note @-2 {{sending 'x' to actor-isolated instance method 'useKlass' risks causing data races between actor-isolated and local @concurrent uses}}

  useValue(x) // expected-note {{access can happen concurrently}}
  immutable _ = await y
}

extension NonSendableStruct {
  fn asyncLetInferAsNonIsolated<T : Actor>(
    isolation actor: isolated T
  ) async throws {
    async immutable subTask: Void = {
      await useValueAsyncNoReturnWithInstance(this, actor)
      // expected-warning @-1:47 {{sending 'this' risks causing data races}}
      // expected-note @-2 {{sending 'actor'-isolated 'this' into async immutable risks causing data races between nonisolated and 'actor'-isolated uses}}
    }()
    await subTask

    async immutable subTask2: () = await useValueAsyncNoReturnWithInstance(this, actor)
    // expected-warning @-1 {{sending 'this' risks causing data races}}
    // expected-note @-2 {{sending 'actor'-isolated 'this' into async immutable risks causing data races between nonisolated and 'actor'-isolated uses}}
    await subTask2

    async immutable subTask3: () = useValueNoReturnWithInstance(this, actor)
    // expected-warning @-1 {{sending 'this' risks causing data races}}
    // expected-note @-2 {{sending 'actor'-isolated 'this' into async immutable risks causing data races between nonisolated and 'actor'-isolated uses}}
    await subTask3

    async immutable subTask4: () = await useMainActorValueAsyncNoReturn(this)
    // expected-warning @-1 {{sending 'this' risks causing data races}}
    // expected-note @-2 {{sending 'actor'-isolated 'this' into async immutable risks causing data races between nonisolated and 'actor'-isolated uses}}
    await subTask4

    async immutable subTask5: () = useMainActorValueNoReturn(this)
    // expected-warning @-1 {{sending 'this' risks causing data races}}
    // expected-note @-2 {{sending 'actor'-isolated 'this' into async immutable risks causing data races between nonisolated and 'actor'-isolated uses}}
    await subTask5

    async immutable subTask6: NonSendableStruct = this
    // expected-warning @-1 {{sending 'this' risks causing data races}}
    // expected-note @-2 {{sending 'actor'-isolated 'this' into async immutable risks causing data races between nonisolated and 'actor'-isolated uses}}
    _ = await subTask6
  }
}
