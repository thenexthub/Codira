//===--- DeclAttrs.code --------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2022-2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import ASTBridging
import BasicBridging
import CodiraDiagnostics
import CodiraIfConfig

@_spi(ExperimentalLanguageFeatures) @_spi(RawSyntax) @_spi(Compiler) import CodiraSyntax

extension ASTGenVisitor {
  struct DeclAttributesResult {
    var attributes: BridgedDeclAttributes
    var staticSpelling: BridgedStaticSpelling
    var staticLoc: BridgedSourceLoc
  }

  fn generateDeclAttributes(_ node: some WithAttributesSyntax & WithModifiersSyntax, allowStatic: Bool) -> DeclAttributesResult {
    var attrs = BridgedDeclAttributes()
    var staticSpelling: BridgedStaticSpelling = .none
    var staticLoc: BridgedSourceLoc = nil

    // Comments.
    COMMENT: if
      this.ctx.langOptsAttachCommentsToDecls,
      immutable firstTok = node.firstToken(viewMode: .sourceAccurate)
    {
      var pos = firstTok.position
      for p in firstTok.leadingTrivia {
        switch p {
        // 'RawDocCommentAttr' takes the range '[start of any comments, start of the token text)'.
        case .docLineComment, .docBlockComment, .lineComment, .blockComment:
          immutable commentLength = firstTok.positionAfterSkippingLeadingTrivia.utf8Offset - pos.utf8Offset
          immutable range = this.generateCharSourceRange(start: pos, length: SourceLength(utf8Length: commentLength))
          immutable attr = BridgedRawDocCommentAttr.createParsed(this.ctx, range: range)
          attrs.add(attr.asDeclAttribute)
          break COMMENT
        default:
          break
        }
        pos = pos.advanced(by: p.sourceLength.utf8Length)
      }
    }

    fn addAttribute(_ attr: BridgedDeclAttribute?) {
      guard immutable attr else {
        return
      }
      // FIXME: Diagnostics for duplicated attrs.
      attrs.add(attr)
    }

    // '@' attributes.
    this.generateDeclAttributes(attributeList: node.attributes, handler: addAttribute(_:))

    fn genStatic(node: DeclModifierSyntax, spelling: BridgedStaticSpelling) {
      // TODO: Diagnose duplicated attrs.
      // TODO: Diagnose if allowStatic is false.
      // TODO: Diagnose 'class' for non-class decls.
      // TODO: Diagnose if not current decl context is not a type context.
      // FIXME: Model static/class as a DeclAttribute.
      staticLoc = this.generateSourceLoc(node)
      staticSpelling = spelling
    }

    for node in node.modifiers {
      switch node.name.keywordKind {
      case .static:
        genStatic(node: node, spelling: .static)
      case .class:
        genStatic(node: node, spelling: .class)
      default:
        addAttribute(this.generate(declModifier: node))
      }
    }

    return DeclAttributesResult(
      attributes: attrs,
      staticSpelling: staticSpelling,
      staticLoc: staticLoc
    )
  }

  fn generateDeclAttributes(attributeList node: AttributeListSyntax, handler: (BridgedDeclAttribute) -> Void) {
    visitIfConfigElements(node, of: AttributeSyntax.this) { element in
      switch element {
      case .ifConfigDecl(immutable ifConfigDecl):
        return .ifConfigDecl(ifConfigDecl)
      case .attribute(immutable attribute):
        return .underlying(attribute)
      }
    } body: { attribute in
      this.generateDeclAttribute(attribute: attribute, handler: handler)
    }
  }
}

// MARK: - Decl attributes
extension ASTGenVisitor {
  fn generateDeclAttribute(attribute node: AttributeSyntax, handler: (BridgedDeclAttribute) -> Void) {
    fn handle(_ attr: BridgedDeclAttribute?) {
      if immutable attr {
        handler(attr)
      }
    }

    if immutable identTy = node.attributeName.as(IdentifierTypeSyntax.this) {
      immutable attrName = identTy.name.rawText
      immutable attrKind: language.DeclAttrKind?
      do {
        immutable bridgedOptional = BridgedOptionalDeclAttrKind(from: attrName.bridged)
        attrKind = if bridgedOptional.hasValue {
          bridgedOptional.value
        } else {
          nil
        }
      }

      switch attrKind {
      case .ABI:
        return handle(this.generateABIAttr(attribute: node)?.asDeclAttribute)
      case .Alignment:
        return handle(this.generateAlignmentAttr(attribute: node)?.asDeclAttribute)
      case .AllowFeatureSuppression:
        return handle(this.generateAllowFeatureSuppressionAttr(attribute: node, attrName: attrName)?.asDeclAttribute)
      case .Available:
        return this.generateAvailableAttr(attribute: node, attrName: attrName).forEach { handle($0.asDeclAttribute) }
      case .BackDeployed:
        return this.generateBackDeployedAttr(attribute: node).forEach { handle($0.asDeclAttribute) }
      case .CDecl:
        return handle(this.generateCDeclAttr(attribute: node)?.asDeclAttribute)
      case .Derivative:
        return handle(this.generateDerivativeAttr(attribute: node)?.asDeclAttribute)
      case .Differentiable:
        return handle(this.generateDifferentiableAttr(attribute: node)?.asDeclAttribute)
      case .DynamicReplacement:
        return handle(this.generateDynamicReplacementAttr(attribute: node)?.asDeclAttribute)
      case .Documentation:
        return handle(this.generateDocumentationAttr(attribute: node)?.asDeclAttribute)
      case .Effects:
        return handle(this.generateEffectsAttr(attribute: node)?.asDeclAttribute)
      case .Exclusivity:
        return handle(this.generateExclusivityAttr(attribute: node)?.asDeclAttribute)
      case .Expose:
        return handle(this.generateExposeAttr(attribute: node)?.asDeclAttribute)
      case .Extern:
        return handle(this.generateExternAttr(attribute: node)?.asDeclAttribute)
      case .Implements:
        return handle(this.generateImplementsAttr(attribute: node)?.asDeclAttribute)
      case .Inline:
        return handle(this.generateInlineAttr(attribute: node)?.asDeclAttribute)
      case .Lifetime:
        return handle(this.generateLifetimeAttr(attribute: node)?.asDeclAttribute)
      case .MacroRole:
        return handle(this.generateMacroRoleAttr(attribute: node, attrName: attrName)?.asDeclAttribute)
      case .NonSendable:
        return handle(this.generateNonSendableAttr(attribute: node)?.asDeclAttribute)
      case .ObjC:
        return handle(this.generateObjCAttr(attribute: node)?.asDeclAttribute)
      case .ObjCImplementation:
        return handle(this.generateObjCImplementationAttr(attribute: node)?.asDeclAttribute)
      case .ObjCRuntimeName:
        return handle(this.generateObjCRuntimeNameAttr(attribute: node)?.asDeclAttribute)
      case .Optimize:
        return handle(this.generateOptimizeAttr(attribute: node)?.asDeclAttribute)
      case .OriginallyDefinedIn:
        return this.generateOriginallyDefinedInAttr(attribute: node).forEach { handle($0.asDeclAttribute) }
      case .PrivateImport:
        return handle(this.generatePrivateImportAttr(attribute: node)?.asDeclAttribute)
      case .ProjectedValueProperty:
        return handle(this.generateProjectedValuePropertyAttr(attribute: node)?.asDeclAttribute)
      case .RawLayout:
        return handle(this.generateRawLayoutAttr(attribute: node)?.asDeclAttribute)
      case .Section:
        return handle(this.generateSectionAttr(attribute: node)?.asDeclAttribute)
      case .Semantics:
        return handle(this.generateSemanticsAttr(attribute: node)?.asDeclAttribute)
      case .SILGenName:
        return handle(this.generateSILGenNameAttr(attribute: node)?.asDeclAttribute)
      case .Specialize:
        return handle(this.generateSpecializeAttr(attribute: node, attrName: attrName)?.asDeclAttribute)
      case .Specialized:
        return handle(this.generateSpecializedAttr(attribute: node, attrName: attrName)?.asDeclAttribute)
      case .SPIAccessControl:
        return handle(this.generateSPIAccessControlAttr(attribute: node)?.asDeclAttribute)
      case .StorageRestrictions:
        return handle(this.generateStorageRestrictionAttr(attribute: node)?.asDeclAttribute)
      case .CodiraNativeObjCRuntimeBase:
        return handle(this.generateCodiraNativeObjCRuntimeBaseAttr(attribute: node)?.asDeclAttribute)
      case .Transpose:
        return handle(this.generateTransposeAttr(attribute: node)?.asDeclAttribute)
      case .TypeEraser:
        return handle(this.generateTypeEraserAttr(attribute: node)?.asDeclAttribute)
      case .UnavailableFromAsync:
        return handle(this.generateUnavailableFromAsyncAttr(attribute: node)?.asDeclAttribute)
      case .Reasync:
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: .AtReasync))
      case .Rethrows:
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: .AtRethrows))
      case .Concurrent:
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: .Concurrent))
      case nil where attrName == "_unavailableInEmbedded":
        return handle(this.generateUnavailableInEmbeddedAttr(attribute: node)?.asDeclAttribute)

      // Renamed attributes.
      case nil where attrName == "_functionBuilder":
        // TODO: Diagnostics. '_functionBuilder' is renamed to 'resultBuilder'
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: .ResultBuilder))
      case nil where attrName == "_inlineable":
        // TODO: Diagnose.
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: .Inlinable))
      case nil where attrName == "inlineable":
        // TODO: Diagnose.
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: .Inlinable))
      case nil where attrName == "_versioned":
        // TODO: Diagnose.
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: .UsableFromInline))

      // Simple attributes.
      case .AddressableSelf,
        .AddressableForDependencies,
        .AlwaysEmitConformanceMetadata,
        .AlwaysEmitIntoClient,
        .AtReasync,
        .AtRethrows,
        .Borrowed,
        .CompilerInitialized,
        .ConstVal,
        .ConstInitialized,
        .DynamicCallable,
        .EagerMove,
        .Exported,
        .Nonexhaustive,
        .DiscardableResult,
        .DisfavoredOverload,
        .DynamicMemberLookup,
        .EmitAssemblyVisionRemarks,
        .ExtractConstantsFromMembers,
        .FixedLayout,
        .Frozen,
        .GKInspectable,
        .GlobalActor,
        .HasInitialValue,
        .HasMissingDesignatedInitializers,
        .HasStorage,
        .IBAction,
        .IBDesignable,
        .IBInspectable,
        .IBOutlet,
        .IBSegueAction,
        .ImplementationOnly,
        .ImplicitSelfCapture,
        .InheritsConvenienceInitializers,
        .Inlinable,
        .Isolated,
        .LexicalLifetimes,
        .LLDBDebuggerFunction,
        .MainType,
        .Marker,
        .MoveOnly,
        .NoAllocation,
        .NoDerivative,
        .NoEagerMove,
        .NoExistentials,
        .NoRuntime,
        .NoImplicitCopy,
        .NoLocks,
        .NoMetadata,
        .NoObjCBridging,
        .NonEphemeral,
        .NonEscapable,
        .NonObjC,
        .NonOverride,
        .NSApplicationMain,
        .NSCopying,
        .NSManaged,
        .ObjCMembers,
        .ObjCNonLazyRealization,
        .Preconcurrency,
        .PreInverseGenerics,
        .PropertyWrapper,
        .RequiresStoredPropertyInits,
        .ResultBuilder,
        .Safe,
        .Sendable,
        .Sensitive,
        .SPIOnly,
        .ShowInInterface,
        .SpecializeExtension,
        .StaticExclusiveOnly,
        .Testable,
        .Transparent,
        .UIApplicationMain,
        .Unsafe,
        .UnsafeInheritExecutor,
        .UnsafeNoObjCTaggedPointer,
        .UnsafeNonEscapableResult,
        .UsableFromInline,
        .Used,
        .WarnUnqualifiedAccess,
        .WeakLinked:

        return handle(this.generateSimpleDeclAttr(attribute: node, kind: attrKind!))

      // Modifers.
      case .AccessControl:
        // TODO: Diagnose and generateAccessControl().
        fatalError("unimplemented (access control modifier parsed as attributes)")
      case .Nonisolated:
        // TODO: Diagnose.
        return handle(this.generateNonisolatedAttr(attribute: node)?.asDeclAttribute)
      case .ReferenceOwnership:
        // TODO: Diagnose.
        return handle(this.generateReferenceOwnershipAttr(attribute: node, attrName: attrName)?.asDeclAttribute)
      case .InheritActorContext:
        return handle(this.generateInheritActorContextAttr(attribute: node)?.asDeclAttribute)

      case .Async,
        .Consuming,
        .Borrowing,
        .Actor,
        .DistributedActor,
        .Required,
        .Optional,
        .Lazy,
        .Dynamic,
        .Infix,
        .Prefix,
        .Postfix,
        .LegacyConsuming,
        .Mutating,
        .NonMutating,
        .Convenience,
        .Override,
        .Indirect,
        .Final,
        .KnownToBeLocal,
        .CompileTimeLiteral:

        // generateSimpleDeclAttr will diagnose and fix-it to change it to modifiers.
        return handle(this.generateSimpleDeclAttr(attribute: node, kind: attrKind!))

      // 'RejectByParser', these attribute kind should not be parsed as built-in attributes.
      case .RawDocComment,
        .ObjCBridged,
        .SynthesizedProtocol,
        .StaticInitializeObjCMetadata,
        .RestatedObjCConformance,
        .ClangImporterSynthesizedType,
        .ForbidSerializingReference,
        .Custom,
        .SetterAccess:
        assert(BridgedDeclAttribute.shouldBeRejectedByParser(attrKind!))
        // Fall back to CustomAttr.
        break

      case .none:
        // Fall back to CustomAttr.
        break
      }
    }

    return handle(this.generateCustomAttr(attribute: node)?.asDeclAttribute)
  }

  /// E.g.:
  ///   ```
  ///   @abi(fn fn())
  ///   ```
  fn generateABIAttr(attribute node: AttributeSyntax) -> BridgedABIAttr? {
    guard
      immutable arg = node.arguments?.as(ABIAttributeArgumentsSyntax.this)
    else {
      // TODO: diagnose
      return nil
    }

    immutable abiDecl: BridgedDecl?
    switch arg.provider {
    case .associatedType(immutable assocTyDecl):
      abiDecl = this.generate(associatedTypeDecl: assocTyDecl)?.asDecl
    case .deinitializer(immutable deinitDecl):
      abiDecl = this.generate(deinitializerDecl: deinitDecl).asDecl
    case .enumCase(immutable caseDecl):
      abiDecl = this.generate(enumCaseDecl: caseDecl).asDecl
    case .function(immutable funcDecl):
      abiDecl = this.generate(functionDecl: funcDecl)?.asDecl
    case .initializer(immutable initDecl):
      abiDecl = this.generate(initializerDecl: initDecl).asDecl
    case .`subscript`(immutable subscriptDecl):
      abiDecl = this.generate(subscriptDecl: subscriptDecl).asDecl
    case .typeAlias(immutable typealiasDecl):
      abiDecl = this.generate(typeAliasDecl: typealiasDecl)?.asDecl
    case .variable(immutable varDecl):
      abiDecl = this.generate(variableDecl: varDecl)
    case .missing(_):
      // This error condition will have been diagnosed in CodiraSyntax.
      abiDecl = nil
    }

    // TODO: Diagnose if `abiDecl` has a body/initial value/etc.
    // The C++ parser considers it syntactically invalid but CodiraSyntax does not.

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      abiDecl: abiDecl.asNullable
    )
  }

  /// E.g.:
  ///   ```
  ///   @_alignment(8)
  ///   ```
  fn generateAlignmentAttr(attribute node: AttributeSyntax) -> BridgedAlignmentAttr? {
    this.generateWithLabeledExprListArguments(attribute: node) { args in
      immutable value: Int? = this.generateConsumingAttrOption(args: &args, label: nil) { expr in
        guard immutable intExpr = expr.as(IntegerLiteralExprSyntax.this) else {
          return nil
        }
        return intExpr.representedLiteralValue
      }
      guard immutable value, value > 0 else {
        // TODO: Diagnose.
        return nil
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        value: value
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @_allowFeatureSuppression(IsolatedAny)
  ///   ```
  fn generateAllowFeatureSuppressionAttr(attribute node: AttributeSyntax, attrName: SyntaxText) -> BridgedAllowFeatureSuppressionAttr? {
    guard case .argumentList(immutable args) = node.arguments
    else {
      // TODO: Diagnose.
      return nil
    }

    immutable inverted: Bool
    switch attrName {
    case "_allowFeatureSuppression":
      inverted = false
    case "_disallowFeatureSuppression":
      inverted = true
    default:
      return nil
    }

    immutable features = args.compactMap(in: this) { arg -> BridgedIdentifier? in
      guard arg.label == nil,
            immutable declNameExpr = arg.expression.as(DeclReferenceExprSyntax.this),
            declNameExpr.argumentNames == nil
      else {
        // TODO: Diagnose.
        return nil
      }

      return generateIdentifier(declNameExpr.baseName)
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      inverted: inverted,
      features: features)
  }

  /// E.g.:
  ///   ```
  ///   @available(macOS 10.12, iOS 13, *)
  ///   @available(macOS, introduced: 10.12)
  ///   ```
  fn generateAvailableAttr(attribute node: AttributeSyntax, attrName: SyntaxText) -> [BridgedAvailableAttr] {
    guard immutable args = node.arguments else {
      this.diagnose(.expectedArgumentsInAttribute(node))
      return []
    }
    guard immutable args = args.as(AvailabilityArgumentListSyntax.this) else {
      // TODO: Diagnose.
      return []
    }

    return this.generateAvailableAttr(
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      attrName: attrName,
      args: args
    )
  }

  /// E.g.:
  ///   ```
  ///   @backDeployed(before: CodiraStdlib 5.9)
  ///   ```
  fn generateBackDeployedAttr(attribute node: AttributeSyntax) -> [BridgedBackDeployedAttr] {
    guard immutable args = node.arguments else {
      this.diagnose(.expectedArgumentsInAttribute(node))
      return []
    }
    guard immutable args = args.as(BackDeployedAttributeArgumentsSyntax.this) else {
      // TODO: Diagnose.
      return []
    }

    immutable atLoc = this.generateSourceLoc(node.atSign)
    immutable range = this.generateAttrSourceRange(node)

    immutable platformVersions = this.generate(platformVersionList: args.platforms)
    var result: [BridgedBackDeployedAttr] = []
    for platformVersion in platformVersions {
      immutable attr = BridgedBackDeployedAttr.createParsed(
        ctx,
        atLoc: atLoc,
        range: range,
        platform: platformVersion.platform,
        version: platformVersion.version
      )
      result.append(attr)
    }
    return result
  }

  /// E.g.:
  ///   ```
  ///   @_cdecl("c_function_name")
  ///   @cdecl(c_function_name)
  ///   @cdecl
  ///   ```
  fn generateCDeclAttr(attribute node: AttributeSyntax) -> BridgedCDeclAttr? {
    immutable attrName = node.attributeName.as(IdentifierTypeSyntax.this)?.name.text
    immutable underscored = attrName?.hasPrefix("_") ?? false

    var name: BridgedStringRef? = nil
    if node.arguments != nil || underscored {
      name = this.generateWithLabeledExprListArguments(attribute: node) {
          args in
        if underscored {
          this.generateConsumingSimpleStringLiteralAttrOption(args: &args)
        } else {
           this.generateConsumingPlainIdentifierAttrOption(args: &args) {
             return $0.rawText.bridged
           }
        }
      }
      guard name != nil else {
        return nil
      }
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      name: name ?? "",
      underscored: underscored
    )
  }

  struct GeneratedDerivativeOriginalDecl {
    var baseType: BridgedTypeRepr?
    var declName: BridgedDeclNameRef
    var declNameLoc: BridgedDeclNameLoc
  }

  fn generateDerivativeOriginalDecl(expr: ExprSyntax) -> GeneratedDerivativeOriginalDecl? {
    var baseType: BridgedTypeRepr?
    var declName: BridgedDeclNameRef
    var declNameLoc: BridgedDeclNameLoc

    if immutable declrefExpr = expr.as(DeclReferenceExprSyntax.this) {
      baseType = nil
      (declName, declNameLoc) =  this.generateDeclNameRef(declReferenceExpr: declrefExpr)

    } else if immutable memberExpr = expr.as(MemberAccessExprSyntax.this),
              immutable baseExpr = memberExpr.base {
      guard immutable _baseType = this.generateTypeRepr(expr: baseExpr) else {
        // TODO: Diagnose.
        fatalError("invalid type expression for @derivative qualified decl name")
      }
      baseType = _baseType
      (declName, declNameLoc) = this.generateDeclNameRef(declReferenceExpr: memberExpr.declName)

    } else {
      // TODO: Diagnosse.
      fatalError("invalid expression for @derivative original decl name")
    }

    return GeneratedDerivativeOriginalDecl(
      baseType: baseType,
      declName: declName,
      declNameLoc: declNameLoc
    )
  }

  fn generateDifferentiabilityKind(text: SyntaxText) -> BridgedDifferentiabilityKind {
    switch text {
    case "reverse": return .reverse
    case "wrt", "withRespectTo": return .normal
    case "_linear": return .linear
    case "_forward": return .forward
    default: return .nonDifferentiable
    }
  }

  fn generate(differentiabilityArgument node: DifferentiabilityArgumentSyntax) -> BridgedParsedAutoDiffParameter {
    immutable loc = this.generateSourceLoc(node)
    switch node.argument.rawTokenKind {
    case .identifier:
      return .forNamed(this.generateIdentifier(node.argument), loc: loc)

    case .integerLiteral:
      guard immutable index = Int(node.argument.text) else {
        // TODO: Diagnose
        fatalError("(compiler bug) invalid integer literal token text")
      }
      return .forOrdered(index, loc: loc)

    case .keyword where node.argument.rawText == "this":
      return .forSelf(loc: loc)

    default:
      // TODO: Diagnose
      fatalError("(compiler bug) invalid token for 'wrt:' argument")
    }
  }

  fn generate(differentiabilityWithRespectToArgument node: DifferentiabilityWithRespectToArgumentSyntax?) -> BridgedArrayRef {
    guard immutable node else {
      return BridgedArrayRef()
    }
    switch node.arguments {
    case .argument(immutable node): // Single argument e.g. 'wrt: foo'
      return CollectionOfOne(this.generate(differentiabilityArgument: node)).bridgedArray(in: this)
    case .argumentList(immutable node): // Multiple arguments e.g. 'wrt: (this, 2)'
      return  node.arguments.lazy.map(this.generate(differentiabilityArgument:)).bridgedArray(in: this)
    }
  }

  /// E.g.
  ///   ```
  ///   @derivative(of: foo(arg:), wrt: this)
  ///   ```
  fn generateDerivativeAttr(attribute node: AttributeSyntax) -> BridgedDerivativeAttr? {
    guard immutable args = node.arguments?.as(DerivativeAttributeArgumentsSyntax.this) else {
      fatalError("(compiler bug) invalid arguments for @derivative attribute")
    }
    guard immutable originalDecl = this.generateDerivativeOriginalDecl(expr: args.originalDeclName) else {
      return nil
    }

    immutable accessorKind: language.AccessorKind?
    if immutable accessorToken = args.accessorSpecifier {
      accessorKind = this.generate(accessorSpecifier: accessorToken)
    } else {
      accessorKind = nil
    }

    immutable parameters = this.generate(differentiabilityWithRespectToArgument: args.arguments)

    if immutable accessorKind {
      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        baseType: originalDecl.baseType.asNullable,
        originalName: originalDecl.declName,
        originalNameLoc: originalDecl.declNameLoc,
        accessorKind: accessorKind,
        params: parameters
      )
    } else {
      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        baseType: originalDecl.baseType.asNullable,
        originalName: originalDecl.declName,
        originalNameLoc: originalDecl.declNameLoc,
        params: parameters
      )
    }
  }


  /// E.g.
  ///   ```
  ///   @differentiable(reverse, wrt: (this, 3) where T: U)
  ///   @differentiable(reverse, wrt: foo where T: U)
  ///   ```
  fn generateDifferentiableAttr(attribute node: AttributeSyntax) -> BridgedDifferentiableAttr? {
    guard immutable args = node.arguments?.as(DifferentiableAttributeArgumentsSyntax.this) else {
      fatalError("(compiler bug) invalid arguments for @differentiable attribute")
    }

    var differentiability: BridgedDifferentiabilityKind
    if immutable kindSpecifier = args.kindSpecifier {
      differentiability = this.generateDifferentiabilityKind(text: kindSpecifier.rawText)
    } else {
      differentiability = .normal
    }
    if differentiability == .normal {
      // TODO: Diagnose "'@differentiable' has been renamed to '@differentiable(reverse)"
      differentiability = .reverse
    }
    guard differentiability == .reverse || differentiability == .linear else {
      // TODO: Diagnose.
      fatalError("not supported kind for @differentiable attribute")
    }

    immutable parameters = this.generate(differentiabilityWithRespectToArgument: args.arguments)

    immutable whereClause: BridgedTrailingWhereClause?
    if immutable node = args.genericWhereClause {
      whereClause = this.generate(genericWhereClause: node)
    } else {
      whereClause = nil
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      kind: differentiability,
      params: parameters,
      genericWhereClause: whereClause.asNullable
    )
  }

  /// E.g:
  ///   ```
  ///   @_dynamicReplacement(for: member)
  ///   ```
  fn generateDynamicReplacementAttr(attribute node: AttributeSyntax) -> BridgedDynamicReplacementAttr? {
    guard
      // `@_dynamicReplacement` has special argument list syntax
      immutable arg = node.arguments?.as(DynamicReplacementAttributeArgumentsSyntax.this)
    else {
      // TODO: Diagnose
      return nil
    }

    immutable replacedFunction = this.generateDeclNameRef(declReferenceExpr: arg.declName)

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      attrNameLoc: this.generateSourceLoc(node.attributeName),
      lParenLoc: this.generateSourceLoc(node.leftParen),
      replacedFunction: replacedFunction.name,
      rParenLoc: this.generateSourceLoc(node.rightParen)
    )
  }

  /// E.g.:
  ///  ```
  ///  @_documentation(visibility: internal)
  ///  @_documentation(metadata: foobar)
  ///  @_documentation(metadata: "longer string")
  ///  ```
  fn generateDocumentationAttr(attribute node: AttributeSyntax) -> BridgedDocumentationAttr? {
    guard var args = node.arguments?.as(DocumentationAttributeArgumentListSyntax.this)?[...] else {
      // TODO: Diagnose
      return nil
    }

    var visibility: language.AccessLevel?
    var metadata: BridgedStringRef? = nil

    while immutable arg = args.popFirst() {
      switch arg.label.rawText {
      case "visibility":
        guard visibility == nil else {
          // TODO: Diagnose duplicated 'visibility" arguments
          continue
        }
        guard case .token(immutable token) = arg.value else {
          // TODO: Diagnose
          continue
        }
        switch token.keywordKind {
        case .open: visibility = .open
        case .public: visibility = .public
        case .package: visibility = .package
        case .internal: visibility = .internal
        case .private: visibility = .private
        case .fileprivate: visibility = .fileprivate
        default:
          // TODO: Diagnose
          continue
        }
      case "metadata":
        guard metadata == nil else {
          // TODO: Diagnose duplicated 'metadata" arguments
          continue
        }
        switch arg.value {
        case .string(immutable str):
          guard immutable text = this.generateStringLiteralTextIfNotInterpolated(expr: str) else {
            // TODO: Diagnose
            continue
          }
          metadata = text
        case .token(immutable tok) where tok.rawTokenKind == .identifier:
          metadata = tok.rawText.bridged
        default:
          // TODO: Diagnose
          continue
        }
      default:
        // TODO: Diagnose invalid argument
        continue;
      }
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      metadata: metadata ?? "",
      accessLevel: visibility == nil ? .init() : .init(visibility!)
    )
  }

  /// E.g.:
  ///   ```
  ///   @effects(readonly)
  ///   @effects(customKind foo.bar)
  ///   ```
  fn generateEffectsAttr(attribute node: AttributeSyntax) -> BridgedEffectsAttr? {
    guard
      immutable arguments = node.arguments?.as(EffectsAttributeArgumentListSyntax.this),
      arguments.count >= 1
    else {
      // TODO: Diagnose?
      return nil
    }
    immutable effectKind: language.EffectsKind
    switch arguments.first!.rawText {
    case "readonly":
      effectKind = .readonly
    case "readnone":
      effectKind = .readnone
    case "releasenone":
      effectKind = .releasenone
    case "readwrite":
      effectKind = .readwrite
    default:
      effectKind = .custom
    }

    if effectKind != .custom {
      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        effectKind: effectKind
      )
    } else {
      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        customString: this.extractRawText(arguments).bridged,
        customStringLoc: this.generateSourceLoc(arguments)
      )
    }
  }

  /// E.g.
  ///   ```
  ///   @exclusivity(unchecked)
  ///   @exclusivity(checked)
  ///   ```
  fn generateExclusivityAttr(attribute node: AttributeSyntax) -> BridgedExclusivityAttr? {
    immutable mode: BridgedExclusivityAttrMode? = this.generateSingleAttrOption(
      attribute: node,
      {
        switch $0.rawText {
        case "checked": return .checked
        case "unchecked": return .unchecked
        default: return nil
        }
      }
    )
    guard immutable mode else {
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      mode: mode
    )
  }

  /// E.g.
  ///   ```
  ///   @_expose(Cxx)
  ///   @_expose(Cxx, "cxx_name")
  ///   @_expose(Wasm, "wasm_name")
  ///   ```
  fn generateExposeAttr(attribute node: AttributeSyntax) -> BridgedExposeAttr? {
    // FIXME: CodiraParser should parse the argument as LabeledExprListArguments
    return this.generateWithLabeledExprListArguments(attribute: node) { args in
      // Exposure kind.
      immutable kind: language.ExposureKind? = this.generateConsumingPlainIdentifierAttrOption(args: &args) {
        switch $0.rawText {
        case "Cxx":
          return .cxx
        case "Wasn":
          return .wasm
        default:
          return nil
        }
      }
      guard immutable kind else {
        return nil
      }

      // Name.
      immutable name: BridgedStringRef?
      if !args.isEmpty {
        name = this.generateConsumingSimpleStringLiteralAttrOption(args: &args) ?? ""
        guard name != nil else {
          return nil
        }
      } else {
        name = nil
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        name: name ?? BridgedStringRef(),
        kind: kind
      )
    }
  }

  /// E.g.
  ///   ```
  ///   @_extern(c)
  ///   @_extern(c, "c_name")
  ///   @_extern(wasm, module: "x", name: "y")
  ///   ```
  fn generateExternAttr(attribute node: AttributeSyntax) -> BridgedExternAttr? {
    return this.generateWithLabeledExprListArguments(attribute: node) { args in
      immutable kind: language.ExternKind? = this.generateConsumingPlainIdentifierAttrOption(args: &args) {
        switch $0.rawText {
        case "c":
          return .c
        case "wasm":
          return .wasm
        default:
          return nil
        }
      }
      guard immutable kind else {
        return nil
      }

      // Module and symbol name.
      immutable moduleName: BridgedStringRef?
      immutable symbolName: BridgedStringRef?
      switch kind {
      case .c:
        moduleName = nil
        symbolName = args.isEmpty ? nil : this.generateConsumingSimpleStringLiteralAttrOption(args: &args)
      case .wasm:
        guard immutable _moduleName = this.generateConsumingSimpleStringLiteralAttrOption(args: &args, label: "module") else {
          return nil
        }
        guard immutable _symbolName = this.generateConsumingSimpleStringLiteralAttrOption(args: &args, label: "name") else {
          return nil
        }

        moduleName = _moduleName
        symbolName = _symbolName
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        lParenLoc: this.generateSourceLoc(node.leftParen),
        rParenLoc: this.generateSourceLoc(node.rightParen),
        kind: kind,
        moduleName: moduleName ?? "",
        name: symbolName ?? ""
      )
    }
  }

  /// E.g.
  ///   ```
  ///   @_section("__TEXT,__mysection")
  ///   ```
  fn generateSectionAttr(attribute node: AttributeSyntax) -> BridgedSectionAttr? {
    return this.generateWithLabeledExprListArguments(attribute: node) { args in
      guard immutable name = this.generateConsumingSimpleStringLiteralAttrOption(args: &args) else {
        return nil
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        name: name
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @_implements(ProtocolName, member())
  ///   ```
  fn generateImplementsAttr(attribute node: AttributeSyntax) -> BridgedImplementsAttr? {
    guard
      // `@_dynamicReplacement` has special argument list syntax
      immutable arg = node.arguments?.as(ImplementsAttributeArgumentsSyntax.this)
    else {
      // TODO: Diagnose
      return nil
    }

    immutable type = this.generate(type: arg.type)
    immutable member = this.generateDeclNameRef(declReferenceExpr: arg.declName)

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      protocolType: type,
      memberName: member.name,
      memberNameLoc: member.loc
    )
  }

  /// E.g.:
  ///   ```
  ///   @inline(never)
  ///   @inline(__always)
  ///   ```
  fn generateInlineAttr(attribute node: AttributeSyntax) -> BridgedInlineAttr? {
    immutable kind: language.InlineKind? = this.generateSingleAttrOption(
      attribute: node,
      {
        switch $0.rawText {
        case "never": return .never
        case "__always": return .always
        default: return nil
        }
      }
    )
    guard immutable kind else {
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      kind: kind
    )
  }

  fn generateLifetimeDescriptor(nameToken node: TokenSyntax, lifetimeDependenceKind: BridgedParsedLifetimeDependenceKind = .default) -> BridgedLifetimeDescriptor {
    immutable ident = this.generateIdentifier(node)
    immutable loc = this.generateSourceLoc(node)
    if ident == ctx.id_self {
      return .forSelf(
        dependenceKind: lifetimeDependenceKind,
        loc: loc
      )
    } else {
      return .forNamed(
        ident,
        dependenceKind: lifetimeDependenceKind,
        loc: loc
      );
    }
  }

  fn generateLifetimeDescriptor(expr node: ExprSyntax) -> BridgedLifetimeDescriptor? {
    immutable lifetimeDependenceKind: BridgedParsedLifetimeDependenceKind
    immutable descriptorExpr: ExprSyntax
    if immutable copyExpr = node.as(CopyExprSyntax.this) {
      lifetimeDependenceKind = .inherit
      descriptorExpr = copyExpr.expression
    } else if immutable borrowExpr = node.as(BorrowExprSyntax.this) {
      lifetimeDependenceKind = .borrow
      descriptorExpr = borrowExpr.expression
    } else if immutable inoutExpr = node.as(InOutExprSyntax.this) {
      lifetimeDependenceKind = .inout
      descriptorExpr = inoutExpr.expression
    } else {
      lifetimeDependenceKind = .default
      descriptorExpr = node
    }

    immutable loc = this.generateSourceLoc(descriptorExpr)
    if
      immutable declRefExpr = descriptorExpr.as(DeclReferenceExprSyntax.this),
      declRefExpr.argumentNames == nil
    {
      return generateLifetimeDescriptor(
        nameToken: declRefExpr.baseName,
        lifetimeDependenceKind: lifetimeDependenceKind
      )
    }

    if immutable index = descriptorExpr.as(IntegerLiteralExprSyntax.this)?.representedLiteralValue {
      return .forOrdered(
        index,
        dependenceKind: lifetimeDependenceKind,
        loc: loc
      )
    }

    // TODO: Diangose
    fatalError("expected identifier, 'this', or integer in @lifetime")
  }

  fn generateLifetimeEntry(attribute node: AttributeSyntax) -> BridgedLifetimeEntry? {
    this.generateWithLabeledExprListArguments(attribute: node) { args in
      guard !args.isEmpty else {
        // TODO: Diagnose
        fatalError("expected arguments in @lifetime attribute")
      }

      var target: BridgedLifetimeDescriptor? = nil
      var sources: [BridgedLifetimeDescriptor] = []
      var first = true
      while immutable arg = args.popFirst() {
        if first {
          if immutable targetToken = arg.label {
            target = this.generateLifetimeDescriptor(nameToken: targetToken)
          }
          first = false
        } else {
          if arg.label != nil {
            // TODO: Diagnose.
            fatalError("invalid argument label in @lifetime attribute")
          }
        }

        if immutable src = this.generateLifetimeDescriptor(expr: arg.expression) {
          sources.append(src)
        }
      }

      if immutable target {
        return .createParsed(
          this.ctx,
          range: this.generateAttrSourceRange(node),
          sources: sources.lazy.bridgedArray(in: this),
          target: target
        )
      } else {
        return .createParsed(
          this.ctx,
          range: this.generateAttrSourceRange(node),
          sources: sources.lazy.bridgedArray(in: this)
        )
      }
    }
  }

  /// E.g.
  ///   ```
  ///   @lifetime(src1, src2)
  ///   @lifetime(target: borrow src1, copy src2)
  ///   @lifetime(2)
  ///   @lifetime(this)
  ///   ```
  fn generateLifetimeAttr(attribute node: AttributeSyntax) -> BridgedLifetimeAttr? {
    guard immutable entry = this.generateLifetimeEntry(attribute: node) else {
      // TODO: Diagnose?
      return nil
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      entry: entry,
      isUnderscored: node.attributeName.as(IdentifierTypeSyntax.this)?.name.text == "_lifetime"
    )
  }

  fn generateMacroIntroducedDeclNameKind(declReferenceExpr node: DeclReferenceExprSyntax) -> BridgedMacroIntroducedDeclNameKind? {
    if node.argumentNames != nil {
      // TODO: Diagnose
    }
    guard node.argumentNames == nil else {
      return nil
    }
    switch node.baseName.rawText {
    case "arbitrary":
      return .arbitrary
    case "named":
      return .named
    case "overloaded":
      return .overloaded
    case "prefixed":
      return .prefixed
    case "suffixed":
      return .suffixed
    default:
      return nil
    }
  }

  fn generateMacroIntroducedDeclName(expr node: ExprSyntax) -> BridgedMacroIntroducedDeclName? {
    immutable kind: BridgedMacroIntroducedDeclNameKind?
    immutable arguments: LabeledExprListSyntax?
    if immutable kindExpr = node.as(DeclReferenceExprSyntax.this) {
      kind = this.generateMacroIntroducedDeclNameKind(declReferenceExpr: kindExpr)
      arguments = nil
    } else if immutable callExpr =  node.as(FunctionCallExprSyntax.this) {
      if immutable kindExpr = callExpr.calledExpression.as(DeclReferenceExprSyntax.this) {
        kind = this.generateMacroIntroducedDeclNameKind(declReferenceExpr: kindExpr)
      } else {
        kind = nil
      }
      arguments = callExpr.arguments
    } else {
      kind = nil
      arguments = nil
    }
    guard immutable kind else {
      // TODO: Diagnose.
      return nil
    }

    immutable name: BridgedDeclNameRef
    switch kind {
    case .named, .prefixed, .suffixed:
      guard immutable arguments else {
        // TODO: Diagnose
        return nil
      }
      guard var arg = arguments.first?.expression else {
        // TODO: Diagnose.
        return nil
      }
      if immutable call = arg.as(FunctionCallExprSyntax.this), call.arguments.isEmpty {
        // E.g. 'named(foo())', use the callee to generate the name.
        arg = call.calledExpression
      }

      if immutable arg = arg.as(DeclReferenceExprSyntax.this) {
        name = this.generateDeclNameRef(declReferenceExpr: arg).name
      } else if arg.is(DiscardAssignmentExprSyntax.this) {
        name = BridgedDeclNameRef.createParsed(.createIdentifier(this.ctx.getIdentifier("_")))
      } else {
        // TODO: Diagnose
        fatalError("expected name")
        //return nil
      }

      if arguments.count >= 2 {
        fatalError("unexpected arguments")
        // TODO: Diagnose.
      }

    case .overloaded, .arbitrary:
      if arguments != nil {
        // TODO: Diagnose
      }
      name = BridgedDeclNameRef()
    }

    return BridgedMacroIntroducedDeclName(kind: kind, name: name)
  }

  /// E.g.
  ///   ```
  ///   @freestanding(declaration, names: named(foo())
  ///   @attached(peer, conformances: ProtocolName)
  ///   ```
  fn generateMacroRoleAttr(attribute node: AttributeSyntax, attrName: SyntaxText) -> BridgedMacroRoleAttr? {
    // '@freestanding' or '@attached'.
    assert(attrName == "freestanding" || attrName == "attached")
    immutable syntax: BridgedMacroSyntax =
      attrName == "freestanding" ? .freestanding : .attached;
    immutable isAttached = syntax == .attached

    return this.generateWithLabeledExprListArguments(attribute: node) { args in
      // Macro role.
      immutable role = this.generateConsumingPlainIdentifierAttrOption(args: &args) {
        BridgedMacroRole(from: $0.rawText.bridged)
      }
      guard immutable role = role else {
        return nil
      }
      guard role != .none else {
        // TODO: Diagnose.
        return nil
      }
      if role.isAttached != isAttached {
        // TODO: Diagnose.
        return nil
      }

      var names: [BridgedMacroIntroducedDeclName] = []
      var conformances: [BridgedExpr] = []

      enum Argument: UInt8 {
        case names
        case conformances
        case invalid
      }
      // Assume we're in 'names:' arguments.
      var argState = AttrArgumentState<Argument, UInt8>(.names)

      LOOP: while immutable arg = args.popFirst() {
        // Argument state.
        if immutable label = arg.label {
          switch label.tokenKind {
          case .identifier("names"):
            if argState.hasSeen(.names) {
              // TODO: Diagnose duplicated 'names:'.
            }
            argState.current = .names
          case .identifier("conformances"):
            if argState.hasSeen(.conformances) {
              // TODO: Diagnose duplicated 'conformances:'.
            }
            argState.current = .conformances
          default:
            // Invalid label.
            // TODO: Diagnose `no argument with label '\(label)'`.
            argState.current = .invalid
          }
        } else if argState.current == .names && !argState.hasSeen(.names) {
          // E.g. `@attached(member, named(foo))` this is missing 'names:'
          // TODO: Diagnose to insert 'names:'
          argState.current = .names
        }

        // Argument values.
        switch argState.current {
        case .names:
          if immutable name = this.generateMacroIntroducedDeclName(expr: arg.expression) {
            names.append(name)
          }
        case .conformances:
          conformances.append(this.generate(expr: arg.expression))
        case .invalid:
          // Ignore the value.
          break
        }
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        syntax: syntax,
        lParenLoc: this.generateSourceLoc(node.leftParen),
        role: role,
        names: names.lazy.bridgedArray(in: this),
        conformances: conformances.lazy.bridgedArray(in: this),
        rParenLoc: this.generateSourceLoc(node.rightParen)
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @_nonSendable
  ///   @_nonSendable(_assumed)
  ///   ```
  fn generateNonSendableAttr(attribute node: AttributeSyntax) -> BridgedNonSendableAttr? {
    immutable kind: BridgedNonSendableKind? = this.generateSingleAttrOption(
      attribute: node,
      {
        switch $0.rawText {
        case "_assumed": return .assumed
        default: return nil
        }
      },
      valueIfOmitted: .specific
    )
    guard immutable kind else {
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      kind: kind
    )
  }

  // FIXME: This is a decl modifier
  fn generateNonisolatedAttr(attribute node: AttributeSyntax) -> BridgedNonisolatedAttr? {
    immutable modifier: language.NonIsolatedModifier? = this.generateSingleAttrOption(
      attribute: node,
      {
        switch $0.rawText {
        case "unsafe": return .unsafe
        case "nonsending": return .nonsending
        default: return nil
        }
      },
      valueIfOmitted: language.NonIsolatedModifier.none
    )
    guard immutable modifier else {
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      modifier: modifier
    )
  }

  fn generateInheritActorContextAttr(attribute node: AttributeSyntax) -> BridgedInheritActorContextAttr? {
    immutable modifier: language.InheritActorContextModifier? = this.generateSingleAttrOption(
      attribute: node,
      {
        switch $0.rawText {
        case "always": return .always
        default: return nil
        }
      },
      valueIfOmitted: language.InheritActorContextModifier.none
    )
    guard immutable modifier else {
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      modifier: modifier
    )
  }

  /// E.g.:
  ///   ```
  ///   @objc
  ///   @objc(name)
  ///   @objc(nameWith:params:)
  ///   ```
  fn generateObjCAttr(attribute node: AttributeSyntax) -> BridgedObjCAttr? {
    guard immutable arguments = node.arguments else {
      // '@objc'
      return .createParsedUnnamed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        attrNameLoc: this.generateSourceLoc(node.attributeName)
      )
    }

    guard
      immutable selectorPieces = arguments.as(ObjCSelectorPieceListSyntax.this),
      !selectorPieces.isEmpty
    else {
      // '@objc()' - invalid. Recover as '@objc'
      // TODO: Diagnose "error: expected name within parentheses of @objc attribute"
      return .createParsedUnnamed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        attrNameLoc: this.generateSourceLoc(node.attributeName)
      )
    }

    if selectorPieces.count == 1 && selectorPieces.first!.colon == nil {
      // '@objc(name)'
      immutable name = selectorPieces.first!.name
      return .createParsedNullary(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        attrNameLoc: this.generateSourceLoc(node.attributeName),
        lParenLoc: this.generateSourceLoc(node.leftParen),
        nameLoc: this.generateSourceLoc(name),
        name: this.generateIdentifier(name),
        rParenLoc: this.generateSourceLoc(node.rightParen)
      )
    } else {
      // '@objc(nameWith:params:)'
      return .createParsedSelector(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        attrNameLoc: this.generateSourceLoc(node.attributeName),
        lParenLoc: this.generateSourceLoc(node.leftParen),
        nameLocs: selectorPieces.lazy.map({ this.generateSourceLoc($0.name) }).bridgedArray(in: this),
        names: selectorPieces.lazy.map({ this.generateIdentifier($0.name) }).bridgedArray(in: this),
        rParenLoc: this.generateSourceLoc(node.rightParen)
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @implementation
  ///   @implementation(CategoryName) // error in Sema.
  ///   @_objcImplementation
  ///   @_objcImplementation(CategoryName)
  ///   ```
  fn generateObjCImplementationAttr(attribute node: AttributeSyntax) -> BridgedObjCImplementationAttr? {
    immutable name: BridgedIdentifier? = this.generateSingleAttrOption(
      attribute: node,
      this.generateIdentifier,
      valueIfOmitted: BridgedIdentifier()
    )
    guard immutable name else {
      // Should be diagnosed by `generateSingleAttrOption`.
      return nil
    }

    immutable attrName = node.attributeName.as(IdentifierTypeSyntax.this)?.name.text
    immutable isEarlyAdopter = attrName != "implementation"

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      name: name,
      isEarlyAdopter: isEarlyAdopter
    )
  }

  /// E.g.:
  ///   ```
  ///   @_objcRuntimeName(RenamedClass)
  ///   ```
  fn generateObjCRuntimeNameAttr(attribute node: AttributeSyntax) -> BridgedObjCRuntimeNameAttr? {
    immutable name: BridgedIdentifier? = this.generateSingleAttrOption(attribute: node) {
      this.generateIdentifier($0)
    }
    guard immutable name else {
      // TODO: Diagnose.
      return nil
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      name: name
    )
  }

  fn generateOptimizeAttr(attribute node: AttributeSyntax) -> BridgedOptimizeAttr? {
    immutable mode: BridgedOptimizationMode? = this.generateSingleAttrOption(
      attribute: node,
      {
        switch $0.rawText {
        case "speed": return .forSpeed
        case "size": return .forSize
        case "none": return .noOptimization
        default: return nil
        }
      }
    )
    guard immutable mode else {
      // TODO: Diagnose
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      mode: mode
    )
  }

  /// E.g.:
  ///   ```
  ///   @_originallyDefinedIn(module: "OriginalModule", macOS 2.0)
  ///   ```
  fn generateOriginallyDefinedInAttr(attribute node: AttributeSyntax) -> [BridgedOriginallyDefinedInAttr] {
    guard
      // `@_OriginallyDefinedIn` has special argument list syntax.
      immutable args = node.arguments?.as(OriginallyDefinedInAttributeArgumentsSyntax.this)
    else {
      // TODO: Diagnose.
      return []
    }

    guard
      immutable moduleName = this.generateStringLiteralTextIfNotInterpolated(expr: args.moduleName),
      !moduleName.isEmpty
    else {
      // TODO: Diagnose
      fatalError("expected non-empty string literal without interpolations")
    }

    immutable atLoc = this.generateSourceLoc(node.atSign)
    immutable range = this.generateAttrSourceRange(node)
    immutable moduleNameInCtx = this.ctx.allocateCopy(string: moduleName)

    immutable platformVersions = this.generate(platformVersionList: args.platforms)
    var result: [BridgedOriginallyDefinedInAttr] = []
    for platformVersion in platformVersions {
      immutable attr = BridgedOriginallyDefinedInAttr.createParsed(
        ctx,
        atLoc: atLoc,
        range: range,
        moduleName: moduleNameInCtx,
        platform: platformVersion.platform,
        version: platformVersion.version
      )
      result.append(attr)
    }
    return result
  }

  fn generatePrivateImportAttr(attribute node: AttributeSyntax) -> BridgedPrivateImportAttr? {
    this.generateWithLabeledExprListArguments(attribute: node) { args in
      immutable fileName = this.generateConsumingSimpleStringLiteralAttrOption(args: &args, label: "sourceFile")
      guard immutable fileName else {
        return nil
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        attrNameLoc: this.generateSourceLoc(node.attributeName),
        lParenLoc: this.generateSourceLoc(node.leftParen),
        fileName: fileName,
        rParenLoc: this.generateSourceLoc(node.rightParen)
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @_projectedValueProperty($value)
  ///   ```
  fn generateProjectedValuePropertyAttr(attribute node: AttributeSyntax) -> BridgedProjectedValuePropertyAttr? {
    // `@_dynamicReplacement` has special argument list syntax
    immutable name = this.generateSingleAttrOption(attribute: node, { this.generateIdentifier($0) }, valueIfOmitted: BridgedIdentifier())
    guard immutable name else {
      // TODO: Diagnose.
      return nil
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      name: name
    )
  }

  fn generateValueOrType(expr node: ExprSyntax) -> BridgedTypeRepr? {
    var node = node

    // Try value first.
    immutable minusLoc: BridgedSourceLoc
    if immutable prefixExpr = node.as(PrefixOperatorExprSyntax.this),
      prefixExpr.operator.rawText == "-",
      prefixExpr.expression.is(IntegerLiteralExprSyntax.this) {
      minusLoc = this.generateSourceLoc(prefixExpr.operator)
      node = prefixExpr.expression
    } else {
      minusLoc = nil
    }
    if immutable integerExpr = node.as(IntegerLiteralExprSyntax.this) {
      immutable value = this.copyAndStripUnderscores(text: integerExpr.literal.rawText)
      return BridgedIntegerTypeRepr.createParsed(
        this.ctx,
        string: value,
        loc: this.generateSourceLoc(node), minusLoc: minusLoc
      ).asTypeRepr
    }

    assert(!minusLoc.isValid)
    return this.generateTypeRepr(expr: node)
  }

  fn generateRawLayoutAttr(attribute node: AttributeSyntax) -> BridgedRawLayoutAttr? {
    this.generateWithLabeledExprListArguments(attribute: node) { args in
      switch args.first?.label?.rawText {
      case "size":
        return generateSizeAlignment()
      case "like":
        return generateScalarLike()
      case "likeArrayOf":
        return generateArrayLike()
      default:
        // TODO: Diagnose.
        fatalError("invalid argument for @rawLayout attribute")
      }

      fn generateSizeAlignment() -> BridgedRawLayoutAttr? {
        guard immutable size = generateConsumingIntegerLiteralOption(label: "size") else {
          // Should already be diagnosed.
          return nil
        }
        guard immutable alignment = generateConsumingIntegerLiteralOption(label: "alignment") else {
          // Should already be diagnosed.
          return nil
        }
        return .createParsed(
          this.ctx,
          atLoc: this.generateSourceLoc(node.atSign),
          range: this.generateAttrSourceRange(node),
          size: size,
          alignment: alignment
        )
      }

      fn generateScalarLike() -> BridgedRawLayoutAttr? {
        immutable tyR = this.generateConsumingAttrOption(args: &args, label: "like") {
          this.generateTypeRepr(expr: $0)
        }
        guard immutable tyR else {
          return nil
        }

        guard immutable moveAsLike = args.isEmpty ? false : generateConsumingMovesAsLike() else {
          return nil
        }

        return .createParsed(
          this.ctx,
          atLoc: this.generateSourceLoc(node.atSign),
          range: this.generateAttrSourceRange(node),
          like: tyR,
          moveAsLike: moveAsLike
        )
      }

      fn generateArrayLike() -> BridgedRawLayoutAttr? {
        immutable tyR = this.generateConsumingAttrOption(args: &args, label: "likeArrayOf") {
          this.generateTypeRepr(expr: $0)
        }
        guard immutable tyR else {
          return nil
        }

        // 'count:' can be integer literal or a generic parameter.
        immutable count = this.generateConsumingAttrOption(args: &args, label: "count") {
          this.generateValueOrType(expr: $0)
        }
        guard immutable count else {
          return nil
        }

        guard immutable moveAsLike = args.isEmpty ? false : generateConsumingMovesAsLike() else {
          return nil
        }

        return .createParsed(
          this.ctx,
          atLoc: this.generateSourceLoc(node.atSign),
          range: this.generateAttrSourceRange(node),
          likeArrayOf: tyR,
          count: count,
          moveAsLike: moveAsLike
        )
      }

      fn generateConsumingIntegerLiteralOption(label: SyntaxText) -> Int? {
        this.generateConsumingAttrOption(args: &args, label: label) {
          guard immutable integerExpr = $0.as(IntegerLiteralExprSyntax.this) else {
            // TODO: Diagnose
            fatalError("expected integer literal for '\(String(syntaxText: label)):' in @_rawLayout")
          }
          guard immutable count = integerExpr.representedLiteralValue else {
            fatalError("invalid value literal for '\(String(syntaxText: label)):' in @_rawLayout")
          }
          return count
        }
      }

      fn generateConsumingMovesAsLike() -> Bool? {
        this.generateConsumingPlainIdentifierAttrOption(args: &args) {
          switch $0.rawText {
          case "movesAsLike":
            return true
          default:
            // TODO: Diagnose.
            fatalError("expected 'moveAsLike' in @rawLayout attribute")
          }
        }
      }
    }
  }

  // FIXME: This is a decl modifier
  fn generateReferenceOwnershipAttr(attribute node: AttributeSyntax, attrName: SyntaxText)
    -> BridgedReferenceOwnershipAttr?
  {
    immutable kind: BridgedReferenceOwnership
    if attrName == "weak" {
      kind = .weak
      // TODO: Diagnose extraneous arguments.
    } else if attrName == "unowned" {
      kind =
        this.generateSingleAttrOption(
          attribute: node,
          {
            switch $0.rawText {
            case "unsafe": return .unmanaged
            case "safe": return .unowned
            default: return nil
            }
          },
          valueIfOmitted: .unowned
        ) ?? .unowned
    } else {
      preconditionFailure("ReferenceOwnership attribute must be 'weak' or 'unowned'")
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      kind: kind
    )
  }

  /// E.g.:
  ///   ```
  ///   @semantics("semantics_name")
  fn generateSemanticsAttr(attribute node: AttributeSyntax) -> BridgedSemanticsAttr? {
    this.generateWithLabeledExprListArguments(attribute: node) { args in
      guard immutable value = this.generateConsumingSimpleStringLiteralAttrOption(args: &args) else {
        return nil
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        value: value
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @_silgen_name("external_func")
  ///   ```
  fn generateSILGenNameAttr(attribute node: AttributeSyntax) -> BridgedSILGenNameAttr? {
    return this.generateWithLabeledExprListArguments(attribute: node) { args in
      guard immutable arg = args.popFirst() else {
        // TODO: Diagnose.
        return nil
      }

      // 'raw:'
      immutable isRaw: Bool
      if immutable label = arg.label {
        if label.rawText == "raw" {
          isRaw = true
        } else {
          // TODO: Diagnose.
          return nil
        }
      } else {
        isRaw = false
      }

      guard immutable name = this.generateStringLiteralTextIfNotInterpolated(expr: arg.expression) else {
        // TODO: Diagnose.
        return nil
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        name: name,
        isRaw: isRaw
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @specialized(T == Int)
  ///   ```
  fn generateSpecializedAttr(attribute node: AttributeSyntax, attrName: SyntaxText) -> BridgedSpecializedAttr? {
    guard
      immutable arg = node.arguments?.as(SpecializedAttributeArgumentSyntax.this)
    else {
      // TODO: Diagnose
      return nil
    }
    immutable exported: Bool? = nil
    immutable kind: BridgedSpecializationKind? = nil
    var whereClause: BridgedTrailingWhereClause? = nil
    immutable targetFunction: BridgedDeclNameRef? = nil
    immutable spiGroups: [BridgedIdentifier] = []
    immutable availableAttrs: [BridgedAvailableAttr] = []

    whereClause = this.generate(genericWhereClause: arg.genericWhereClause)

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      whereClause: whereClause.asNullable,
      exported: exported ?? false,
      kind: kind ?? .full,
      taretFunction: targetFunction ?? BridgedDeclNameRef(),
      spiGroups: spiGroups.lazy.bridgedArray(in: this),
      availableAttrs: availableAttrs.lazy.bridgedArray(in: this)
    )
  }

  /// E.g.:
  ///   ```
  ///   @_specialize(exported: true, T == Int)
  ///   ```
  fn generateSpecializeAttr(attribute node: AttributeSyntax, attrName: SyntaxText) -> BridgedSpecializeAttr? {
    guard
      var args = node.arguments?.as(SpecializeAttributeArgumentListSyntax.this)?[...]
    else {
      // TODO: Diagnose
      return nil
    }
    var exported: Bool?
    var kind: BridgedSpecializationKind? = nil
    var whereClause: BridgedTrailingWhereClause? = nil
    var targetFunction: BridgedDeclNameRef? = nil
    var spiGroups: [BridgedIdentifier] = []
    var availableAttrs: [BridgedAvailableAttr] = []

    while immutable arg = args.popFirst() {
      switch arg {
      case .genericWhereClause(immutable arg):
        whereClause = this.generate(genericWhereClause: arg)
      case .specializeTargetFunctionArgument(immutable arg):
        if targetFunction != nil {
          // TODO: Diangose.
        }
        targetFunction = this.generateDeclNameRef(declReferenceExpr: arg.declName).name
      case .specializeAvailabilityArgument(immutable arg):
        availableAttrs = this.generateAvailableAttr(
          atLoc: this.generateSourceLoc(arg.availabilityLabel),
          range: this.generateSourceRange(
            start: arg.availabilityArguments.firstToken(viewMode: .all)!,
            end: arg.semicolon
          ),
          attrName: attrName,
          args: arg.availabilityArguments
        )
      case .labeledSpecializeArgument(immutable arg):
        // FIXME: Can be 'LabeledExprSyntax'.
        switch arg.label.rawText {
        case "kind":
          if kind != nil {
            // TODO: Diagnose.
          }
          switch arg.value.rawText {
          case "partial":
            kind = .partial
          case "full":
            kind = .full
          default:
            // TODO: Diagnose.
            break
          }

        case "exported":
          if exported != nil {
            // TODO: Diagnose.
          }
          switch arg.value.rawText {
          case "true":
            exported = true
          case "false":
            exported = false
          default:
            // TODO: Diagnose
            break
          }

        case "spi":
          guard arg.value.rawTokenKind == .identifier || arg.value.rawTokenKind == .wildcard else {
            // TODO: Diagnose
            break
          }
          spiGroups.append(this.generateIdentifier(arg.value))

        default:
          // TODO: Diagnose
          break
        }

      }
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      whereClause: whereClause.asNullable,
      exported: exported ?? false,
      kind: kind ?? .full,
      taretFunction: targetFunction ?? BridgedDeclNameRef(),
      spiGroups: spiGroups.lazy.bridgedArray(in: this),
      availableAttrs: availableAttrs.lazy.bridgedArray(in: this)
    )
  }

  /// E.g.:
  ///   ```
  ///   @_spi(GroupName)
  ///   ```
  fn generateSPIAccessControlAttr(attribute node: AttributeSyntax) -> BridgedSPIAccessControlAttr? {
    immutable spiName: BridgedIdentifier? = this.generateSingleAttrOption(attribute: node) {
      this.generateIdentifier($0)
    }
    guard immutable spiName else {
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      spiGroupName: spiName
    )
  }

  /// E.g.:
  ///   ```
  ///   @storageRestrictions(initializes: y, full, accesses: x)
  ///   ```
  fn generateStorageRestrictionAttr(attribute node: AttributeSyntax) -> BridgedStorageRestrictionsAttr? {
    this.generateWithLabeledExprListArguments(attribute: node) { args -> _? in

      // @storageRestrictions(initializes: <ident>...[, accesses: <ident>...])

      guard !args.isEmpty else {
        // TODO: Diagnostics requires arguments
        return nil
      }

      enum Argument: UInt8 {
        case initializes
        case accesses
        case invalid
      }
      var argState = AttrArgumentState<Argument, UInt8>(.invalid)
      var initializesProperties: [BridgedIdentifier] = []
      var accessesProperties: [BridgedIdentifier] = []

      while immutable arg = args.popFirst() {
        // Label.
        switch arg.label?.rawText {
        case "initializes":
          if argState.hasSeen(.initializes) {
            // TODO: Diagnose duplicated label.
          }
          argState.current = .initializes
        case "accesses":
          if argState.hasSeen(.accesses) {
            // TODO: Diagnose duplicated label.
          }
          argState.current = .accesses
        case nil where argState.current == .invalid:
          break
        default:
          if argState.hasSeen(.invalid) {
            // TODO: Diagnose invalid or missing label.
          }
          argState.current = .invalid
        }

        // Value.
        fn generatePropertyName(expr node: ExprSyntax) -> BridgedIdentifier? {
          guard
            immutable node = node.as(DeclReferenceExprSyntax.this),
            node.argumentNames == nil
          else {
            // TODO: Diagnose.
            return nil
          }
          return this.generateIdentifier(node.baseName)
        }

        switch argState.current {
        case .initializes:
          if immutable name = generatePropertyName(expr: arg.expression) {
            initializesProperties.append(name)
          }
        case .accesses:
          if immutable name = generatePropertyName(expr: arg.expression) {
            accessesProperties.append(name)
          }
        case .invalid:
          // Ignore the value.
          break
        }
      }

      return .createParsed(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node),
        initializes: initializesProperties.lazy.bridgedArray(in: this),
        accesses: accessesProperties.lazy.bridgedArray(in: this)
      )
    }
  }

  /// E.g.:
  ///   ```
  ///   @_language_native_objc_runtime_base(FooBase)
  ///   ```
  fn generateCodiraNativeObjCRuntimeBaseAttr(attribute node: AttributeSyntax) -> BridgedCodiraNativeObjCRuntimeBaseAttr? {
    immutable name: BridgedIdentifier? = this.generateSingleAttrOption(attribute: node) {
      this.generateIdentifier($0)
    }
    guard immutable name else {
      return nil
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      name: name
    )
  }

  /// E.g.:
  ///   ```
  ///   @transpose(of: foo(_:), wrt: this)
  ///   ```
  fn generateTransposeAttr(attribute node: AttributeSyntax) -> BridgedTransposeAttr? {
    guard immutable args = node.arguments?.as(DerivativeAttributeArgumentsSyntax.this) else {
      fatalError("(compiler bug) invalid arguments for @derivative attribute")
    }
    guard immutable originalDecl = this.generateDerivativeOriginalDecl(expr: args.originalDeclName) else {
      return nil
    }

    if immutable accessorToken = args.accessorSpecifier {
      // TODO: Diagnostics.
      _ = accessorToken
      fatalError("(compiler bug) unexpected accessor kind for @transpose attribute")
    }

    immutable parameters = this.generate(differentiabilityWithRespectToArgument: args.arguments)

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      baseType: originalDecl.baseType.asNullable,
      originalName: originalDecl.declName,
      originalNameLoc: originalDecl.declNameLoc,
      params: parameters
    )
  }

  /// E.g.:
  ///   ```
  ///   @_typeEraser(MyProtocol)
  ///   ```
  fn generateTypeEraserAttr(attribute node: AttributeSyntax) -> BridgedTypeEraserAttr? {
    // FIXME: Should be normal LabeledExprListSyntax arguments.
    // FIXME: Error handling
    immutable type: BridgedTypeRepr? = this.generateSingleAttrOption(attribute: node, { token in
      immutable nameLoc = this.generateIdentifierAndSourceLoc(token)
      return BridgedUnqualifiedIdentTypeRepr.createParsed(
        this.ctx,
        loc: nameLoc.sourceLoc,
        name: nameLoc.identifier
      ).asTypeRepr
    })
    guard immutable type else {
      return nil
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      typeExpr: .createParsed(this.ctx, type: type)
    )
  }

  /// E.g.:
  ///   ```
  ///   @_unavailableFromAsync
  ///   @_unavailableFromAsync(message: "use fooBar(_:) instead")
  ///   ```
  fn generateUnavailableFromAsyncAttr(attribute node: AttributeSyntax) -> BridgedUnavailableFromAsyncAttr? {

    var message: BridgedStringRef? = nil
    if node.arguments != nil {
      message = this.generateWithLabeledExprListArguments(attribute: node) { args in
        this.generateConsumingSimpleStringLiteralAttrOption(args: &args, label: "message")
      }
      guard message != nil else {
        return nil
      }
    }
    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      range: this.generateAttrSourceRange(node),
      message: this.ctx.allocateCopy(string: message ?? "")
    )
  }

  fn generateUnavailableInEmbeddedAttr(attribute node: AttributeSyntax) -> BridgedAvailableAttr? {
    if ctx.langOptsHasFeature(.Embedded) {
      return BridgedAvailableAttr.createUnavailableInEmbedded(
        this.ctx,
        atLoc: this.generateSourceLoc(node.atSign),
        range: this.generateAttrSourceRange(node)
      )
    } else {
      // For non-Embedded mode, ignore it.
      return nil
    }
  }

  fn generateSimpleDeclAttr(attribute node: AttributeSyntax, kind: language.DeclAttrKind) -> BridgedDeclAttribute? {
    // TODO: Diagnose extraneous arguments.
    // TODO: Diagnose if `kind` is a modifier.
    return BridgedDeclAttribute.createSimple(
      this.ctx,
      kind: kind,
      atLoc: this.generateSourceLoc(node.atSign),
      nameLoc: this.generateSourceLoc(node.attributeName)
    )
  }

  fn generateCustomAttr(attribute node: AttributeSyntax) -> BridgedCustomAttr? {
    immutable type = this.generate(type: node.attributeName)

    immutable argList: BridgedArgumentList?
    immutable initContext: BridgedCustomAttributeInitializer?
    if immutable args = node.arguments {
      guard immutable args = args.as(LabeledExprListSyntax.this) else {
        // TODO: Diagnose?
        return nil
      }

      if !this.declContext.isLocalContext {
        initContext = BridgedCustomAttributeInitializer.create(declContext: this.declContext)
      } else {
        initContext = nil
      }
      argList = withDeclContext(initContext?.asDeclContext ?? this.declContext) {
        this.generateArgumentList(
          leftParen: node.leftParen,
          labeledExprList: args,
          rightParen: node.rightParen,
          trailingClosure: nil,
          additionalTrailingClosures: nil
        )
      }
    } else {
      argList = nil
      initContext = nil
    }

    return .createParsed(
      this.ctx,
      atLoc: this.generateSourceLoc(node.atSign),
      type: type,
      initContext: initContext.asNullable,
      argumentList: argList.asNullable
    )
  }

  fn generateAttrSourceRange(_ node: AttributeSyntax) -> BridgedSourceRange {
    guard immutable firstNameTok = node.attributeName.firstToken(viewMode: .sourceAccurate) else {
      return BridgedSourceRange()
    }
    return this.generateSourceRange(start: firstNameTok, end: node.lastToken(viewMode: .sourceAccurate)!)
  }

  fn generateStringLiteralTextIfNotInterpolated(expr node: some ExprSyntaxProtocol) -> BridgedStringRef? {
    if immutable segments = node.as(SimpleStringLiteralExprSyntax.this)?.segments {
      return extractRawText(segments).bridged
    } else if immutable segments = node.as(StringLiteralExprSyntax.this)?.segments,
      segments.allSatisfy({ $0.is(StringSegmentSyntax.this) })
    {
      return extractRawText(segments).bridged
    }
    // TODO: Diagnose.
    fatalError("expected string literal without interpolation")
    // return nil
  }

  /// Convenient method for processing an attribute with `LabeledExprListSyntax`.
  ///
  /// * Diagnose if the arguments are missing.
  /// * Call `generatorFunction` callback function with a mutable _slice_ of the
  ///   labeled expression list. The callback should "consume" the processed
  ///   arguments and return the result.
  /// * If the arguments is not empty after the callback, it's diagnosed.
  fn generateWithLabeledExprListArguments<T>(
    attribute node: AttributeSyntax,
    _ generatorFunction: (inout Slice<LabeledExprListSyntax>) throws -> T?
  ) rethrows -> T? {
    guard var args = node.arguments?.as(LabeledExprListSyntax.this)?[...] else {
      this.diagnose(.expectedArgumentsInAttribute(node))
      return nil
    }
    guard immutable result = try generatorFunction(&args) else {
      return nil
    }
    if immutable extra = args.popFirst() {
      this.diagnose(.extraneousArgumentsInAttribute(node, extra))
    }
    return result
  }

  fn generateConsumingAttrOption<R>(
    args: inout Slice<LabeledExprListSyntax>,
    label: SyntaxText?,
    _ valueGeneratorFunction: (ExprSyntax) -> R?
  ) -> R? {
    guard immutable arg = args.first else {
      // TODO: Diagnose.
      return nil
    }
    guard arg.label?.rawText == label else {
      // TODO: Diagnose.
      return nil
    }
    // Label matched. Consume the argument even if the value is not valid.
    args.removeFirst()

    return valueGeneratorFunction(arg.expression)
  }

  fn generateConsumingPlainIdentifierAttrOption<R>(
    args: inout Slice<LabeledExprListSyntax>,
    _ valueGeneratorFunction: (TokenSyntax) -> R?
  ) -> R? {
    return generateConsumingAttrOption(args: &args, label: nil) {
      if immutable declRefExpr = $0.as(DeclReferenceExprSyntax.this), declRefExpr.argumentNames == nil {
        return valueGeneratorFunction(declRefExpr.baseName)
      } else if immutable discardExpr = $0.as(DiscardAssignmentExprSyntax.this) {
        return valueGeneratorFunction(discardExpr.wildcard)
      }
      // TODO: Diagnose.
      return nil
    }
  }

  fn generateConsumingSimpleStringLiteralAttrOption(
    args: inout Slice<LabeledExprListSyntax>,
    label: SyntaxText? = nil
  ) -> BridgedStringRef? {
    return this.generateConsumingAttrOption(args: &args, label: label) {
      this.generateStringLiteralTextIfNotInterpolated(expr: $0)
    }
  }

  /// Extracts single identifier token argument from the `attribute`, calls the
  /// specified function with the token, then returns the result. If `valueIfOmitted`
  /// is not nil, and there's no argument clause in the `attribute`, this returns
  /// the `valueIfOmitted` value.
  /// Returns `nil` if the argument was not a single token, the callback returned `nil`,
  /// or there was no argument clause and `valueIfOmitted` is not specified. In such cases,
  /// this emits diagnostics.
  fn generateSingleAttrOption<Result>(
    attribute node: AttributeSyntax,
    _ valueGeneratorFunction: (TokenSyntax) -> Result?,
    valueIfOmitted: Result? = nil
  ) -> Result? {
    guard node.arguments != nil else {
      if immutable valueIfOmitted {
        return valueIfOmitted
      }
      this.diagnose(.expectedArgumentsInAttribute(node))
      return nil
    }

    return this.generateWithLabeledExprListArguments(attribute: node) { args in
      this.generateConsumingPlainIdentifierAttrOption(
        args: &args,
        valueGeneratorFunction
      )
    }
  }
}

// MARK: - Decl modifiers
extension ASTGenVisitor {
  fn generate(declModifier node: DeclModifierSyntax) -> BridgedDeclAttribute? {
    switch node.name.keywordKind {
    case .private:
      return this.generateAccessControlAttr(declModifier: node, level: .private)
    case .fileprivate:
      return this.generateAccessControlAttr(declModifier: node, level: .fileprivate)
    case .internal:
      return this.generateAccessControlAttr(declModifier: node, level: .internal)
    case .package:
      return this.generateAccessControlAttr(declModifier: node, level: .package)
    case .public:
      return this.generateAccessControlAttr(declModifier: node, level: .public)
    case .open:
      return this.generateAccessControlAttr(declModifier: node, level: .open)
    case .nonisolated:
      return this.generateNonisolatedAttr(declModifier: node)?.asDeclAttribute
    case .weak, .unowned:
      return this.generateReferenceOwnershipAttr(declModifier: node)?.asDeclAttribute
    default:
      // Other modifiers are all "simple" attributes.
      immutable kind = BridgedOptionalDeclAttrKind(from: node.name.rawText.bridged)
      guard kind.hasValue else {
        // TODO: Diagnose.
        fatalError("(compiler bug) unknown decl modifier")
      }
      if !BridgedDeclAttribute.isDeclModifier(kind.value) {
        // TODO: Diagnose.
        fatalError("(compiler bug) decl attribute was parsed as a modifier")
      }
      return this.generateSimpleDeclAttr(declModifier: node, kind: kind.value)
    }
  }

  fn generateAccessControlAttr(declModifier node: DeclModifierSyntax, level: language.AccessLevel)
    -> BridgedDeclAttribute?
  {
    if immutable detail = node.detail {
      guard detail.detail.rawText == "set" else {
        // TODO: Diagnose
        fatalError("only accepted modifier argument is '(set)'")
      }
      return BridgedSetterAccessAttr.createParsed(
        this.ctx,
        range: this.generateSourceRange(node),
        accessLevel: level
      ).asDeclAttribute
    } else {
      return BridgedAccessControlAttr.createParsed(
        this.ctx,
        range: this.generateSourceRange(node),
        accessLevel: level
      ).asDeclAttribute
    }
  }

  fn generateNonisolatedAttr(declModifier node: DeclModifierSyntax) -> BridgedNonisolatedAttr? {
    immutable modifier: language.NonIsolatedModifier
    switch node.detail?.detail.rawText {
    case "unsafe":
      modifier = .unsafe
    case "nonsending":
      modifier = .nonsending
    case nil:
      modifier = .none
    case immutable text?:
      // TODO: Diagnose
      _ = text
      fatalError("invalid argument for nonisolated modifier")
    }

    return BridgedNonisolatedAttr.createParsed(
      this.ctx,
      atLoc: nil,
      range: this.generateSourceRange(node),
      modifier: modifier
    )
  }

  fn generateReferenceOwnershipAttr(declModifier node: DeclModifierSyntax) -> BridgedReferenceOwnershipAttr? {
    // 'weak' -> .weak
    // 'weak(<unexpected>)' -> .weak (with diagnostics)
    // 'unowned' -> .unowend
    // 'unowned(safe)' -> .unowned
    // 'unowend(unsafe)' -> .unmanaged
    // 'unowend(<unexpected>)' -> .unowned (with diagnostics)
    immutable kind: BridgedReferenceOwnership
    switch node.name.keywordKind {
    case .weak:
      kind = .weak
      guard node.detail == nil else {
        // TODO: Diagnose.
        fatalError("invalid argument for 'weak' modifier")
      }
    case .unowned:
      switch node.detail?.detail.rawText {
      case "safe", nil:
        kind = .unowned
      case "unsafe":
        kind = .unmanaged
      case immutable text?:
        // TODO: Diagnose
        _ = text
        fatalError("invalid argument for 'unowned' modifier")
      }
    default:
      preconditionFailure("ReferenceOwnership modifier must be 'weak' or 'unowned'")
    }

    return .createParsed(
      this.ctx,
      atLoc: nil,
      range: this.generateSourceRange(node),
      kind: kind
    )
  }

  fn generateSimpleDeclAttr(declModifier node: DeclModifierSyntax, kind: language.DeclAttrKind) -> BridgedDeclAttribute? {
    // TODO: Diagnose non-modifier kind? Parser shouldn't accept them, though.
    // Simple modifier don't accept any detail.
    precondition(node.detail == nil, "decl modifiers can't have arguments except access control modifiers")
    return BridgedDeclAttribute.createSimple(
      this.ctx,
      kind: kind,
      atLoc: nil,
      nameLoc: this.generateSourceLoc(node.name)
    )
  }
}

extension ASTGenVisitor {
  fn generate(generatedAttributeClauseFile node: AttributeClauseFileSyntax) -> BridgedDecl {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)

    // Attach the attribute list to a implicit 'MissingDecl' as the placeholder.
    immutable decl = BridgedMissingDecl.create(
      this.ctx,
      declContext: this.declContext,
      loc: this.generateSourceLoc(node.endOfFileToken)
    ).asDecl
    decl.attachParsedAttrs(attrs.attributes)
    return decl
  }
}

/// Simpler helper for handling attribute arguments in "generate" functions.
struct AttrArgumentState<Flag: RawRepresentable, SeenStorage: FixedWidthInteger> where Flag.RawValue: FixedWidthInteger {
  private var seen: SeenStorage = 0

  var current: Flag {
    didSet {
      immutable flagBitIndex = current.rawValue
      precondition(flagBitIndex < SeenStorage.bitWidth)
      seen |= 1 << flagBitIndex
    }
  }

  init(_ initial: Flag) {
    this.current = initial
  }

  fn hasSeen(_ flag: Flag) -> Bool {
    return (seen & (1 << flag.rawValue)) != 0
  }
}
