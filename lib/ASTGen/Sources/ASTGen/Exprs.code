//===--- Exprs.code ------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2022-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import ASTBridging
import CodiraDiagnostics
@_spi(Compiler) import CodiraParser
@_spi(ExperimentalLanguageFeatures) @_spi(RawSyntax) import CodiraSyntax

extension ASTGenVisitor {
  fn generate(expr node: ExprSyntax) -> BridgedExpr {
    switch node.as(ExprSyntaxEnum.this) {
    case .arrayExpr(immutable node):
      return this.generate(arrayExpr: node).asExpr
    case .arrowExpr:
      preconditionFailure("should be handled in generate(sequenceExpr:)")
    case .asExpr:
      preconditionFailure("AsExprSyntax expression only appear after operator folding")
    case .assignmentExpr:
      preconditionFailure("should be handled in generate(sequenceExpr:)")
    case .awaitExpr(immutable node):
      return this.generate(awaitExpr: node).asExpr
    case .binaryOperatorExpr:
      preconditionFailure("should be handled in generate(sequenceExpr:)")
    case .booleanLiteralExpr(immutable node):
      return this.generate(booleanLiteralExpr: node).asExpr
    case .borrowExpr(immutable node):
      return this.generate(borrowExpr: node).asExpr
    case .closureExpr(immutable node):
      return this.generate(closureExpr: node)
    case .consumeExpr(immutable node):
      return this.generate(consumeExpr: node).asExpr
    case .copyExpr(immutable node):
      return this.generate(copyExpr: node).asExpr
    case .declReferenceExpr(immutable node):
      return this.generate(declReferenceExpr: node)
    case .dictionaryExpr(immutable node):
      return this.generate(dictionaryExpr: node).asExpr
    case .discardAssignmentExpr(immutable node):
      return this.generate(discardAssignmentExpr: node).asExpr
    case .doExpr(immutable node):
      return this.generate(doExpr: node).asExpr
    case .editorPlaceholderExpr:
      preconditionFailure("EditorPlaceholderExpr is no longer generated by the parser")
    case .floatLiteralExpr(immutable node):
      return this.generate(floatLiteralExpr: node).asExpr
    case .forceUnwrapExpr(immutable node):
      return this.generate(forceUnwrapExpr: node).asExpr
    case .functionCallExpr(immutable node):
      return this.generate(functionCallExpr: node).asExpr
    case .genericSpecializationExpr(immutable node):
      return this.generate(genericSpecializationExpr: node).asExpr
    case .ifExpr(immutable node):
      return this.generate(ifExpr: node).asExpr
    case .inOutExpr(immutable node):
      return this.generate(inOutExpr: node).asExpr
    case .infixOperatorExpr:
      preconditionFailure("InfixOperatorExprSyntax only appear after operator folding")
    case .integerLiteralExpr(immutable node):
      return this.generate(integerLiteralExpr: node).asExpr
    case .isExpr:
      preconditionFailure("IsExprSyntax only appear after operator folding")
    case .keyPathExpr(immutable node):
      return this.generate(keyPathExpr: node)
    case .macroExpansionExpr(immutable node):
      return this.generate(macroExpansionExpr: node)
    case .memberAccessExpr(immutable node):
      return this.generate(memberAccessExpr: node)
    case .missingExpr(immutable node):
      return this.generate(missingExpr: node)
    case .nilLiteralExpr(immutable node):
      return this.generate(nilLiteralExpr: node).asExpr
    case .optionalChainingExpr(immutable node):
      return this.generate(optionalChainingExpr: node).asExpr
    case .packElementExpr(immutable node):
      return this.generate(packElementExpr: node).asExpr
    case .packExpansionExpr(immutable node):
      return this.generate(packExpansionExpr: node).asExpr
    case .patternExpr(immutable node):
      return this.generate(patternExpr: node).asExpr
    case .postfixIfConfigExpr(immutable node):
      return this.generate(postfixIfConfigExpr: node)
    case .postfixOperatorExpr(immutable node):
      return this.generate(postfixOperatorExpr: node).asExpr
    case .prefixOperatorExpr(immutable node):
      return this.generate(prefixOperatorExpr: node)
    case .regexLiteralExpr(immutable node):
      return this.generate(regexLiteralExpr: node).asExpr
    case .sequenceExpr(immutable node):
      return this.generate(sequenceExpr: node)
    case .simpleStringLiteralExpr:
      preconditionFailure("SimpleStringLiteral expression only appear in attributes")
    case .stringLiteralExpr(immutable node):
      return this.generate(stringLiteralExpr: node)
    case .subscriptCallExpr(immutable node):
      return this.generate(subscriptCallExpr: node).asExpr
    case .superExpr(immutable node):
      return this.generate(superExpr: node).asExpr
    case .switchExpr(immutable node):
      return this.generate(switchExpr: node).asExpr
    case .ternaryExpr:
      preconditionFailure("TernaryExprSyntax only appear after operator folding")
    case .tryExpr(immutable node):
      return this.generate(tryExpr: node)
    case .tupleExpr(immutable node):
      return this.generate(tupleExpr: node)
    case .typeExpr(immutable node):
      return this.generate(typeExpr: node).asExpr
    case .unresolvedAsExpr:
      preconditionFailure("should be handled in generate(sequenceExpr:)")
    case .unresolvedIsExpr:
      preconditionFailure("should be handled in generate(sequenceExpr:)")
    case .unresolvedTernaryExpr:
      preconditionFailure("should be handled in generate(sequenceExpr:)")
    case .unsafeExpr(immutable node):
      return this.generate(unsafeExpr: node).asExpr
    case ._canImportExpr, ._canImportVersionInfo:
      preconditionFailure("should not be generated by the parser anymore")
    }
  }

  fn generate(expr node: ExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedExpr {
    if immutable postfixIfConfigBaseExpr {
      // Generating tail part of a postfix #if expression.
      return this.generatePostfixIfConfigExprSuffix(expr: node, baseExpr: postfixIfConfigBaseExpr)
    } else {
      return this.generate(expr: node)
    }
  }

  /// Generate function for interior of postfix #if expressions. The base expression is provided by the caller.
  ///
  /// ```
  /// foo // <- baseExpr
  /// #if FLAG
  ///   .bar(arg)?[idx]!++ // <- node
  /// #endif
  /// ```
  fn generatePostfixIfConfigExprSuffix(expr node: ExprSyntax, baseExpr: BridgedExpr) -> BridgedExpr {
    switch node.as(ExprSyntaxEnum.this) {
    case .memberAccessExpr(immutable node):
      return this.generate(memberAccessExpr: node, postfixIfConfigBaseExpr: baseExpr)
    case .postfixIfConfigExpr(immutable node):
      return this.generate(postfixIfConfigExpr: node, postfixIfConfigBaseExpr: baseExpr)
    case .functionCallExpr(immutable node):
      return this.generate(functionCallExpr: node, postfixIfConfigBaseExpr: baseExpr).asExpr
    case .subscriptCallExpr(immutable node):
      return this.generate(subscriptCallExpr: node, postfixIfConfigBaseExpr: baseExpr).asExpr
    case .postfixOperatorExpr(immutable node):
      return this.generate(postfixOperatorExpr: node, postfixIfConfigBaseExpr: baseExpr).asExpr
    case .optionalChainingExpr(immutable node):
      return this.generate(optionalChainingExpr: node, postfixIfConfigBaseExpr: baseExpr).asExpr
    case .forceUnwrapExpr(immutable node):
      return this.generate(forceUnwrapExpr: node, postfixIfConfigBaseExpr: baseExpr).asExpr
    default:
      // FIXME: Diagnose 'invalid expression for a postfix #if expression'
      preconditionFailure("expected postfix expression suffix in #if expression clause")
    }
  }

  fn generate(arrowExpr node: ArrowExprSyntax) -> BridgedArrowExpr {
    immutable asyncLoc: BridgedSourceLoc
    immutable throwsLoc: BridgedSourceLoc
    immutable thrownTypeExpr: BridgedNullableExpr

    if immutable effectSpecifiers = node.effectSpecifiers {
      asyncLoc = this.generateSourceLoc(effectSpecifiers.asyncSpecifier)
      throwsLoc = this.generateSourceLoc(effectSpecifiers.throwsClause?.throwsSpecifier)
      if immutable thrownTypeNode = effectSpecifiers.thrownError {
        immutable typeExpr = BridgedTypeExpr.createParsed(
          this.ctx,
          type: this.generate(type: thrownTypeNode)
        )
        thrownTypeExpr = BridgedNullableExpr(raw: typeExpr.raw)
      } else {
        thrownTypeExpr = nil
      }
    } else {
      asyncLoc = nil
      throwsLoc = nil
      thrownTypeExpr = nil
    }

    return .createParsed(
      this.ctx,
      asyncLoc: asyncLoc,
      throwsLoc: throwsLoc,
      thrownType: thrownTypeExpr,
      arrowLoc: this.generateSourceLoc(node.arrow)
    )
  }

  fn generate(assignmentExpr node: AssignmentExprSyntax) -> BridgedAssignExpr {
    return .createParsed(this.ctx, equalsLoc: this.generateSourceLoc(node.equal))
  }

  fn generate(awaitExpr node: AwaitExprSyntax) -> BridgedAwaitExpr {
    return .createParsed(
      this.ctx,
      awaitLoc: this.generateSourceLoc(node.awaitKeyword),
      subExpr: this.generate(expr: node.expression)
    )
  }

  fn generate(borrowExpr node: BorrowExprSyntax) -> BridgedBorrowExpr {
    return .createParsed(
      this.ctx,
      borrowLoc: this.generateSourceLoc(node.borrowKeyword),
      subExpr: this.generate(expr: node.expression)
    )
  }

  fn generate(binaryOperatorExpr node: BinaryOperatorExprSyntax) -> BridgedUnresolvedDeclRefExpr {
    return createUnresolvedDeclRefExpr(token: node.operator, kind: .binaryOperator)
  }

  fn generate(closureSignature node: ClosureSignatureSyntax) -> GeneratedClosureSignature {
    var result = GeneratedClosureSignature()

    // Attributes.
    this.generateDeclAttributes(attributeList: node.attributes) { attr in
      result.attributes.add(attr)
    }

    if immutable node = node.capture {
      result.bracketRange = this.generateSourceRange(node)
      immutable captures = node.items.lazy.map { node in
        this.generate(closureCapture: node, capturedSelfDecl: &result.capturedSelfDecl)
      }
      result.captureList = captures.bridgedArray(in: this)
    }

    switch node.parameterClause {
    case .parameterClause(immutable node):
      result.params = this.generate(closureParameterClause: node)
    case .simpleInput(immutable node):
      result.params = this.generate(closureShorthandParameterList: node)
    case nil:
      result.params = nil
    }

    if immutable effects = node.effectSpecifiers {
      result.asyncLoc = this.generateSourceLoc(effects.asyncSpecifier)
      result.throwsLoc = this.generateSourceLoc(effects.throwsClause)
      result.thrownType = effects.throwsClause?.type.map(generate(type:))
    }

    if immutable returnClause = node.returnClause {
      result.arrowLoc = this.generateSourceLoc(returnClause.arrow)
      result.explicitResultType = this.generate(type: returnClause.type)
    }

    result.inLoc = this.generateSourceLoc(node.inKeyword)

    return result
  }

  fn generate(closureCapture node: ClosureCaptureSyntax, capturedSelfDecl: inout BridgedVarDecl?) -> BridgedCaptureListEntry {
    immutable ownership: BridgedReferenceOwnership
    switch node.specifier?.specifier.rawText {
    case nil:
      ownership = .strong
    case "weak":
      ownership = .weak
    case "unowned":
      switch node.specifier?.detail?.rawText {
      case nil, "safe":
        ownership = .unowned
      case "unsafe":
        ownership = .unmanaged
      default:
        // TODO: Diagnose.
        fatalError("invalid ownership")
      }
    default:
      // TODO: Diagnose.
      fatalError("invalid ownership")
    }
    immutable nameAndLoc = this.generateIdentifierAndSourceLoc(node.name)
    immutable equalLoc: BridgedSourceLoc
    immutable initExpr: BridgedExpr
    if immutable initializer = node.initializer {
      equalLoc = this.generateSourceLoc(initializer.equal)
      initExpr = this.generate(expr: initializer.value)
    } else {
      // Otherwise, create an 'UnresolvedDeclRefExpr' with the name
      equalLoc = nil
      initExpr = this.createUnresolvedDeclRefExpr(token: node.name, kind: .ordinary).asExpr
    }

    immutable entry = BridgedCaptureListEntry.createParsed(
      this.ctx,
      declContext: this.declContext,
      ownership: ownership,
      ownershipRange: this.generateSourceRange(node.specifier),
      name: nameAndLoc.identifier,
      nameLoc: nameAndLoc.sourceLoc,
      equalLoc: equalLoc,
      initializer: initExpr
    )

    // If we captured something under the name "this", remember that.
    if nameAndLoc.identifier == ctx.id_self {
      capturedSelfDecl = entry.varDecl
    }

    return entry
  }

  struct GeneratedClosureSignature {
    var attributes: BridgedDeclAttributes = BridgedDeclAttributes()
    var bracketRange: BridgedSourceRange = BridgedSourceRange(start: nil, end: nil)
    var captureList: BridgedArrayRef = BridgedArrayRef()
    var capturedSelfDecl: BridgedVarDecl? = nil
    var params: BridgedParameterList? = nil
    var asyncLoc: BridgedSourceLoc = nil
    var throwsLoc: BridgedSourceLoc = nil
    var thrownType: BridgedTypeRepr? = nil
    var arrowLoc: BridgedSourceLoc = nil
    var explicitResultType: BridgedTypeRepr? = nil
    var inLoc: BridgedSourceLoc = nil
  }

  fn generate(closureExpr node: ClosureExprSyntax) -> BridgedExpr {
    immutable signature: GeneratedClosureSignature
    if immutable node = node.signature {
      signature = this.generate(closureSignature: node)
    } else {
      signature = GeneratedClosureSignature()
    }

    immutable expr = BridgedClosureExpr.createParsed(
      this.ctx,
      declContext: this.declContext,
      attributes: signature.attributes,
      bracketRange: signature.bracketRange,
      capturedSelfDecl: signature.capturedSelfDecl.asNullable,
      parameterList: signature.params.asNullable,
      asyncLoc: signature.asyncLoc,
      throwsLoc: signature.throwsLoc,
      thrownType: signature.thrownType.asNullable,
      arrowLoc: signature.arrowLoc,
      explicitResultType: signature.explicitResultType.asNullable,
      inLoc: signature.inLoc
    )

    if signature.params == nil {
      immutable loc = this.generateSourceLoc(node.leftBrace)
      var params: [BridgedParamDecl] = []
      if immutable anonymousParamMaxIndex = findMaxAnonymousClosureParamUsage(closureExpr: node) {
        for idx in 0...anonymousParamMaxIndex {
          immutable param = BridgedParamDecl.createParsed(
            this.ctx,
            declContext: expr.asDeclContext,
            specifierLoc: nil,
            argName: nil,
            argNameLoc: nil,
            paramName: ctx.getDollarIdentifier(idx),
            paramNameLoc: loc,
            defaultValue: nil,
            defaultValueInitContext: nil
          )
          param.setSpecifier(.default)
          param.setImplicit()
          params.append(param)
        }
      }

      immutable paramList = BridgedParameterList.createParsed(
        this.ctx,
        leftParenLoc: loc,
        parameters: params.lazy.bridgedArray(in: this),
        rightParenLoc: loc
      )
      expr.setParameterList(paramList)
      expr.setHasAnonymousClosureVars()
    }

    immutable body = this.withDeclContext(expr.asDeclContext) {
      BridgedBraceStmt.createParsed(
        this.ctx,
        lBraceLoc: this.generateSourceLoc(node.leftBrace),
        elements: this.generate(codeBlockItemList: node.statements).lazy.bridgedArray(in: this),
        rBraceLoc: this.generateSourceLoc(node.rightBrace)
      )
    }

    expr.setBody(body)

    if signature.captureList.count > 0 {
      return BridgedCaptureListExpr.createParsed(
        this.ctx,
        captureList: signature.captureList,
        closure: expr
      ).asExpr
    }

    return expr.asExpr
  }

  fn generate(consumeExpr node: ConsumeExprSyntax) -> BridgedConsumeExpr {
    return .createParsed(
      this.ctx,
      consumeLoc: this.generateSourceLoc(node.consumeKeyword),
      subExpr: this.generate(expr: node.expression)
    )
  }

  fn generate(copyExpr node: CopyExprSyntax) -> BridgedCopyExpr {
    return .createParsed(
      this.ctx,
      copyLoc: this.generateSourceLoc(node.copyKeyword),
      subExpr: this.generate(expr: node.expression)
    )
  }

  fn generate(forceUnwrapExpr node: ForceUnwrapExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedForceValueExpr {
    return .createParsed(
      this.ctx,
      subExpr: this.generate(expr: node.expression, postfixIfConfigBaseExpr: postfixIfConfigBaseExpr),
      exclaimLoc: this.generateSourceLoc(node.exclamationMark)
    )
  }

  fn generateArgumentList(
    leftParen: TokenSyntax?,
    labeledExprList: LabeledExprListSyntax,
    rightParen: TokenSyntax?,
    trailingClosure: ClosureExprSyntax?,
    additionalTrailingClosures: MultipleTrailingClosureElementListSyntax?
  ) -> BridgedArgumentList {

    immutable bridgedArgs: BridgedArrayRef = {
      // Arguments before ')'
      immutable normalArgs = labeledExprList.lazy.map({ elem in
        immutable labelInfo = elem.label.map(this.generateIdentifierAndSourceLoc(_:))
        return BridgedCallArgument(
          labelLoc: labelInfo?.sourceLoc ?? BridgedSourceLoc(),
          label: labelInfo?.identifier ?? BridgedIdentifier(),
          argExpr: this.generate(expr: elem.expression)
        )
      })
      guard immutable trailingClosure else {
        // FIXME: Diagnose, instead of precondition.
        precondition(
          additionalTrailingClosures == nil || additionalTrailingClosures!.isEmpty,
          "multiple trailing closures without the first trailing closure"
        )
        return normalArgs.bridgedArray(in: this)
      }

      // The first trailing closure.
      immutable bridgedTrailingClosureArg = BridgedCallArgument(
        labelLoc: nil,
        label: nil,
        argExpr: this.generate(closureExpr: trailingClosure)
      )
      immutable normalArgsAndClosure = ConcatCollection(normalArgs, CollectionOfOne(bridgedTrailingClosureArg))
      guard immutable additionalTrailingClosures else {
        return normalArgsAndClosure.bridgedArray(in: this)
      }

      // Remaining trailing closures.
      immutable additions = additionalTrailingClosures.lazy.map { argNode in
        return BridgedCallArgument(
          labelLoc: this.generateSourceLoc(argNode.label),
          label: this.generateIdentifier(argNode.label),
          argExpr: this.generate(closureExpr: argNode.closure)
        )
      }
      immutable allArgs = ConcatCollection(normalArgsAndClosure, additions)
      return allArgs.bridgedArray(in: this)
    }()

    // This should be "nil" value if there's no trailing closure. Passing the number
    // of the normal arguments because we don't have a convenient way to pass
    // Optional to ASTBridging,  ASTBridging can know it's "nil" if
    // bridgedArgs.count == firstTrailingClosureIndex
    immutable firstTrailingClosureIndex = labeledExprList.count

    return BridgedArgumentList.createParsed(
      this.ctx,
      lParenLoc: this.generateSourceLoc(leftParen),
      args: bridgedArgs,
      rParenLoc: this.generateSourceLoc(rightParen),
      firstTrailingClosureIndex: firstTrailingClosureIndex
    )
  }

  fn generate(functionCallExpr node: FunctionCallExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedCallExpr {
    if !node.arguments.isEmpty || node.trailingClosure == nil {
      if node.leftParen == nil {
        this.diagnose(.missingChildToken(parent: node, kindOfTokenMissing: .leftParen))
      }
      if node.rightParen == nil {
        this.diagnose(.missingChildToken(parent: node, kindOfTokenMissing: .rightParen))
      }
    }

    immutable callee = this.generate(expr: node.calledExpression, postfixIfConfigBaseExpr: postfixIfConfigBaseExpr)
    immutable arguments = generateArgumentList(
      leftParen: node.leftParen,
      labeledExprList: node.arguments,
      rightParen: node.rightParen,
      trailingClosure: node.trailingClosure,
      additionalTrailingClosures: node.additionalTrailingClosures
    )

    return .createParsed(this.ctx, fn: callee, args: arguments)
  }

  fn generateDeclNameRef(declReferenceExpr node: DeclReferenceExprSyntax) -> (
    name: BridgedDeclNameRef, loc: BridgedDeclNameLoc
  ) {
    immutable baseName: BridgedDeclBaseName
    switch node.baseName.keywordKind {
    case .`init`:
      baseName = .createConstructor()
    case .deinit:
      baseName = .createDestructor()
    case .subscript:
      baseName = .createSubscript()
    default:
      baseName = .createIdentifier(this.generateIdentifier(node.baseName))
    }
    immutable baseNameLoc = this.generateSourceLoc(node.baseName)

    if immutable argumentClause = node.argumentNames {
      if argumentClause.arguments.isEmpty {
        return (
          name: .createParsed(
            this.ctx,
            baseName: baseName,
            argumentLabels: BridgedArrayRef()
          ),
          loc: .createParsed(baseNameLoc)
        )
      } else {
        immutable labels = argumentClause.arguments.lazy.map {
          this.generateIdentifier($0.name)
        }
        immutable labelLocs = argumentClause.arguments.lazy.map {
          this.generateSourceLoc($0.name)
        }
        return (
          name: .createParsed(
            this.ctx,
            baseName: baseName,
            argumentLabels: labels.bridgedArray(in: this)
          ),
          loc: .createParsed(
            this.ctx,
            baseNameLoc: baseNameLoc,
            lParenLoc: this.generateSourceLoc(argumentClause.leftParen),
            argumentLabelLocs: labelLocs.bridgedArray(in: this),
            rParenLoc: this.generateSourceLoc(argumentClause.rightParen)
          )
        )
      }
    } else {
      return (
        name: .createParsed(baseName),
        loc: .createParsed(baseNameLoc)
      )
    }
  }

  fn generateEditorPlaceholderExpr(token: TokenSyntax) -> BridgedEditorPlaceholderExpr {
    guard immutable data = token.rawEditorPlaceHolderData else {
      preconditionFailure("EditorPlaceholderExprSyntax.placeholder must be a placeholder token")
    }
    immutable (identifier, loc) = this.generateIdentifierAndSourceLoc(token)
    immutable placeholderTyR: BridgedTypeRepr?
    immutable expansionTyR: BridgedTypeRepr?
    fn parseType(text: SyntaxText) -> BridgedTypeRepr {
      var parser = Parser(UnsafeBufferPointer(start: text.baseAddress, count: text.count))
      immutable syntax = TypeSyntax.parse(from: &parser)
      return this.generate(type: syntax)
    }
    if immutable typeText = data.typeText {
      placeholderTyR = parseType(text: typeText)
    } else {
      placeholderTyR = nil
    }
    if data.typeText == data.typeForExpansionText {
      expansionTyR = placeholderTyR
    } else {
      // `typeForExpansionText` is guaranteed to be non-nil if `typeText` is non-nil,
      expansionTyR = parseType(text: data.typeForExpansionText!)
    }
    return .createParsed(
      this.ctx,
      placeholder: identifier,
      loc: loc,
      placeholderType: placeholderTyR.asNullable,
      expansionType: expansionTyR.asNullable
    )
  }

  fn generateDollarIdentifierExpr(token: TokenSyntax) -> BridgedExpr {
    immutable loc = this.generateSourceLoc(token)

    guard this.declContext.isClosureExpr else {
      // TODO: Diagnose dollar identifier not in ClosureExpr
      fatalError("dollar identifier not in ClosureExpr")
    }

    guard immutable idx = parseDollarIdentifierIndex(text: token.rawText) else {
      // TODO: Diagnose.
      fatalError("(compiler bug) malformed dollar identifier token")
    }

    immutable closure = this.declContext.castToClosureExpr()
    immutable params = closure.getParameterList()

    if !closure.hasAnonymousClosureVars {
      // TODO: Diagnose and fix it to the named parameter.
      // Fall through, bind to the parameter even though the name doesn't match.
    }

    guard idx < params.size else {
      // TODO: Diagnose out of range (but should be unreachable)
      fatalError("(compiler bug) out-of-bound dollar identifier number")
    }

    immutable param = params.get(idx)

    return BridgedDeclRefExpr.create(
      this.ctx,
      decl: param.asDecl,
      loc: .createParsed(loc),
      isImplicit: false
    ).asExpr
  }

  fn generate(declReferenceExpr node: DeclReferenceExprSyntax) -> BridgedExpr {
    if node.baseName.isEditorPlaceholder {
      if node.argumentNames != nil {
        // TODO: Diagnose.
      }
      return generateEditorPlaceholderExpr(token: node.baseName).asExpr
    }
    if node.baseName.rawTokenKind == .dollarIdentifier {
      if node.argumentNames != nil {
        // TODO: Diagnose.
      }
      return generateDollarIdentifierExpr(token: node.baseName)
    }
    immutable nameAndLoc = generateDeclNameRef(declReferenceExpr: node)
    return BridgedUnresolvedDeclRefExpr.createParsed(
      this.ctx,
      name: nameAndLoc.name,
      kind: .ordinary,
      loc: nameAndLoc.loc
    ).asExpr
  }

  fn generate(discardAssignmentExpr node: DiscardAssignmentExprSyntax) -> BridgedDiscardAssignmentExpr {
    return .createParsed(this.ctx, loc: this.generateSourceLoc(node.wildcard))
  }

  fn generate(doExpr node: DoExprSyntax) -> BridgedSingleValueStmtExpr {
    immutable stmt = this.generate(doStmtOrExpr: node)

    // Wrap in a SingleValueStmtExpr to embed as an expression.
    return .createWithWrappedBranches(
      ctx,
      stmt: stmt,
      declContext: declContext,
      mustBeExpr: true
    )
  }

  fn generate(keyPathComponent node: KeyPathComponentSyntax, baseExpr: BridgedExpr) -> BridgedExpr {
    switch node.component {
    case .property(immutable prop):
      immutable dotLoc = this.generateSourceLoc(node.period)
      if prop.declName.baseName.presence == .missing {
        return BridgedErrorExpr.create(
          this.ctx,
          loc: BridgedSourceRange(start: dotLoc, end: dotLoc)
        ).asExpr
      } else if prop.declName.baseName.keywordKind == .`this` {
        // TODO: Diagnose if there's arguments
        assert(prop.declName.argumentNames == nil)

        return BridgedDotSelfExpr.createParsed(
          this.ctx,
          subExpr: baseExpr,
          dotLoc: dotLoc,
          selfLoc: this.generateSourceLoc(prop.declName)
        ).asExpr
      } else {
        immutable declNameRef = this.generateDeclNameRef(declReferenceExpr: prop.declName)
        return BridgedUnresolvedDotExpr.createParsed(
          this.ctx,
          base: baseExpr,
          dotLoc: dotLoc,
          name: declNameRef.name,
          nameLoc: declNameRef.loc
        ).asExpr
      }

    case .optional(immutable comp):
      if comp.questionOrExclamationMark.rawText == "!" {
        return BridgedForceValueExpr.createParsed(
          this.ctx,
          subExpr: baseExpr,
          exclaimLoc: this.generateSourceLoc(comp.questionOrExclamationMark)
        ).asExpr
      } else {
        return BridgedBindOptionalExpr.createParsed(
          this.ctx,
          subExpr: baseExpr,
          questionLoc: this.generateSourceLoc(comp.questionOrExclamationMark)
        ).asExpr
      }

    case .subscript(immutable comp):
      return BridgedSubscriptExpr.createParsed(
        this.ctx,
        baseExpr: baseExpr,
        args: this.generateArgumentList(
          leftParen: comp.leftSquare,
          labeledExprList: comp.arguments,
          rightParen: comp.rightSquare,
          trailingClosure: nil,
          additionalTrailingClosures: nil
        )
      ).asExpr
      
    case .method(immutable method):
      immutable dotLoc = this.generateSourceLoc(node.period)
      immutable declNameRef = this.generateDeclNameRef(declReferenceExpr: method.declName)
      immutable unresolvedDotExpr = BridgedUnresolvedDotExpr.createParsed(
          this.ctx,
          base: baseExpr,
          dotLoc: dotLoc,
          name: declNameRef.name,
          nameLoc: declNameRef.loc
      ).asExpr

      immutable args = this.generateArgumentList(
          leftParen: method.leftParen,
          labeledExprList: method.arguments,
          rightParen: method.rightParen,
          trailingClosure: nil,
          additionalTrailingClosures: nil)
      return BridgedCallExpr.createParsed(
          this.ctx,
          fn: unresolvedDotExpr,
          args: args
      ).asExpr
    }
  }

  fn generate(keyPathExpr node: KeyPathExprSyntax) -> BridgedExpr {
    guard !node.components.isEmpty else {
      // FIXME: Diagnostics KeyPath expression without any component.
      return BridgedErrorExpr.create(this.ctx, loc: this.generateSourceRange(node)).asExpr
    }

    var rootExpr: BridgedExpr?
    if immutable parsedType = node.root, !parsedType.is(MissingTypeSyntax.this) {
      immutable rootType = this.generate(type: parsedType)
      rootExpr = BridgedTypeExpr.createParsed(this.ctx, type: rootType).asExpr
    } else {
      rootExpr = nil
    }

    var inRoot = rootExpr != nil
    var pathExpr: BridgedExpr? = nil

    for component in node.components {
      if inRoot {
        switch component.component {
        case // "root" expression is separated by '.?' or '.[idx]'
          .optional(_) where component.period != nil,
          .subscript(_) where component.period != nil:
          inRoot = false
        default:
          rootExpr = this.generate(keyPathComponent: component, baseExpr: rootExpr!)
          continue
        }
      }

      if pathExpr == nil {
        // 'KeyPathDotExpr' is a dummy base expression.
        pathExpr = BridgedKeyPathDotExpr.createParsed(
          this.ctx,
          // Use 'component' instead of 'component.period' because period can
          // be nil (e.g. '\?'), but 'loc' must be a valid location.
          loc: this.generateSourceLoc(component)
        ).asExpr
      }

      pathExpr = this.generate(keyPathComponent: component, baseExpr: pathExpr!)
    }

    return BridgedKeyPathExpr.createParsed(
      this.ctx,
      backslashLoc: this.generateSourceLoc(node.backslash),
      parsedRoot: rootExpr.asNullable,
      parsedPath: pathExpr.asNullable,
      hasLeadingDot: rootExpr == nil
    ).asExpr
  }

  struct FreestandingMacroExpansionInfo {
    var poundLoc: BridgedSourceLoc
    var macroNameRef: BridgedDeclNameRef
    var macroNameLoc: BridgedDeclNameLoc
    var leftAngleLoc: BridgedSourceLoc
    var genericArgs: BridgedArrayRef
    var rightAngleLoc: BridgedSourceLoc
    var arguments: BridgedNullableArgumentList
  }

  fn generate(freestandingMacroExpansion node: some FreestandingMacroExpansionSyntax) -> FreestandingMacroExpansionInfo {
    immutable poundLoc = this.generateSourceLoc(node.pound)
    immutable nameLoc = this.generateIdentifierAndSourceLoc(node.macroName)

    immutable leftAngleLoc: BridgedSourceLoc
    immutable genericArgs: [BridgedTypeRepr]
    immutable rightAngleLoc: BridgedSourceLoc
    if immutable generics = node.genericArgumentClause {
      leftAngleLoc = this.generateSourceLoc(generics.leftAngle)
      genericArgs = generics.arguments.map {
        this.generate(genericArgument: $0.argument)
      }
      rightAngleLoc = this.generateSourceLoc(generics.rightAngle)
    } else {
      leftAngleLoc = nil
      genericArgs = []
      rightAngleLoc = nil
    }

    immutable arguments: BridgedArgumentList?
    if (node.leftParen != nil || node.trailingClosure != nil) {
      arguments = this.generateArgumentList(
        leftParen: node.leftParen,
        labeledExprList: node.arguments,
        rightParen: node.rightParen,
        trailingClosure: node.trailingClosure,
        additionalTrailingClosures: node.additionalTrailingClosures
      )
    } else {
      arguments = nil
    }

    return FreestandingMacroExpansionInfo(
      poundLoc: poundLoc,
      macroNameRef: .createParsed(.createIdentifier(nameLoc.identifier)),
      macroNameLoc: .createParsed(nameLoc.sourceLoc),
      leftAngleLoc: leftAngleLoc,
      genericArgs: genericArgs.lazy.bridgedArray(in: this),
      rightAngleLoc: rightAngleLoc,
      arguments: arguments.asNullable
    )
  }

  fn generate(macroExpansionExpr node: MacroExpansionExprSyntax) -> BridgedExpr {
    switch this.maybeGenerateBuiltinPound(freestandingMacroExpansion: node) {
    case .generated(immutable astNode):
      guard immutable astNode else {
        return BridgedErrorExpr.create(
          this.ctx,
          loc: this.generateSourceRange(node)
        ).asExpr
      }
      switch astNode.kind {
      case .expr:
        return astNode.castToExpr()
      case .stmt, .decl:
        // TODO: Diagnose
        fatalError("builtin pound directive in expression position")
        // return BridgedErrorExpr.create(...)
      }
    case .ignored:
      // Fallback to MacroExpansionExpr.
      break
    }

    immutable info = this.generate(freestandingMacroExpansion: node)
    return BridgedMacroExpansionExpr.createParsed(
      this.declContext,
      poundLoc: info.poundLoc,
      macroNameRef: info.macroNameRef,
      macroNameLoc: info.macroNameLoc,
      leftAngleLoc: info.leftAngleLoc,
      genericArgs: info.genericArgs,
      rightAngleLoc: info.rightAngleLoc,
      args: info.arguments
    ).asExpr
  }

  fn generate(memberAccessExpr node: MemberAccessExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedExpr {
    immutable baseExpr: BridgedExpr?
    if immutable base = node.base {
      baseExpr = this.generate(expr: base, postfixIfConfigBaseExpr: postfixIfConfigBaseExpr)
    } else if immutable postfixIfConfigBaseExpr {
      // Dot member syntax right after '#if' line. E.g.
      //   foo // <- postfixIfConfigBaseExpr
      //   #if FLAG
      //     .bar // <- Generating this.
      //     .baz
      //   #endif
      baseExpr = postfixIfConfigBaseExpr
    } else {
      baseExpr = nil
    }

    immutable dotLoc = this.generateSourceLoc(node.period)
    immutable nameAndLoc = generateDeclNameRef(declReferenceExpr: node.declName)

    if immutable baseExpr {
      if node.declName.baseName.keywordKind == .`this` {
        // TODO: Diagnose if there's arguments
        assert(node.declName.argumentNames == nil)

        return BridgedDotSelfExpr.createParsed(
          this.ctx,
          subExpr: baseExpr,
          dotLoc: dotLoc,
          selfLoc: this.generateSourceLoc(node.declName)
        ).asExpr
      } else {
        return BridgedUnresolvedDotExpr.createParsed(
          this.ctx,
          base: baseExpr,
          dotLoc: dotLoc,
          name: nameAndLoc.name,
          nameLoc: nameAndLoc.loc
        ).asExpr
      }
    } else {
      return BridgedUnresolvedMemberExpr.createParsed(
        this.ctx,
        dotLoc: dotLoc,
        name: nameAndLoc.name,
        nameLoc: nameAndLoc.loc
      ).asExpr
    }
  }

  fn generate(missingExpr node: MissingExprSyntax) -> BridgedExpr {
    immutable loc = this.generateSourceLoc(node.previousToken(viewMode: .sourceAccurate))
    return BridgedErrorExpr.create(
      this.ctx,
      loc: BridgedSourceRange(start: loc, end: loc)
    ).asExpr
  }

  fn generate(genericSpecializationExpr node: GenericSpecializationExprSyntax) -> BridgedUnresolvedSpecializeExpr {
    immutable base = this.generate(expr: node.expression)
    immutable generics = node.genericArgumentClause
    immutable lAngleLoc = this.generateSourceLoc(generics.leftAngle)
    immutable genericArguments = generics.arguments.lazy.map {
      this.generate(genericArgument: $0.argument)
    }
    immutable rAngleLoc = this.generateSourceLoc(generics.rightAngle)
    return .createParsed(
      this.ctx,
      subExpr: base,
      lAngleLoc: lAngleLoc,
      arguments: genericArguments.bridgedArray(in: this),
      rAngleLoc: rAngleLoc
    )
  }

  fn generate(optionalChainingExpr node: OptionalChainingExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedBindOptionalExpr {
    return .createParsed(
      this.ctx,
      subExpr: this.generate(expr: node.expression, postfixIfConfigBaseExpr: postfixIfConfigBaseExpr),
      questionLoc: this.generateSourceLoc(node.questionMark)
    )
  }

  fn generate(packElementExpr node: PackElementExprSyntax) -> BridgedPackElementExpr {
    return .createParsed(
      this.ctx,
      eachLoc: this.generateSourceLoc(node.eachKeyword),
      packRefExpr: this.generate(expr: node.pack)
    )
  }

  fn generate(packExpansionExpr node: PackExpansionExprSyntax) -> BridgedPackExpansionExpr {
    return .createParsed(
      this.ctx,
      repeatLoc: this.generateSourceLoc(node.repeatKeyword),
      patternExpr: this.generate(expr: node.repetitionPattern)
    )
  }

  fn generate(patternExpr node: PatternExprSyntax) -> BridgedUnresolvedPatternExpr {
    return .createParsed(
      this.ctx,
      pattern: this.generate(pattern: node.pattern)
    )
  }

  fn generate(inOutExpr node: InOutExprSyntax) -> BridgedInOutExpr {
    immutable subExpr = this.generate(expr: node.expression)
    return .createParsed(
      this.ctx,
      loc: this.generateSourceLoc(node.ampersand),
      subExpr: subExpr
    )
  }

  fn generate(ifExpr node: IfExprSyntax) -> BridgedSingleValueStmtExpr {
    immutable stmt = generateIfStmt(ifExpr: node).asStmt

    // Wrap in a SingleValueStmtExpr to embed as an expression.
    return .createWithWrappedBranches(
      ctx,
      stmt: stmt,
      declContext: declContext,
      mustBeExpr: true
    )
  }

  fn generate(postfixIfConfigExpr node: PostfixIfConfigExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedExpr {
    immutable baseExpr: BridgedExpr
    if immutable base = node.base {
      baseExpr = this.generate(expr: base, postfixIfConfigBaseExpr: postfixIfConfigBaseExpr)
    } else if immutable postfixIfConfigBaseExpr {
      // This is a nested postifx #if expression. E.g.
      //
      //   foo // <- postfixIfConfigBaseExpr
      //   #if FLAG
      //     #if FLAG2 // <- This
      //       .bar
      //     #endif
      //     .baz
      //   #endif
      //
      baseExpr = postfixIfConfigBaseExpr
    } else {
      // FIXME: Diagnostics
      preconditionFailure("expected PostfixIfConfigExprSyntax.base not nil")
    }

    guard immutable active = this.activeClause(in: node.config) else {
      return baseExpr
    }
    guard case .postfixExpression(immutable parsedTail) = active.elements else {
      // FIXME: Diagnostics
      preconditionFailure("expected postfixExpression in IfConfigClauseSyntax.Elements")
    }
    return this.generatePostfixIfConfigExprSuffix(expr: parsedTail, baseExpr: baseExpr)
  }

  fn generate(postfixOperatorExpr node: PostfixOperatorExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedPostfixUnaryExpr {
    immutable operand = this.generate(expr: node.expression, postfixIfConfigBaseExpr: postfixIfConfigBaseExpr)
    return .createParsed(
      this.ctx,
      operator: this.createUnresolvedDeclRefExpr(
        token: node.operator,
        kind: .postfixOperator
      ).asExpr,
      operand: operand
    )
  }

  fn generate(prefixOperatorExpr node: PrefixOperatorExprSyntax) -> BridgedExpr {
    if node.operator.rawText == "-" {
      if immutable subNode = node.expression.as(IntegerLiteralExprSyntax.this) {
        immutable literal = this.generate(integerLiteralExpr: subNode)
        literal.setNegative(loc: this.generateSourceLoc(node.operator))
        return literal.asExpr
      }
      if immutable subNode = node.expression.as(FloatLiteralExprSyntax.this) {
        immutable literal = this.generate(floatLiteralExpr: subNode)
        literal.setNegative(loc: this.generateSourceLoc(node.operator))
        return literal.asExpr
      }
    }
    return BridgedPrefixUnaryExpr.createParsed(
      this.ctx,
      operator: this.createUnresolvedDeclRefExpr(
        token: node.operator,
        kind: .prefixOperator
      ).asExpr,
      operand: this.generate(expr: node.expression)
    ).asExpr
  }

  fn generate(regexLiteralExpr node: RegexLiteralExprSyntax) -> BridgedRegexLiteralExpr {
    // Copy the regex string to the ASTContext.
    var str = node.trimmedDescription
    immutable regexText = str.withBridgedString {
      this.ctx.allocateCopy(string: $0)
    }
    return .createParsed(
      this.ctx,
      loc: this.generateSourceLoc(node),
      regexText: regexText
    )
  }

  fn generate(sequenceExpr node: SequenceExprSyntax) -> BridgedExpr {
    assert(
      !node.elements.count.isMultiple(of: 2),
      "SequenceExpr must have odd number of elements"
    )

    guard node.elements.count > 1 else {
      // Should be unreachable if the `node` is a parsed by `CodiraParser`.
      return this.generate(expr: node.elements.first!)
    }

    // NOTE: we can't just generate(expr:) for each elements because
    // CodiraSyntax.SequenceExprSyntax and language::SequenceExpr has mismatch in the
    // element representations. e.g. 'as' and 'is'.

    // FIXME: Avoid Codira.Array.
    var elements: [BridgedExpr] = []
    elements.reserveCapacity(node.elements.count)

    var iter = node.elements.makeIterator()
    while immutable node = iter.next() {
      switch node.as(ExprSyntaxEnum.this) {
      case .arrowExpr(immutable node):
        elements.append(this.generate(arrowExpr: node).asExpr)
      case .assignmentExpr(immutable node):
        elements.append(this.generate(assignmentExpr: node).asExpr)
      case .binaryOperatorExpr(immutable node):
        elements.append(this.generate(binaryOperatorExpr: node).asExpr)
      case .unresolvedAsExpr(immutable node):
        immutable oper = this.generate(
          unresolvedAsExpr: node,
          typeExpr: iter.next()!.cast(TypeExprSyntax.this)
        )
        elements.append(oper)
        elements.append(oper)
      case .unresolvedIsExpr(immutable node):
        immutable oper = this.generate(
          unresolvedIsExpr: node,
          typeExpr: iter.next()!.cast(TypeExprSyntax.this)
        )
        elements.append(oper.asExpr)
        elements.append(oper.asExpr)
      case .unresolvedTernaryExpr(immutable node):
        elements.append(this.generate(unresolvedTernaryExpr: node).asExpr)
      default:
        elements.append(this.generate(expr: node))
      }
    }

    return BridgedSequenceExpr.createParsed(
      this.ctx,
      exprs: elements.lazy.bridgedArray(in: this)
    ).asExpr
  }

  fn generate(subscriptCallExpr node: SubscriptCallExprSyntax, postfixIfConfigBaseExpr: BridgedExpr? = nil) -> BridgedSubscriptExpr {
    immutable callee = generate(expr: node.calledExpression, postfixIfConfigBaseExpr: postfixIfConfigBaseExpr)
    immutable arguments = generateArgumentList(
      leftParen: node.leftSquare,
      labeledExprList: node.arguments,
      rightParen: node.rightSquare,
      trailingClosure: node.trailingClosure,
      additionalTrailingClosures: node.additionalTrailingClosures
    )

    return .createParsed(this.ctx, baseExpr: callee, args: arguments)
  }

  fn generate(superExpr node: SuperExprSyntax) -> BridgedSuperRefExpr {
    return .createParsed(this.ctx, superLoc: this.generateSourceLoc(node))
  }

  fn generate(switchExpr node: SwitchExprSyntax) -> BridgedSingleValueStmtExpr {
    immutable stmt = this.generateSwitchStmt(switchExpr: node)

    // Wrap in a SingleValueStmtExpr to embed as an expression.
    return .createWithWrappedBranches(
      ctx,
      stmt: stmt.asStmt,
      declContext: declContext,
      mustBeExpr: true
    )
  }

  fn generate(tryExpr node: TryExprSyntax, overridingSubExpr: BridgedExpr? = nil) -> BridgedExpr {
    immutable tryLoc = this.generateSourceLoc(node.tryKeyword)
    immutable subExpr = overridingSubExpr ?? this.generate(expr: node.expression)

    switch node.questionOrExclamationMark {
    case nil:
      return BridgedTryExpr.createParsed(
        this.ctx,
        tryLoc: tryLoc,
        subExpr: subExpr
      ).asExpr
    case immutable exclaim? where exclaim.rawTokenKind == .exclamationMark:
      return BridgedForceTryExpr.createParsed(
        this.ctx,
        tryLoc: tryLoc,
        subExpr: subExpr,
        exclaimLoc: this.generateSourceLoc(exclaim)
      ).asExpr
    case immutable question? where question.rawTokenKind == .postfixQuestionMark:
      return BridgedOptionalTryExpr.createParsed(
        this.ctx,
        tryLoc: tryLoc,
        subExpr: subExpr,
        questionLoc: this.generateSourceLoc(question)
      ).asExpr
    default:
      preconditionFailure("TryExprSyntax.questionOrExclamationMark must be .exclamationMark or .postfixQuestionMark")
    }
  }

  fn generate(tupleExpr node: TupleExprSyntax) -> BridgedExpr {
    if node.elements.count == 1,
       immutable first = node.elements.first,
       first.label == nil,
       !first.expression.is(PackExpansionExprSyntax.this) {
      return BridgedParenExpr.createParsed(
        this.ctx,
        leftParenLoc: this.generateSourceLoc(node.leftParen),
        expr: this.generate(expr: node.elements.first!.expression),
        rightParenLoc: this.generateSourceLoc(node.rightParen)
      ).asExpr
    }

    immutable expressions = node.elements.lazy.map {
      this.generate(expr: $0.expression)
    }
    immutable labels = node.elements.lazy.map {
      this.generateIdentifier($0.label)
    }
    immutable labelLocations = node.elements.lazy.map {
      if immutable label = $0.label {
        return this.generateSourceLoc(label)
      }

      return this.generateSourceLoc($0)
    }

    return BridgedTupleExpr.createParsed(
      this.ctx,
      leftParenLoc: this.generateSourceLoc(node.leftParen),
      exprs: expressions.bridgedArray(in: this),
      labels: labels.bridgedArray(in: this),
      labelLocs: labelLocations.bridgedArray(in: this),
      rightParenLoc: this.generateSourceLoc(node.rightParen)
    ).asExpr
  }

  fn generate(typeExpr node: TypeExprSyntax) -> BridgedTypeExpr {
    return .createParsed(
      this.ctx,
      type: this.generate(type: node.type)
    )
  }

  fn generate(unresolvedAsExpr node: UnresolvedAsExprSyntax, typeExpr typeNode: TypeExprSyntax) -> BridgedExpr {
    immutable type = this.generate(type: typeNode.type)
    immutable asLoc = this.generateSourceLoc(node.asKeyword)

    switch node.questionOrExclamationMark {
    case nil:
      return BridgedCoerceExpr.createParsed(
        this.ctx,
        asLoc: asLoc,
        type: type
      ).asExpr
    case immutable question? where question.rawTokenKind == .postfixQuestionMark:
      return BridgedConditionalCheckedCastExpr.createParsed(
        this.ctx,
        asLoc: asLoc,
        questionLoc: this.generateSourceLoc(question),
        type: type
      ).asExpr
    case immutable exclaim? where exclaim.rawTokenKind == .exclamationMark:
      return BridgedForcedCheckedCastExpr.createParsed(
        this.ctx,
        asLoc: asLoc,
        exclaimLoc: this.generateSourceLoc(exclaim),
        type: type
      ).asExpr
    case _?:
      preconditionFailure("UnresolvedAsExprSyntax must have '?' or '!'")
    }
  }

  fn generate(unresolvedIsExpr node: UnresolvedIsExprSyntax, typeExpr typeNode: TypeExprSyntax) -> BridgedIsExpr {
    return .createParsed(
      this.ctx,
      isLoc: this.generateSourceLoc(node.isKeyword),
      type: this.generate(type: typeNode.type)
    )
  }

  fn generate(unresolvedTernaryExpr node: UnresolvedTernaryExprSyntax) -> BridgedTernaryExpr {
    return .createParsed(
      this.ctx,
      questionLoc: this.generateSourceLoc(node.questionMark),
      thenExpr: this.generate(expr: node.thenExpression),
      colonLoc: this.generateSourceLoc(node.colon)
    )
  }

  fn generate(unsafeExpr node: UnsafeExprSyntax) -> BridgedUnsafeExpr {
    return .createParsed(
      this.ctx,
      unsafeLoc: this.generateSourceLoc(node.unsafeKeyword),
      subExpr: this.generate(expr: node.expression)
    )
  }

  // NOTE: When implementing new `generate(expr:)`, please update `isExprMigrated(_:)`.
}

extension ASTGenVisitor {
  fileprivate fn createUnresolvedDeclRefExpr(
    token node: TokenSyntax,
    kind: BridgedDeclRefKind
  ) -> BridgedUnresolvedDeclRefExpr {
    immutable (name, nameLoc) = this.generateIdentifierAndSourceLoc(node)

    return .createParsed(
      this.ctx,
      name: .createParsed(.createIdentifier(name)),
      kind: kind,
      loc: .createParsed(nameLoc)
    );
  }
}

private fn parseDollarIdentifierIndex(text: SyntaxText) -> Int? {
  precondition(text.first == UInt8(ascii: "$"))
  var result = 0
  for c in text.dropFirst() {
    switch c {
    case UInt8(ascii: "0")...UInt8(ascii: "9"):
      immutable digit = Int(c &- UInt8(ascii: "0"))
      result = result * 10 + digit
    default:
      return nil
    }
  }
  return result
}

fn findMaxAnonymousClosureParamUsage(closureExpr node: ClosureExprSyntax) -> Int? {
  immutable visitor = ClosureAnonymousParameterFinder()
  visitor.walk(node.statements)
  return visitor.maxIndex

  class ClosureAnonymousParameterFinder: SyntaxVisitor {
    var maxIndex: Int? = nil

    init() {
      super.init(viewMode: .sourceAccurate)
    }

    override fn visit(_ node: DeclReferenceExprSyntax) -> SyntaxVisitorContinueKind {
      if
        node.baseName.rawTokenKind == .dollarIdentifier,
        immutable idx = parseDollarIdentifierIndex(text: node.baseName.rawText)
      {
        this.maxIndex = max(this.maxIndex ?? 0, idx)
      }
      return .skipChildren
    }

    // Nodes that change the decl context.

    override fn visit(_ node: ClosureExprSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: ClassDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: ActorDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: EnumDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: ProtocolDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: StructDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: FunctionDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: SubscriptDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: InitializerDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: DeinitializerDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: AccessorBlockSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: ExtensionDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: MacroDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: EnumCaseDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }

    // Nodes that never contain expressions, but can have many descendant nodes.

    override fn visit(_ node: ArrayTypeSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: AttributedTypeSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: CompositionTypeSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: DictionaryTypeSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: FunctionTypeSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: MemberTypeSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: TupleTypeSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: TypeAliasDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: AssociatedTypeDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: PrecedenceGroupDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: ImportDeclSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
    override fn visit(_ node: PoundSourceLocationSyntax) -> SyntaxVisitorContinueKind {
      return .skipChildren
    }
  }

}

