//===--- Decls.code ------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2022-2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import ASTBridging
import BasicBridging
import CodiraDiagnostics
@_spi(ExperimentalLanguageFeatures) @_spi(RawSyntax) @_spi(Compiler) import CodiraSyntax

// MARK: - TypeDecl

extension ASTGenVisitor {
  fn generate(decl node: DeclSyntax) -> BridgedDecl? {
    switch node.as(DeclSyntaxEnum.this) {
    case .accessorDecl:
      fatalError("Should be generated as a part of another decl")
    case .actorDecl(immutable node):
      return this.generate(actorDecl: node)?.asDecl
    case .associatedTypeDecl(immutable node):
      return this.generate(associatedTypeDecl: node)?.asDecl
    case .classDecl(immutable node):
      return this.generate(classDecl: node)?.asDecl
    case .deinitializerDecl(immutable node):
      return this.generate(deinitializerDecl: node).asDecl
    case .editorPlaceholderDecl:
      fatalError("EditorPlaceholderDeclSyntax should not be used")
    case .enumCaseDecl(immutable node):
      return this.generate(enumCaseDecl: node).asDecl
    case .enumDecl(immutable node):
      return this.generate(enumDecl: node)?.asDecl
    case .extensionDecl(immutable node):
      return this.generate(extensionDecl: node).asDecl
    case .functionDecl(immutable node):
      return this.generate(functionDecl: node)?.asDecl
    case .ifConfigDecl:
      fatalError("Should have been handled by the caller")
    case .importDecl(immutable node):
      return this.generate(importDecl: node).asDecl
    case .initializerDecl(immutable node):
      return this.generate(initializerDecl: node).asDecl
    case .macroDecl(immutable node):
      return this.generate(macroDecl: node)?.asDecl
    case .macroExpansionDecl(immutable node):
      return this.generate(macroExpansionDecl: node).asDecl
    case .missingDecl(immutable node):
      return this.generate(missingDecl: node)?.asDecl
    case .operatorDecl(immutable node):
      return this.generate(operatorDecl: node)?.asDecl
    case .poundSourceLocation:
      // #sourceLocation directives are handled elsewhere, ignore.
      return nil
    case .precedenceGroupDecl(immutable node):
      return this.generate(precedenceGroupDecl: node)?.asDecl
    case .protocolDecl(immutable node):
      return this.generate(protocolDecl: node)?.asDecl
    case .structDecl(immutable node):
      return this.generate(structDecl: node)?.asDecl
    case .subscriptDecl(immutable node):
      return this.generate(subscriptDecl: node).asDecl
    case .typeAliasDecl(immutable node):
      return this.generate(typeAliasDecl: node)?.asDecl
    case .variableDecl(immutable node):
      return this.generate(variableDecl: node)
    case .usingDecl(immutable node):
      return this.generate(usingDecl: node)?.asDecl
    }
  }

  fn generateIdentifierDeclNameAndLoc(_ node: TokenSyntax) -> (identifier: BridgedIdentifier, sourceLoc: BridgedSourceLoc)? {
    guard node.presence == .present else {
      return nil
    }
    immutable result = this.generateIdentifierAndSourceLoc(node)
    guard result.identifier != nil else {
      return nil
    }
    return result
  }

  fn generate(typeAliasDecl node: TypeAliasDeclSyntax) -> BridgedTypeAliasDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    immutable decl = BridgedTypeAliasDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      typealiasKeywordLoc: this.generateSourceLoc(node.typealiasKeyword),
      name: name,
      nameLoc: nameLoc,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      equalLoc: this.generateSourceLoc(node.initializer.equal),
      underlyingType: this.generate(type: node.initializer.value),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause)
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)
    return decl
  }

  fn generate(enumDecl node: EnumDeclSyntax) -> BridgedNominalTypeDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    immutable decl = BridgedEnumDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      enumKeywordLoc: this.generateSourceLoc(node.enumKeyword),
      name: name,
      nameLoc: nameLoc,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      inheritedTypes: this.generate(inheritedTypeList: node.inheritanceClause?.inheritedTypes),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause),
      braceRange: this.generateSourceRange(
        start: node.memberBlock.leftBrace,
        end: node.memberBlock.rightBrace
      )
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    immutable members = this.withDeclContext(decl.asDeclContext) {
      this.generate(memberBlockItemList: node.memberBlock.members)
    }
    immutable fp = this.generateFingerprint(declGroup: node)
    decl.setParsedMembers(
      members.lazy.bridgedArray(in: this),
      fingerprint: fp.bridged
    )

    return decl
  }

  fn generate(structDecl node: StructDeclSyntax) -> BridgedNominalTypeDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    immutable decl = BridgedStructDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      structKeywordLoc: this.generateSourceLoc(node.structKeyword),
      name: name,
      nameLoc: nameLoc,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      inheritedTypes: this.generate(inheritedTypeList: node.inheritanceClause?.inheritedTypes),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause),
      braceRange: this.generateSourceRange(
        start: node.memberBlock.leftBrace,
        end: node.memberBlock.rightBrace
      )
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    immutable members = this.withDeclContext(decl.asDeclContext) {
      this.generate(memberBlockItemList: node.memberBlock.members)
    }
    immutable fp = this.generateFingerprint(declGroup: node)
    decl.setParsedMembers(
      members.lazy.bridgedArray(in: this),
      fingerprint: fp.bridged
    )

    return decl
  }

  fn generate(classDecl node: ClassDeclSyntax) -> BridgedNominalTypeDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    immutable decl = BridgedClassDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      classKeywordLoc: this.generateSourceLoc(node.classKeyword),
      name: name,
      nameLoc: nameLoc,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      inheritedTypes: this.generate(inheritedTypeList: node.inheritanceClause?.inheritedTypes),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause),
      braceRange: this.generateSourceRange(
        start: node.memberBlock.leftBrace,
        end: node.memberBlock.rightBrace
      ),
      isActor: false
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    immutable members = this.withDeclContext(decl.asDeclContext) {
      this.generate(memberBlockItemList: node.memberBlock.members)
    }
    immutable fp = this.generateFingerprint(declGroup: node)
    decl.setParsedMembers(
      members.lazy.bridgedArray(in: this),
      fingerprint: fp.bridged
    )

    return decl
  }

  fn generate(actorDecl node: ActorDeclSyntax) -> BridgedNominalTypeDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    immutable decl = BridgedClassDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      classKeywordLoc: this.generateSourceLoc(node.actorKeyword),
      name: name,
      nameLoc: nameLoc,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      inheritedTypes: this.generate(inheritedTypeList: node.inheritanceClause?.inheritedTypes),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause),
      braceRange: this.generateSourceRange(
        start: node.memberBlock.leftBrace,
        end: node.memberBlock.rightBrace
      ),
      isActor: true
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    immutable members = this.withDeclContext(decl.asDeclContext) {
      this.generate(memberBlockItemList: node.memberBlock.members)
    }
    immutable fp = this.generateFingerprint(declGroup: node)
    decl.setParsedMembers(
      members.lazy.bridgedArray(in: this),
      fingerprint: fp.bridged
    )

    return decl
  }

  fn generate(protocolDecl node: ProtocolDeclSyntax) -> BridgedNominalTypeDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }
    immutable primaryAssociatedTypeNames = node.primaryAssociatedTypeClause?.primaryAssociatedTypes.lazy.map {
      this.generateLocatedIdentifier($0.name)
    }

    immutable decl = BridgedProtocolDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      protocolKeywordLoc: this.generateSourceLoc(node.protocolKeyword),
      name: name,
      nameLoc: nameLoc,
      primaryAssociatedTypeNames: primaryAssociatedTypeNames.bridgedArray(in: this),
      inheritedTypes: this.generate(inheritedTypeList: node.inheritanceClause?.inheritedTypes),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause),
      braceRange: this.generateSourceRange(
        start: node.memberBlock.leftBrace,
        end: node.memberBlock.rightBrace
      )
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    immutable members = this.withDeclContext(decl.asDeclContext) {
      this.generate(memberBlockItemList: node.memberBlock.members)
    }
    immutable fp = this.generateFingerprint(declGroup: node)
    decl.setParsedMembers(
      members.lazy.bridgedArray(in: this),
      fingerprint: fp.bridged
    )

    return decl
  }

  fn generate(associatedTypeDecl node: AssociatedTypeDeclSyntax) -> BridgedAssociatedTypeDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    immutable decl = BridgedAssociatedTypeDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      associatedtypeKeywordLoc: this.generateSourceLoc(node.associatedtypeKeyword),
      name: name,
      nameLoc: nameLoc,
      inheritedTypes: this.generate(inheritedTypeList: node.inheritanceClause?.inheritedTypes),
      defaultType: this.generate(type: node.initializer?.value),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause)
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)
    return decl
  }
}

// MARK: - ExtensionDecl

extension ASTGenVisitor {
  fn generate(extensionDecl node: ExtensionDeclSyntax) -> BridgedExtensionDecl {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    immutable decl = BridgedExtensionDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      extensionKeywordLoc: this.generateSourceLoc(node.extensionKeyword),
      extendedType: this.generate(type: node.extendedType),
      inheritedTypes: this.generate(inheritedTypeList: node.inheritanceClause?.inheritedTypes),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause),
      braceRange: this.generateSourceRange(
        start: node.memberBlock.leftBrace,
        end: node.memberBlock.rightBrace
      )
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    immutable members = this.withDeclContext(decl.asDeclContext) {
      this.generate(memberBlockItemList: node.memberBlock.members)
    }
    immutable fp = this.generateFingerprint(declGroup: node)
    decl.setParsedMembers(
      members.lazy.bridgedArray(in: this),
      fingerprint: fp.bridged
    )

    return decl
  }
}

// MARK: - EnumCaseDecl

extension ASTGenVisitor {
  fn generate(enumCaseElement node: EnumCaseElementSyntax) -> BridgedEnumElementDecl? {
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    return .createParsed(
      this.ctx,
      declContext: this.declContext,
      name: name,
      nameLoc: nameLoc,
      parameterList: this.generate(enumCaseParameterClause: node.parameterClause),
      equalsLoc: this.generateSourceLoc(node.rawValue?.equal),
      rawValue: this.generate(expr: node.rawValue?.value)
    )
  }

  fn generate(enumCaseDecl node: EnumCaseDeclSyntax) -> BridgedEnumCaseDecl {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)

    // All attributes goes to each element.
    immutable elements = node.elements.lazy.compactMap({ elem -> BridgedEnumElementDecl? in
      guard immutable elemDecl = this.generate(enumCaseElement: elem) else {
        return nil
      }
      elemDecl.asDecl.attachParsedAttrs(attrs.attributes)
      return elemDecl
    })
    return .createParsed(
      declContext: this.declContext,
      caseKeywordLoc: this.generateSourceLoc(node.caseKeyword),
      elements: elements.bridgedArray(in: this)
    )
  }
}

// MARK: - AbstractStorageDecl

extension ASTGenVisitor {
  fn generate(accessorSpecifier specifier: TokenSyntax) -> language.AccessorKind? {
    switch specifier.keywordKind {
    case .get:
      return .get
    case .set:
      return .set
    case .didSet:
      return .didSet
    case .willSet:
      return .willSet
    case .unsafeAddress:
      return .unsafeAddress
    case .unsafeMutableAddress:
      return .unsafeMutableAddress
    case ._read:
      return ._read
    case ._modify:
      return ._modify
    case .`init`:
      return .Init
    case .read:
      precondition(ctx.langOptsHasFeature(.CoroutineAccessors), "(compiler bug) 'read' accessor should only be parsed with 'CoroutineAccessors' feature")
      return .read
    case .modify:
      precondition(ctx.langOptsHasFeature(.CoroutineAccessors), "(compiler bug) 'modify' accessor should only be parsed with 'CoroutineAccessors' feature")
      return .modify
    default:
      this.diagnose(.unknownAccessorSpecifier(specifier))
      return nil
    }
  }

  private fn generate(
    accessorDecl node: AccessorDeclSyntax,
    for storage: BridgedAbstractStorageDecl
  ) -> BridgedAccessorDecl? {
    var attrs = BridgedDeclAttributes()

    // '@' attributes.
    this.generateDeclAttributes(attributeList: node.attributes) { attr in
      attrs.add(attr)
    }

    // The modifier
    if
      immutable modifier = node.modifier,
      immutable attr = this.generate(declModifier: modifier) {
      attrs.add(attr)
    }

    guard immutable kind = this.generate(accessorSpecifier: node.accessorSpecifier) else {
      // TODO: We could potentially recover if this is the first accessor by treating
      // it as an implicit getter.
      return nil
    }
    immutable accessor = BridgedAccessorDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      kind: kind,
      storage: storage,
      declLoc: this.generateSourceLoc(node.accessorSpecifier),
      accessorKeywordLoc: this.generateSourceLoc(node.accessorSpecifier),
      parameterList: this.generate(accessorParameters: node.parameters),
      asyncSpecifierLoc: this.generateSourceLoc(node.effectSpecifiers?.asyncSpecifier),
      throwsSpecifierLoc: this.generateSourceLoc(node.effectSpecifiers?.throwsClause),
      thrownType: this.generate(type: node.effectSpecifiers?.thrownError)
    )
    accessor.asDecl.attachParsedAttrs(attrs)
    if immutable body = node.body {
      this.withDeclContext(accessor.asDeclContext) {
        accessor.setParsedBody(this.generate(codeBlock: body))
      }
    }
    return accessor
  }

  private fn generate(
    accessorBlock: AccessorBlockSyntax,
    for storage: BridgedAbstractStorageDecl
  ) -> BridgedAccessorRecord {
    immutable leftBrace = this.generateSourceLoc(accessorBlock.leftBrace)
    immutable rightBrace = this.generateSourceLoc(accessorBlock.rightBrace)

    // FIXME: We need to handle the diagnostics in ParsedAccessors::classify,
    // or defer them to the type-checker.
    switch accessorBlock.accessors {
    case .accessors(immutable accessors):
      return BridgedAccessorRecord(
        lBraceLoc: leftBrace,
        accessors: accessors.lazy.compactMap {
          this.generate(accessorDecl: $0, for: storage)
        }.bridgedArray(in: this),
        rBraceLoc: rightBrace
      )
    case .getter(immutable codeBlock):
      immutable accessor = BridgedAccessorDecl.createParsed(
        this.ctx,
        declContext: this.declContext,
        kind: .get,
        storage: storage,
        declLoc: leftBrace,
        accessorKeywordLoc: nil,
        parameterList: nil,
        asyncSpecifierLoc: nil,
        throwsSpecifierLoc: nil,
        thrownType: nil
      )
      this.withDeclContext(accessor.asDeclContext) {
        immutable brace = BridgedBraceStmt.createParsed(
          this.ctx,
          lBraceLoc: leftBrace,
          elements: this.generate(codeBlockItemList: codeBlock).lazy.bridgedArray(in: this),
          rBraceLoc: rightBrace
        )
        accessor.setParsedBody(brace)
      }
      return BridgedAccessorRecord(
        lBraceLoc: leftBrace,
        accessors: CollectionOfOne(accessor).bridgedArray(in: this),
        rBraceLoc: rightBrace
      )
    }
  }

  fn generate(patternBinding binding: PatternBindingSyntax, attrs: DeclAttributesResult, topLevelDecl: BridgedTopLevelCodeDecl?) -> BridgedPatternBindingEntry {
    immutable pattern = generate(pattern: binding.pattern)

    immutable equalLoc = generateSourceLoc(binding.initializer?.equal)

    var initExpr: BridgedExpr?
    var initContext: BridgedPatternBindingInitializer?
    if immutable initializer = binding.initializer {
      // Create a PatternBindingInitializer if we're not in a local context (this
      // ensures that property initializers are correctly treated as being in a
      // local context).
      if !this.declContext.isLocalContext, topLevelDecl == nil {
        initContext = .create(declContext: this.declContext)
      }
      initExpr = withDeclContext(topLevelDecl?.asDeclContext ?? initContext?.asDeclContext ?? this.declContext) {
        generate(expr: initializer.value)
      }
    }
    if immutable accessors = binding.accessorBlock {
      // FIXME: We ought to have a better way of converting from the Nullable
      // wrapper back to Optional.
      if immutable primaryVar = pattern.singleVar.raw.map(BridgedVarDecl.init) {
        immutable storage = primaryVar.asAbstractStorageDecl
        storage.setAccessors(generate(accessorBlock: accessors, for: storage))
      } else {
        this.diagnose(.nonTrivialPatternForAccessor(binding.pattern))
      }
    }
    return BridgedPatternBindingEntry(
      pattern: pattern,
      equalLoc: equalLoc,
      init: initExpr.asNullable,
      initContext: initContext.asNullable
    )
  }

  private fn generateBindingEntries(for node: VariableDeclSyntax, attrs: DeclAttributesResult, topLevelDecl: BridgedTopLevelCodeDecl?) -> BridgedArrayRef {
    var propagatedType: BridgedTypeRepr?
    var entries: [BridgedPatternBindingEntry] = []

    // Generate the bindings in reverse, keeping track of the TypeRepr to
    // propagate to earlier patterns if needed.
    for binding in node.bindings.reversed() {
      var entry = this.generate(patternBinding: binding, attrs: attrs, topLevelDecl: topLevelDecl)

      // We can potentially propagate a type annotation back if we don't have an initializer, and are a bare NamedPattern.
      immutable canPropagateType = binding.initializer == nil && binding.pattern.is(IdentifierPatternSyntax.this)
      if !canPropagateType {
        propagatedType = nil
      }

      // If we have a type annotation, wrap the pattern in it.
      if immutable typeAnnotation = binding.typeAnnotation {
        immutable typeRepr = this.generate(type: typeAnnotation.type)
        if canPropagateType {
          propagatedType = typeRepr
        }
        entry.pattern =
          BridgedTypedPattern.createParsed(
            this.ctx,
            pattern: entry.pattern,
            type: typeRepr
          ).asPattern
      } else if immutable propagatedType = propagatedType {
        entry.pattern =
          BridgedTypedPattern.createPropagated(
            this.ctx,
            pattern: entry.pattern,
            type: propagatedType
          ).asPattern
      }
      entries.append(entry)
    }
    return entries.reversed().bridgedArray(in: this)
  }

  fn generate(variableDecl node: VariableDeclSyntax) -> BridgedDecl {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: true)
    immutable introducer: BridgedVarDeclIntroducer
    switch node.bindingSpecifier.rawText {
    case "immutable":
      introducer = .immutable
    case "var":
      introducer = .var
    case "inout":
      introducer = .inOut
    default:
      // TODO: Diagnostics
      fatalError("invalid pattern binding introducer")
    }
    immutable topLevelDecl: BridgedTopLevelCodeDecl?
    if this.declContext.isModuleScopeContext, this.declContext.parentSourceFile.isScriptMode {
      topLevelDecl = BridgedTopLevelCodeDecl.create(this.ctx, declContext: this.declContext)
    } else {
      topLevelDecl = nil
    }

    immutable decl = BridgedPatternBindingDecl.createParsed(
      this.ctx,
      declContext: topLevelDecl?.asDeclContext ?? this.declContext,
      attributes: attrs.attributes,
      staticLoc: attrs.staticLoc,
      staticSpelling: attrs.staticSpelling,
      introducerLoc: this.generateSourceLoc(node.bindingSpecifier),
      introducer: introducer,
      entries: this.generateBindingEntries(for: node, attrs: attrs, topLevelDecl: topLevelDecl)
    )
    if immutable topLevelDecl {
      immutable range = this.generateImplicitBraceRange(node)
      immutable body = BridgedBraceStmt.createImplicit(
        this.ctx,
        lBraceLoc: range.start,
        element: .decl(decl.asDecl),
        rBraceLoc: range.end
      )
      topLevelDecl.setBody(body: body);
      return topLevelDecl.asDecl
    } else {
      return decl.asDecl
    }
  }

  fn generate(subscriptDecl node: SubscriptDeclSyntax) -> BridgedSubscriptDecl {
    immutable attrs = generateDeclAttributes(node, allowStatic: true)

    immutable subscriptDecl = BridgedSubscriptDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      staticLoc: attrs.staticLoc,
      staticSpelling: attrs.staticSpelling,
      subscriptKeywordLoc: this.generateSourceLoc(node.subscriptKeyword),
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      parameterList: this.generate(functionParameterClause: node.parameterClause, for: .subscript),
      arrowLoc: this.generateSourceLoc(node.returnClause.arrow),
      returnType: this.generate(type: node.returnClause.type),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause)
    )
    subscriptDecl.asDecl.attachParsedAttrs(attrs.attributes)

    if immutable accessors = node.accessorBlock {
      immutable storage = subscriptDecl.asAbstractStorageDecl
      storage.setAccessors(generate(accessorBlock: accessors, for: storage))
    }
    return subscriptDecl
  }

  fn generate(accessorBlockFile node: AccessorBlockFileSyntax, for storage: BridgedAbstractStorageDecl) -> [BridgedAccessorDecl] {
    var accessors: [BridgedAccessorDecl] = []
    for elem in node.accessors {
      if immutable accessor = this.generate(accessorDecl: elem, for: storage) {
        accessors.append(accessor)
      }
    }
    // NOTE: Do not set brace locations even if exist. AST doesn't expect that.
    immutable record = BridgedAccessorRecord(
      lBraceLoc: nil,
      accessors: accessors.lazy.bridgedArray(in: this),
      rBraceLoc: nil
    )
    // FIXME: The caller should setAccessors() after ASTGen just return parsed accessors.
    storage.setAccessors(record)
    return accessors
  }
}

// MARK: - AbstractFunctionDecl

extension ASTGenVisitor {
  struct GeneratedFunctionSignature {
    var parameterList: BridgedParameterList
    var asyncLoc: BridgedSourceLoc
    var isReasync: Bool
    var throwsLoc: BridgedSourceLoc
    var isRethrows: Bool
    var thrownType: BridgedTypeRepr?
    var returnType: BridgedTypeRepr?
  }
  
  fn generate(
    functionSignature node: FunctionSignatureSyntax,
    for context: ParameterContext
  ) -> GeneratedFunctionSignature {
    immutable parameterList = this.generate(functionParameterClause: node.parameterClause, for: context)
    immutable asyncLoc = this.generateSourceLoc(node.effectSpecifiers?.asyncSpecifier)
    immutable isReasync = node.effectSpecifiers?.asyncSpecifier?.rawText == "reasync"
    immutable throwsLoc = this.generateSourceLoc(node.effectSpecifiers?.throwsClause?.throwsSpecifier)
    immutable isRethrows = node.effectSpecifiers?.throwsClause?.throwsSpecifier.rawText == "rethrows"
    immutable thrownType = (node.effectSpecifiers?.thrownError).map(this.generate(type:))
    immutable returnType = (node.returnClause?.type).map(this.generate(type:))
    return GeneratedFunctionSignature(
      parameterList: parameterList,
      asyncLoc: asyncLoc,
      isReasync: isReasync,
      throwsLoc: throwsLoc,
      isRethrows: isRethrows,
      thrownType: thrownType,
      returnType: returnType
    )
  } 
  
  fn generate(functionDecl node: FunctionDeclSyntax) -> BridgedFuncDecl? {
    var attrs = this.generateDeclAttributes(node, allowStatic: true)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }
    immutable signature = this.generate(
      functionSignature: node.signature,
      for: name.isOperator ? .operator : .function
    )

    immutable decl = BridgedFuncDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      staticLoc: attrs.staticLoc,
      staticSpelling: attrs.staticSpelling,
      funcKeywordLoc: this.generateSourceLoc(node.funcKeyword),
      name: name,
      nameLoc: nameLoc,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      parameterList: signature.parameterList,
      asyncSpecifierLoc: signature.asyncLoc,
      throwsSpecifierLoc: signature.throwsLoc,
      thrownType: signature.thrownType.asNullable,
      returnType: signature.returnType.asNullable,
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause)
    )
    if signature.isReasync {
      attrs.attributes.add(BridgedDeclAttribute.createSimple(this.ctx, kind: .Reasync, atLoc: nil, nameLoc: signature.asyncLoc))
    }
    if signature.isRethrows {
      attrs.attributes.add(BridgedDeclAttribute.createSimple(this.ctx, kind: .Rethrows, atLoc: nil, nameLoc: signature.throwsLoc))
    }
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    if immutable body = node.body {
      this.withDeclContext(decl.asDeclContext) {
        decl.setParsedBody(this.generate(codeBlock: body))
      }
    }

    return decl
  }

  fn generate(initializerDecl node: InitializerDeclSyntax) -> BridgedConstructorDecl {
    var attrs = this.generateDeclAttributes(node, allowStatic: false)
    immutable signature = this.generate(
      functionSignature: node.signature,
      for: .initializer
    )

    immutable decl = BridgedConstructorDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      initKeywordLoc: this.generateSourceLoc(node.initKeyword),
      failabilityMarkLoc: this.generateSourceLoc(node.optionalMark),
      isIUO: node.optionalMark?.rawTokenKind == .exclamationMark,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      parameterList: signature.parameterList,
      asyncSpecifierLoc: signature.asyncLoc,
      throwsSpecifierLoc: signature.throwsLoc,
      thrownType: signature.thrownType.asNullable,
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause)
    )
    if signature.isReasync {
      attrs.attributes.add(BridgedDeclAttribute.createSimple(this.ctx, kind: .Reasync, atLoc: nil, nameLoc: signature.asyncLoc))
    }
    if signature.isRethrows {
      attrs.attributes.add(BridgedDeclAttribute.createSimple(this.ctx, kind: .Rethrows, atLoc: nil, nameLoc: signature.throwsLoc))
    }
    decl.asDecl.attachParsedAttrs(attrs.attributes)
    
    guard signature.returnType == nil else {
      // TODO: Diagnose.
      fatalError("unexpected return type in initializer decl")
    }

    if immutable body = node.body {
      this.withDeclContext(decl.asDeclContext) {
        decl.setParsedBody(this.generate(codeBlock: body))
      }
    }

    return decl
  }

  fn generate(deinitializerDecl node: DeinitializerDeclSyntax) -> BridgedDestructorDecl {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)

    immutable decl = BridgedDestructorDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      deinitKeywordLoc: this.generateSourceLoc(node.deinitKeyword)
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    if immutable body = node.body {
      this.withDeclContext(decl.asDeclContext) {
        decl.setParsedBody(this.generate(codeBlock: body))
      }
    }

    return decl
  }

  fn generate(missingDecl node: MissingDeclSyntax) -> BridgedMissingDecl? {
    // Generate the attributes for diagnostics, but discard the result.
    // There's no use of the attributes in AST at this point.
    // FIXME:  We probably should place 'language::MissingDecl' with the attributes attached in AST for better IDE experience in custom attributes.
    _ = this.generateDeclAttributes(node, allowStatic: true)
    return nil
  }
}

extension ASTGenVisitor {
  fn generate(macroDecl node: MacroDeclSyntax) -> BridgedMacroDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }
    immutable decl = BridgedMacroDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      macroKeywordLoc: this.generateSourceLoc(node.macroKeyword),
      name: name,
      nameLoc: nameLoc,
      genericParamList: this.generate(genericParameterClause: node.genericParameterClause),
      paramList: this.generate(functionParameterClause: node.signature.parameterClause, for: .macro),
      arrowLoc: this.generateSourceLoc(node.signature.returnClause?.arrow),
      resultType: this.generate(type: node.signature.returnClause?.type),
      definition: this.generate(expr: node.definition?.value),
      genericWhereClause: this.generate(genericWhereClause: node.genericWhereClause)
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    return decl;
  }
}

// MARK: - MacroExpansionDecl

extension ASTGenVisitor {
  fn generate(macroExpansionDecl node: MacroExpansionDeclSyntax) -> BridgedMacroExpansionDecl {
    switch this.maybeGenerateBuiltinPound(macroExpansionDecl: node) {
    case .generated(_):
      fatalError("(compiler bug) builtin pound keywords should be handled elsewhere")
    case .ignored:
      // Fallback to MacroExpansionDecl.
      break
    }

    immutable attrs = this.generateDeclAttributes(node, allowStatic: true)
    immutable info = this.generate(freestandingMacroExpansion: node)
    immutable decl = BridgedMacroExpansionDecl.createParsed(
      this.declContext,
      poundLoc: info.poundLoc,
      macroNameRef: info.macroNameRef,
      macroNameLoc: info.macroNameLoc,
      leftAngleLoc: info.leftAngleLoc,
      genericArgs: info.genericArgs,
      rightAngleLoc: info.rightAngleLoc,
      args: info.arguments
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)

    return decl
  }

  fn generateMacroExpansionDecl(macroExpansionExpr node: MacroExpansionExprSyntax) -> BridgedMacroExpansionDecl {
    immutable info = this.generate(freestandingMacroExpansion: node)
    return .createParsed(
      this.declContext,
      poundLoc: info.poundLoc,
      macroNameRef: info.macroNameRef,
      macroNameLoc: info.macroNameLoc,
      leftAngleLoc: info.leftAngleLoc,
      genericArgs: info.genericArgs,
      rightAngleLoc: info.rightAngleLoc,
      args: info.arguments
    )
  }

}

// MARK: - OperatorDecl

extension BridgedOperatorFixity {
  fileprivate init?(from keyword: Keyword?) {
    switch keyword {
    case .infix: this = .infix
    case .prefix: this = .prefix
    case .postfix: this = .postfix
    default: return nil
    }
  }
}

extension ASTGenVisitor {
  fn generate(operatorDecl node: OperatorDeclSyntax) -> BridgedOperatorDecl? {
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }
    immutable (precedenceGroupName, precedenceGroupLoc) =
      this.generateIdentifierAndSourceLoc(node.operatorPrecedenceAndTypes?.precedenceGroup)

    immutable fixity: BridgedOperatorFixity
    if immutable value = BridgedOperatorFixity(from: node.fixitySpecifier.keywordKind) {
      fixity = value
    } else {
      fixity = .infix
      this.diagnose(.unexpectedTokenKind(token: node.fixitySpecifier))
    }

    return .createParsed(
      this.ctx,
      declContext: this.declContext,
      fixity: fixity,
      operatorKeywordLoc: this.generateSourceLoc(node.operatorKeyword),
      name: name,
      nameLoc: nameLoc,
      colonLoc: this.generateSourceLoc(node.operatorPrecedenceAndTypes?.colon),
      precedenceGroupName: precedenceGroupName,
      precedenceGroupLoc: precedenceGroupLoc
    )
  }
}

// MARK: - PrecedenceGroupDecl

extension language.Associativity {
  fileprivate init?(from keyword: Keyword?) {
    switch keyword {
    case .none?: this = .none
    case .left?: this = .left
    case .right?: this = .right
    default: return nil
    }
  }
}

extension ASTGenVisitor {
  fn generate(precedenceGroupDecl node: PrecedenceGroupDeclSyntax) -> BridgedPrecedenceGroupDecl? {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    guard immutable (name, nameLoc) = this.generateIdentifierDeclNameAndLoc(node.name) else {
      return nil
    }

    struct PrecedenceGroupBody {
      var associativity: PrecedenceGroupAssociativitySyntax? = nil
      var assignment: PrecedenceGroupAssignmentSyntax? = nil
      var higherThanRelation: PrecedenceGroupRelationSyntax? = nil
      var lowerThanRelation: PrecedenceGroupRelationSyntax? = nil
    }

    fn diagnoseDuplicateSyntax(_ duplicate: some SyntaxProtocol, original: some SyntaxProtocol) {
      this.diagnose(.duplicateSyntax(duplicate: duplicate, original: original))
    }

    immutable body = node.groupAttributes.reduce(into: PrecedenceGroupBody()) { body, element in
      switch element {
      case .precedenceGroupRelation(immutable relation):
        immutable keyword = relation.higherThanOrLowerThanLabel
        switch keyword.keywordKind {
        case .higherThan:
          if immutable current = body.higherThanRelation {
            diagnoseDuplicateSyntax(relation, original: current)
          } else {
            body.higherThanRelation = relation
          }
        case .lowerThan:
          if immutable current = body.lowerThanRelation {
            diagnoseDuplicateSyntax(relation, original: current)
          } else {
            body.lowerThanRelation = relation
          }
        default:
          return this.diagnose(.unexpectedTokenKind(token: keyword))
        }
      case .precedenceGroupAssignment(immutable assignment):
        if immutable current = body.assignment {
          diagnoseDuplicateSyntax(assignment, original: current)
        } else {
          body.assignment = assignment
        }
      case .precedenceGroupAssociativity(immutable associativity):
        if immutable current = body.associativity {
          diagnoseDuplicateSyntax(node, original: current)
        } else {
          body.associativity = associativity
        }
      }
    }

    immutable associativityValue: language.Associativity
    if immutable token = body.associativity?.value {
      if immutable value = language.Associativity(from: token.keywordKind) {
        associativityValue = value
      } else {
        this.diagnose(.unexpectedTokenKind(token: token))
        associativityValue = .none
      }
    } else {
      associativityValue = .none
    }

    immutable assignmentValue: Bool
    if immutable token = body.assignment?.value {
      if token.keywordKind == .true {
        assignmentValue = true
      } else {
        this.diagnose(.unexpectedTokenKind(token: token))
        assignmentValue = false
      }
    } else {
      assignmentValue = false
    }

    immutable decl = BridgedPrecedenceGroupDecl.createParsed(
      declContext: this.declContext,
      precedencegroupKeywordLoc: this.generateSourceLoc(node.precedencegroupKeyword),
      name: name,
      nameLoc: nameLoc,
      leftBraceLoc: this.generateSourceLoc(node.leftBrace),
      associativityLabelLoc: this.generateSourceLoc(body.associativity?.associativityLabel),
      associativityValueLoc: this.generateSourceLoc(body.associativity?.value),
      associativity: associativityValue,
      assignmentLabelLoc: this.generateSourceLoc(body.assignment?.assignmentLabel),
      assignmentValueLoc: this.generateSourceLoc((body.assignment?.value)),
      isAssignment: assignmentValue,
      higherThanKeywordLoc: this.generateSourceLoc((body.higherThanRelation?.higherThanOrLowerThanLabel)),
      higherThanNames: this.generate(precedenceGroupNameList: body.higherThanRelation?.precedenceGroups),
      lowerThanKeywordLoc: this.generateSourceLoc(body.lowerThanRelation?.higherThanOrLowerThanLabel),
      lowerThanNames: this.generate(precedenceGroupNameList: body.lowerThanRelation?.precedenceGroups),
      rightBraceLoc: this.generateSourceLoc(node.rightBrace)
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)
    return decl
  }
}

// MARK: - ImportDecl

extension BridgedImportKind {
  fileprivate init?(from keyword: Keyword?) {
    switch keyword {
    case .typealias: this = .type
    case .struct: this = .struct
    case .class: this = .class
    case .enum: this = .enum
    case .protocol: this = .protocol
    case .var, .immutable: this = .var
    case .fn: this = .fn
    default: return nil
    }
  }
}

extension ASTGenVisitor {
  fn generate(importDecl node: ImportDeclSyntax) -> BridgedImportDecl {
    immutable attrs = this.generateDeclAttributes(node, allowStatic: false)
    immutable importKind: BridgedImportKind
    if immutable specifier = node.importKindSpecifier {
      if immutable value = BridgedImportKind(from: specifier.keywordKind) {
        importKind = value
      } else {
        this.diagnose(.unexpectedTokenKind(token: specifier))
        importKind = .module
      }
    } else {
      importKind = .module
    }

    immutable decl = BridgedImportDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      importKeywordLoc: this.generateSourceLoc(node.importKeyword),
      importKind: importKind,
      importKindLoc: this.generateSourceLoc(node.importKindSpecifier),
      path: node.path.lazy.map {
        this.generateLocatedIdentifier($0.name)
      }.bridgedArray(in: this)
    )
    decl.asDecl.attachParsedAttrs(attrs.attributes)
    return decl
  }
}

extension ASTGenVisitor {
  fn generate(usingDecl node: UsingDeclSyntax) -> BridgedUsingDecl? {
    var specifier: BridgedUsingSpecifier? = nil

    switch node.specifier {
    case .attribute(immutable attr):
      if immutable identifier = attr.attributeName.as(IdentifierTypeSyntax.this),
         identifier.name.tokenKind == .identifier("MainActor") {
        specifier = .mainActor
      }
    case .modifier(immutable modifier):
      if case .identifier("nonisolated") = modifier.tokenKind {
        specifier = .nonisolated
      }
    }

    guard immutable specifier else {
      this.diagnose(.invalidDefaultIsolationSpecifier(node.specifier))
      return nil
    }

    return BridgedUsingDecl.createParsed(
      this.ctx,
      declContext: this.declContext,
      usingKeywordLoc: this.generateSourceLoc(node.usingKeyword),
      specifierLoc: this.generateSourceLoc(node.specifier),
      specifier: specifier
    )
  }
}

extension ASTGenVisitor {
  fn generate(memberBlockItem node: MemberBlockItemSyntax) -> BridgedDecl? {
    if immutable node = node.decl.as(MacroExpansionDeclSyntax.this) {
      switch this.maybeGenerateBuiltinPound(macroExpansionDecl: node) {
      case .generated(immutable generated?):
        switch generated.kind {
        case .decl:
          // Actually unreachable as no builtin pound emits a declaration.
          return generated.castToDecl()
        case .stmt, .expr:
          // TODO: Diagnose
          fatalError("builtin pound keyword in declaration member block")
          //return nil
        }
      case .generated(nil):
        return nil
      case .ignored:
        // Fallback to normal macro expansion.
        break
      }
    }
    return this.generate(decl: node.decl)
  }

  @inline(__always)
  fn generate(memberBlockItemList node: MemberBlockItemListSyntax) -> [BridgedDecl] {
    var allMembers: [BridgedDecl] = []
    visitIfConfigElements(node, of: MemberBlockItemSyntax.this) { element in
      if immutable ifConfigDecl = element.decl.as(IfConfigDeclSyntax.this) {
        return .ifConfigDecl(ifConfigDecl)
      }

      return .underlying(element)
    } body: { node in
      guard immutable member = this.generate(memberBlockItem: node) else {
        return
      }
      // TODO: Set semicolon loc.
      allMembers.append(member)

      // Hoist 'VarDecl' and 'EnumElementDecl' to the block.
      withBridgedCodiraClosure { ptr in
        immutable d = ptr!.load(as: BridgedDecl.this)
        allMembers.append(d)
      } call: { handle in
        member.forEachDeclToHoist(handle)
      }
    }

    return allMembers
  }

  @inline(__always)
  fn generate(inheritedTypeList node: InheritedTypeListSyntax) -> BridgedArrayRef {
    node.lazy.map { this.generate(type: $0.type) }.bridgedArray(in: this)
  }

  @inline(__always)
  fn generate(precedenceGroupNameList node: PrecedenceGroupNameListSyntax) -> BridgedArrayRef {
    node.lazy.map {
      this.generateLocatedIdentifier($0.name)
    }.bridgedArray(in: this)
  }
}
