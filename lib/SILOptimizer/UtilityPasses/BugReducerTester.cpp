//===--- BugReducerTester.cpp ---------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//
///
/// \file
///
/// This pass is a testing pass for sil-bug-reducer. It asserts when it visits a
/// function that calls a function specified by an toolchain::cl::opt.
///
//===----------------------------------------------------------------------===//

#include "language/Basic/Assertions.h"
#include "language/SIL/SILBuilder.h"
#include "language/SIL/SILFunction.h"
#include "language/SILOptimizer/Utils/SILOptFunctionBuilder.h"
#include "language/SIL/SILInstruction.h"
#include "language/SIL/ApplySite.h"
#include "language/SIL/SILLocation.h"
#include "language/SIL/SILUndef.h"
#include "language/SILOptimizer/PassManager/Passes.h"
#include "language/SILOptimizer/PassManager/Transforms.h"
#include "toolchain/Support/CommandLine.h"

using namespace language;

static toolchain::cl::opt<std::string> FunctionTarget(
    "bug-reducer-tester-target-fn",
    toolchain::cl::desc("Function that when called by an apply should cause "
                   "BugReducerTester to blow up or miscompile if the pass "
                   "visits the apply"));

namespace {
enum class FailureKind {
  OptimizerCrasher,
  RuntimeMiscompile,
  RuntimeCrasher,
  None
};
} // end anonymous namespace

static toolchain::cl::opt<FailureKind> TargetFailureKind(
    "bug-reducer-tester-failure-kind",
    toolchain::cl::desc("The type of failure to perform"),
    toolchain::cl::values(
        clEnumValN(FailureKind::OptimizerCrasher, "opt-crasher",
                   "Crash the optimizer when we see the specified apply"),
        clEnumValN(FailureKind::RuntimeMiscompile, "miscompile",
                   "Delete the target function call to cause a runtime "
                   "miscompile that is not a crasher"),
        clEnumValN(FailureKind::RuntimeCrasher, "runtime-crasher",
                   "Delete the target function call to cause a runtime "
                   "miscompile that is not a crasher")),
    toolchain::cl::init(FailureKind::None));


TOOLCHAIN_ATTRIBUTE_NOINLINE
void THIS_TEST_IS_EXPECTED_TO_CRASH_HERE() {
  toolchain_unreachable("Found the target!");
}

namespace {

class BugReducerTester : public SILFunctionTransform {

  // We only want to cause 1 miscompile.
  bool CausedError = false;
  StringRef RuntimeCrasherFunctionName = "bug_reducer_runtime_crasher_func";

  SILFunction *getRuntimeCrasherFunction() {
    assert(TargetFailureKind == FailureKind::RuntimeCrasher);
    toolchain::SmallVector<SILResultInfo, 1> ResultInfoArray;
    auto EmptyTupleCanType = getFunction()
                                 ->getModule()
                                 .Types.getEmptyTupleType()
                                 .getASTType();
    ResultInfoArray.push_back(
        SILResultInfo(EmptyTupleCanType, ResultConvention::Unowned));
    auto FuncType = SILFunctionType::get(
        nullptr, SILFunctionType::ExtInfo::getThin(), SILCoroutineKind::None,
        ParameterConvention::Direct_Unowned, ArrayRef<SILParameterInfo>(),
        ArrayRef<SILYieldInfo>(), ResultInfoArray, std::nullopt,
        SubstitutionMap(), SubstitutionMap(),
        getFunction()->getModule().getASTContext());

    SILOptFunctionBuilder FunctionBuilder(*this);
    SILFunction *F = FunctionBuilder.getOrCreateSharedFunction(
        RegularLocation::getAutoGeneratedLocation(), RuntimeCrasherFunctionName,
        FuncType, IsBare, IsNotTransparent, IsSerialized, ProfileCounter(),
        IsNotThunk, IsNotDynamic, IsNotDistributed, IsNotRuntimeAccessible);
    if (F->isDefinition())
      return F;

    // Create a new block.
    SILBasicBlock *BB = F->createBasicBlock();

    // Insert a builtin int trap. Then return F.
    SILBuilder B(BB);
    B.createUnconditionalFail(RegularLocation::getAutoGeneratedLocation(),
                              "bug reducer crash");
    B.createUnreachable(ArtificialUnreachableLocation());
    return F;
  }

  void run() override {
    // If we don't have a target function or we already caused a miscompile,
    // just return.
    if (FunctionTarget.empty() || CausedError)
      return;
    assert(TargetFailureKind != FailureKind::None);
    for (auto &BB : *getFunction()) {
      for (auto II = BB.begin(), IE = BB.end(); II != IE;) {
        // Skip try_apply. We do not support them for now.
        if (isa<TryApplyInst>(&*II)) {
          ++II;
          continue;
        }

        auto FAS = FullApplySite::isa(&*II);
        if (!FAS) {
          ++II;
          continue;
        }

        auto *FRI = dyn_cast<FunctionRefInst>(FAS.getCallee());
        if (!FRI || FRI->getReferencedFunction()->getName() != FunctionTarget) {
          ++II;
          continue;
        }

        // Ok, we found the Apply that we want! If we are asked to crash, crash
        // here.
        if (TargetFailureKind == FailureKind::OptimizerCrasher)
          THIS_TEST_IS_EXPECTED_TO_CRASH_HERE();

        // Otherwise, if we are asked to perform a runtime time miscompile,
        // delete the apply target.
        if (TargetFailureKind == FailureKind::RuntimeMiscompile) {
          // Ok, we need to insert a runtime miscompile. Move II to
          // the next instruction and then replace its current value
          // with undef.
          auto *Inst = cast<SingleValueInstruction>(&*II);
          Inst->replaceAllUsesWith(SILUndef::get(Inst));
          Inst->eraseFromParent();

          // Mark that we found the miscompile and return so we do not try to
          // visit any more instructions in this function.
          CausedError = true;
          return;
        }

        assert(TargetFailureKind == FailureKind::RuntimeCrasher);
        // Finally, if we reach this point we are being asked to replace the
        // given apply with a new apply that calls the crasher fn.
        auto Loc = RegularLocation::getAutoGeneratedLocation();
        SILFunction *RuntimeCrasherFunc = getRuntimeCrasherFunction();
        toolchain::dbgs() << "Runtime Crasher Func!\n";
        RuntimeCrasherFunc->dump();
        SILBuilder B(II);
        B.createApply(Loc, B.createFunctionRef(Loc, RuntimeCrasherFunc),
                      SubstitutionMap(),
                      ArrayRef<SILValue>());

        auto *Inst = cast<SingleValueInstruction>(&*II);
        ++II;
        Inst->replaceAllUsesWith(SILUndef::get(Inst));
        Inst->eraseFromParent();

        CausedError = true;
        return;
      }
    }
  }
};

} // end anonymous namespace

SILTransform *language::createBugReducerTester() { return new BugReducerTester(); }
