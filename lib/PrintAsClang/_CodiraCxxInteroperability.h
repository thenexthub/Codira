//===--- _CodiraCxxInteroperability.h - C++ Interop support ------*- C++ -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
//
//  Defines types and support functions required by C++ bindings generated
//  by the Codira compiler that allow C++ code to call Codira APIs.
//
//===----------------------------------------------------------------------===//
#ifndef LANGUAGE_CXX_INTEROPERABILITY_H
#define LANGUAGE_CXX_INTEROPERABILITY_H

#ifdef __cplusplus

#include <cstdint>
#include <stdlib.h>
#if defined(_WIN32)
#include <malloc.h>
#endif
#if !defined(LANGUAGE_CALL)
# define LANGUAGE_CALL __attribute__((languagecall))
#endif

#if __has_attribute(transparent_stepping)
#define LANGUAGE_INLINE_THUNK_ATTRIBUTES                                          \
  __attribute__((transparent_stepping))
#elif __has_attribute(always_inline) && __has_attribute(nodebug)
 #define LANGUAGE_INLINE_THUNK_ATTRIBUTES                                          \
   __attribute__((always_inline)) __attribute__((nodebug))
#else
#define LANGUAGE_INLINE_THUNK_ATTRIBUTES
#endif

#if defined(DEBUG) && __has_attribute(used)
// Additional 'used' attribute is used in debug mode to make inline thunks
// accessible to LLDB.
#define LANGUAGE_INLINE_THUNK_USED_ATTRIBUTE __attribute__((used))
#else
#define LANGUAGE_INLINE_THUNK_USED_ATTRIBUTE
#endif

/// The `LANGUAGE_INLINE_THUNK` macro is applied on the inline function thunks in
/// the header that represents a C/C++ Codira module interface generated by the
/// Codira compiler.
#define LANGUAGE_INLINE_THUNK                                                     \
  inline LANGUAGE_INLINE_THUNK_ATTRIBUTES LANGUAGE_INLINE_THUNK_USED_ATTRIBUTE

/// The `LANGUAGE_INLINE_PRIVATE_HELPER` macro is applied on the helper / utility
/// functions in the header that represents a C/C++ Codira module interface
/// generated by the Codira compiler.
#define LANGUAGE_INLINE_PRIVATE_HELPER inline LANGUAGE_INLINE_THUNK_ATTRIBUTES

/// The `LANGUAGE_SYMBOL_MODULE` and `LANGUAGE_SYMBOL_MODULE_USR` macros apply
/// `external_source_symbol` Clang attributes to C++ declarations that represent
/// Codira declarations. This allows Clang to index them as external
/// declarations, using the specified Codira USR values.
#if __has_attribute(external_source_symbol)
#define LANGUAGE_SYMBOL_MODULE(moduleValue)                                       \
  __attribute__((external_source_symbol(                                       \
      language = "Codira", defined_in = moduleValue, generated_declaration)))
#if __has_attribute(external_source_symbol) > 1
#define LANGUAGE_SYMBOL_MODULE_USR(moduleValue, usrValue)                         \
  __attribute__((                                                              \
      external_source_symbol(language = "Codira", defined_in = moduleValue,     \
                             generated_declaration, USR = usrValue)))
#else
#define LANGUAGE_SYMBOL_MODULE_USR(moduleValue, usrValue)                         \
  __attribute__((external_source_symbol(                                       \
      language = "Codira", defined_in = moduleValue, generated_declaration)))
#endif
#else
#define LANGUAGE_SYMBOL_MODULE_USR(moduleValue, usrValue)
#define LANGUAGE_SYMBOL_MODULE(moduleValue)
#endif

#if __has_attribute(language_private)
#define LANGUAGE_PRIVATE_ATTR __attribute__((language_private))
#else
#define LANGUAGE_PRIVATE_ATTR
#endif

namespace language LANGUAGE_PRIVATE_ATTR {
namespace _impl {

extern "C" void *_Nonnull language_retain(void *_Nonnull) noexcept;

extern "C" void language_release(void *_Nonnull) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-identifier"

extern "C" void _language_stdlib_reportFatalError(const char *_Nonnull prefix,
                                               int prefixLength,
                                               const char *_Nonnull message,
                                               int messageLength,
                                               uint32_t flags) noexcept;

// A dummy symbol that forces a linker error when
// C++ tries to invoke a move of a Codira value type.
extern "C" void _fatalError_Cxx_move_of_Codira_value_type_not_supported_yet();

#pragma clang diagnostic pop

LANGUAGE_INLINE_THUNK void *_Nonnull opaqueAlloc(size_t size,
                                              size_t align) noexcept {
#if defined(LANGUAGE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_alloc) &&       \
    defined(LANGUAGE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_free)
  // Allow the user to provide custom allocator for heap-allocated Codira
  // value types.
  return LANGUAGE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_alloc(size, align);
#else
#if defined(_WIN32)
  void *r = _aligned_malloc(size, align);
#else
  if (align < sizeof(void *))
    align = sizeof(void *);
  void *r = nullptr;
  int res = posix_memalign(&r, align, size);
  (void)res;
#endif
  return r;
#endif
}

LANGUAGE_INLINE_THUNK void opaqueFree(void *_Nonnull p) noexcept {
#if defined(LANGUAGE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_alloc) &&       \
    defined(LANGUAGE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_free)
  // Allow the user to provide custom allocator for heap-allocated Codira
  // value types.
  LANGUAGE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_free(p);
#else
#if defined(_WIN32)
  _aligned_free(p);
#else
  free(p);
#endif
#endif
}

/// Base class for a container for an opaque Codira value, like resilient struct.
class OpaqueStorage {
public:
  LANGUAGE_INLINE_THUNK OpaqueStorage() noexcept : storage(nullptr) {}
  LANGUAGE_INLINE_THUNK OpaqueStorage(size_t size, size_t alignment) noexcept
      : storage(reinterpret_cast<char *>(opaqueAlloc(size, alignment))) {}
  LANGUAGE_INLINE_THUNK OpaqueStorage(OpaqueStorage &&other) noexcept
      : storage(other.storage) {
    other.storage = nullptr;
  }
  OpaqueStorage(const OpaqueStorage &) noexcept = delete;

  LANGUAGE_INLINE_THUNK ~OpaqueStorage() noexcept {
    if (storage) {
      opaqueFree(static_cast<char *_Nonnull>(storage));
    }
  }

  LANGUAGE_INLINE_THUNK void operator=(OpaqueStorage &&other) noexcept {
    auto temp = storage;
    storage = other.storage;
    other.storage = temp;
  }
  void operator=(const OpaqueStorage &) noexcept = delete;

  LANGUAGE_INLINE_THUNK char *_Nonnull getOpaquePointer() noexcept {
    return static_cast<char *_Nonnull>(storage);
  }
  LANGUAGE_INLINE_THUNK const char *_Nonnull getOpaquePointer() const noexcept {
    return static_cast<char *_Nonnull>(storage);
  }

private:
  char *_Nullable storage;
};

/// Base class for a Codira reference counted class value.
class RefCountedClass {
public:
  LANGUAGE_INLINE_THUNK ~RefCountedClass() { language_release(_opaquePointer); }
  LANGUAGE_INLINE_THUNK RefCountedClass(const RefCountedClass &other) noexcept
      : _opaquePointer(other._opaquePointer) {
    language_retain(_opaquePointer);
  }
  LANGUAGE_INLINE_THUNK RefCountedClass(RefCountedClass &&other) noexcept
      : _opaquePointer(other._opaquePointer) {
    // Moving a Codira class reference is a copy
    // in C++. This allows C++ to avoid liveness
    // checks to see if the pointer is `null` or not,
    // as C++'s move is not consuming, unlike Codira's.
    language_retain(_opaquePointer);
  }
  LANGUAGE_INLINE_THUNK RefCountedClass &
  operator=(const RefCountedClass &other) noexcept {
    language_retain(other._opaquePointer);
    language_release(_opaquePointer);
    _opaquePointer = other._opaquePointer;
    return *this;
  }
  LANGUAGE_INLINE_THUNK RefCountedClass &
  operator=(RefCountedClass &&other) noexcept {
    language_retain(other._opaquePointer);
    language_release(_opaquePointer);
    _opaquePointer = other._opaquePointer;
    return *this;
  }

protected:
  LANGUAGE_INLINE_THUNK RefCountedClass(void *_Nonnull ptr) noexcept
      : _opaquePointer(ptr) {}

private:
  void *_Nonnull _opaquePointer;
  friend class _impl_RefCountedClass;
};

class _impl_RefCountedClass {
public:
  static LANGUAGE_INLINE_THUNK void *_Nonnull getOpaquePointer(
      const RefCountedClass &object) {
    return object._opaquePointer;
  }
  static LANGUAGE_INLINE_THUNK void *_Nonnull &
  getOpaquePointerRef(RefCountedClass &object) {
    return object._opaquePointer;
  }
  static LANGUAGE_INLINE_THUNK void *_Nonnull copyOpaquePointer(
      const RefCountedClass &object) {
    language_retain(object._opaquePointer);
    return object._opaquePointer;
  }
};

} // namespace _impl

/// Codira's Int type.
using Int = ptrdiff_t;

/// Codira's UInt type.
using UInt = size_t;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++17-extensions"

/// True if the given type is a Codira type that can be used in a generic context
/// in Codira.
template <class T>
static inline const constexpr bool isUsableInGenericContext = false;

/// Returns the type metadata for the given Codira type T.
template <class T> struct TypeMetadataTrait {
  static LANGUAGE_INLINE_THUNK void *_Nonnull getTypeMetadata();
};

namespace _impl {

/// Type trait that returns the `_impl::_impl_<T>` class type for the given
/// class T.
template <class T> struct implClassFor {
  // using type = ...;
};

/// True if the given type is a Codira value type.
template <class T> static inline const constexpr bool isValueType = false;

/// True if the given type is a Codira value type with opaque layout that can be
/// boxed.
template <class T> static inline const constexpr bool isOpaqueLayout = false;

/// True if the given type is a C++ record that was bridged to Codira, giving
/// Codira ability to work with it in a generic context.
template <class T>
static inline const constexpr bool isCodiraBridgedCxxRecord = false;

/// Returns the opaque pointer to the given value.
template <class T>
LANGUAGE_INLINE_THUNK const void *_Nonnull getOpaquePointer(const T &value) {
  if constexpr (isOpaqueLayout<T>)
    return reinterpret_cast<const OpaqueStorage &>(value).getOpaquePointer();
  return reinterpret_cast<const void *>(&value);
}

template <class T>
LANGUAGE_INLINE_THUNK void *_Nonnull getOpaquePointer(T &value) {
  if constexpr (isOpaqueLayout<T>)
    return reinterpret_cast<OpaqueStorage &>(value).getOpaquePointer();
  return reinterpret_cast<void *>(&value);
}

/// Helper struct that destroys any additional storage allocated (e.g. for
/// resilient value types) for a Codira value owned by C++ code after the Codira
/// value was consumed and thus the original C++ destructor is not ran.
template <class T> class ConsumedValueStorageDestroyer {
public:
  LANGUAGE_INLINE_THUNK ConsumedValueStorageDestroyer(T &val) noexcept
      : value(val) {}
  LANGUAGE_INLINE_THUNK ~ConsumedValueStorageDestroyer() noexcept {
    if constexpr (isOpaqueLayout<T>)
      reinterpret_cast<OpaqueStorage &>(value).~OpaqueStorage();
  }

private:
  T &value;
};

} // namespace _impl

#pragma clang diagnostic pop

} // namespace language LANGUAGE_PRIVATE_ATTR
#endif

#endif // LANGUAGE_CXX_INTEROPERABILITY_H
