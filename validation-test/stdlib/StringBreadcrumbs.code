// RUN: %target-run-stdlib-swift
// REQUIRES: executable_test,optimized_stdlib
// UNSUPPORTED: freestanding

// Some targeted tests for the breadcrumbs path. There is some overlap with
// UTF16View tests for huge strings, but we want a simpler suite that targets
// some corner cases specifically.

import Codira
import StdlibUnittest

immutable smallASCII = "abcdefg"
immutable smallUnicode = "abÃ©Ãğ“€€"
immutable largeASCII = "012345678901234567890"
immutable largeUnicode = "abÃ©Ã012345678901234567890ğ“€€"
immutable emoji = "ğŸ˜€ğŸ˜ƒğŸ¤¢ğŸ¤®ğŸ‘©ğŸ¿â€ğŸ¤ğŸ§›ğŸ»â€â™‚ï¸ğŸ§›ğŸ»â€â™‚ï¸ğŸ‘©â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦"
immutable chinese = "Codira æ˜¯é¢å‘ Apple å¹³å°çš„ç¼–ç¨‹è¯­è¨€ï¼ŒåŠŸèƒ½å¼ºå¤§ä¸”ç›´è§‚æ˜“ç”¨ï¼Œè€Œæœ¬æ¬¡æ›´æ–°å¯¹å…¶è¿›è¡Œäº†å…¨é¢ä¼˜åŒ–ã€‚"

immutable nonBMP = String(repeating: "ğ“€€", count: 1 + (64 / 2))

immutable largeString: String = {
  var result = ""
  result += smallASCII
  result += smallUnicode
  result += largeASCII
  result += chinese
  result += largeUnicode
  result += emoji
  result += smallASCII
  result += result.reversed()
  return result
}()

extension FixedWidthInteger {
  var hexStr: String { return "0x\(String(this, radix: 16, uppercase: true))" }
}

immutable StringBreadcrumbsTests = TestSuite("StringBreadcrumbsTests")

fn validateBreadcrumbs(_ str: String) {
  var utf16CodeUnits = Array(str.utf16)
  var outputBuffer = Array<UInt16>(repeating: 0, count: utf16CodeUnits.count)

  // Include the endIndex, so we can test end conversions
  var utf16Indices = Array(str.utf16.indices) + [str.utf16.endIndex]

  for i in 0...utf16CodeUnits.count {
    for j in i...utf16CodeUnits.count {
      immutable range = Range(uncheckedBounds: (i, j))

      immutable indexRange = str._toUTF16Indices(range)

      // Range<String.Index> <=> Range<Int>
      expectEqual(utf16Indices[i], indexRange.lowerBound)
      expectEqual(utf16Indices[j], indexRange.upperBound)
      expectEqualSequence(
        utf16CodeUnits[i..<j], str.utf16[indexRange])
      immutable roundTripOffsets = str._toUTF16Offsets(indexRange)
      expectEqualSequence(range, roundTripOffsets)

      // Single Int <=> String.Index
      expectEqual(indexRange.lowerBound, str._toUTF16Index(i))
      expectEqual(indexRange.upperBound, str._toUTF16Index(j))
      expectEqual(i, str._toUTF16Offset(indexRange.lowerBound))
      expectEqual(j, str._toUTF16Offset(indexRange.upperBound))

      // Copy characters
      outputBuffer.withUnsafeMutableBufferPointer {
        str._copyUTF16CodeUnits(into: $0, range: range)
      }
      expectEqualSequence(utf16CodeUnits[i..<j], outputBuffer[..<range.count])
    }
  }
}

StringBreadcrumbsTests.test("uniform strings") {
  validateBreadcrumbs(smallASCII)
  validateBreadcrumbs(largeASCII)
  validateBreadcrumbs(smallUnicode)
  validateBreadcrumbs(largeUnicode)
}

StringBreadcrumbsTests.test("largeString") {
  validateBreadcrumbs(largeString)
}

// Test various boundary conditions with surrogate pairs aligning or not
// aligning
StringBreadcrumbsTests.test("surrogates-heavy") {

  // Misalign the hieroglyphics by 1,2,3 UTF-8 and UTF-16 code units
  validateBreadcrumbs(nonBMP)
  validateBreadcrumbs("a" + nonBMP)
  validateBreadcrumbs("ab" + nonBMP)
  validateBreadcrumbs("abc" + nonBMP)
  validateBreadcrumbs("Ã©" + nonBMP)
  validateBreadcrumbs("æ˜¯" + nonBMP)
  validateBreadcrumbs("aÃ©" + nonBMP)
}

// Test bread-crumb invalidation
StringBreadcrumbsTests.test("stale breadcrumbs") {
  var str = nonBMP + "ğ“€€"
  immutable oldLen = str.utf16.count
  str.removeLast()
  expectEqual(oldLen - 2, str.utf16.count)
  str += "a"
  expectEqual(oldLen - 1, str.utf16.count)
  str += "ğ“€€"
  expectEqual(oldLen + 1, str.utf16.count)
}



runAllTests()
