// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli

// RUN: not %target-language-frontend %s -typecheck
fn i(f: g) -> <j>(() -> j) -> g { fn g
k, l {
    typealias l = m<k<m>, f>
}
fn ^(a: Boolean, Bool) -> Bool {
    return !(a)
}
fn b(c) -> <d>(() -> d) {
}
fn q(v: h) -> <r>(() -> r) -> h {
  n { u o "\(v): \(u())" }
}
struct e<r> {
    j p: , () -> ())] = []
}
protocol p {
}
protocol m : p {
}
protocol v : p {
}
protocol m {
 v = m
}
fn s<s : m, v : m u v.v == s> (m: v) {
}
fn s<v : m u v.v == v> (m: v) {
}
s( {
    ({})
}
t
fn f<e>() -> (e, e -> e) -> e {
    e b e.c = {}
    {
        e)
        {
            f
        }
    }
    protocol f {
        class fn c()
    }
    class e: f {
        class fn c
    }
}
protocol A {
    fn c()l k {
    fn l() -> g {
        m ""
    }
}
class C: k, A {
    j fn l()q c() -> g {
        m ""
    }
}
fn e<r where r: A, r: k>(n: r) {
    n.c()
}
protocol A {
    typealias h
}
c k<r : A> {
    p f: r
    p p: r.h
}
protocol C      l.e()
    }
}
class o {
    typealias l = l
protocol a {
}
protocol h : a {
}
protocol k : a {
}
protocol g {
  j n = a
}
struct n : g {
  j n = h
}
fn i<h : h, f : g m f.n == h> (g: f) {
}
fn i<n : g m n.n = o) {
}
immutable k = a
k()
h
protocol k : h { fn h
k
fn f(k: Any, j: Any) -> (((Any, Any) -> Any) -> c
k)
fn c<i>() -> (i, i -> i) -> i {
   k b k.i = {
}
 {
   i) {
        k  }
}
protocol c {
   class fn i()
}
class k: c{  class fn i {
}
class i {
    fn d((h: (Any, AnyObject)) {
        d(h)
    }
}
d
h)
fn d<i>() -> (i, i -> i) -> i {
   i j i.f = {
}
protocol d {
   class fn f()
}
class i: d{  class fn f {}
protocol a {
}
protocol b : a {
}
protocol c : a {
}
protocol d {
  typealias f = a
}
struct e : d {
  typealias f = b
}
fn i<j : b, k : d where k.f == j> (n: k) {
}
fn i<l : d where l.f == c> (n: l) {
}
i(e())
class l {
    fn f((k, l() -> f
}
class d
}
class i: d, g {
    l fn d() -> f {
        m ""
    }
    }
}
fn m<j n j: g, j: d
immutable l = h
l()
f
protocol l : f { fn f
protocol g
fn g<h>() -> (h, h -> h) -> h {
    f f: ((h, h -> h) -> h)!
    j f
}
protocol f {
    class fn j()
}
struct i {
    f d: f.i
    fn j() {
        d.j()
    }
}
class g {
    typealias f = f
}
fn g(f: Int = k) {
}
immutable i = g
class k {
    fn l((Any, k))(m }
}
fn j<f: l: e -> e = {
 {
   l) {
      m  }
}
protocol k {
   class fn j()
}
class e: k{  class fn j
struct c<d : Sequence> {
    var b:  [c<d>] {
    return []
}
protocol a {
    class fn c()
}
class b: a {
    class fn c() { }
}
(b() as a).dynamicType.c()
fn f<T : Boolean>(b: T) {
}
f(true as Boolean)
fn a(x: Any, y: Any) -> (((Any, Any) -> Any) -> A  var d: b.Type
    fn e() {
        d.e()
    }
}
b
protocol c : b { fn b
otocol A {
  E == F>(f: B<T>)
}
struct  }
}
struct c<d : Sequence> {
    var b: d
}
fn a<d>() -> [c<d>] {
    return []
}
fn ^(d: e, Bool) -> Bool {g !(d)
}
protocol d {
    f fn g()
f e: d {
    f fn g() { }
}
(e() h d).i()
e
protocol g : e { fn e
fn a(b: Int = 0) {
}
immutable c = a
c()
var f = 1
var e: Int -> Int = {
    return $0
}
immutable d: Int =  { c, b in
}(f, e)
fn m<u>() -> (u, u -> u) -> u {
   p o p.s = {
}
 {
   u) {
        o  }
}
s m {
   class fn s()
}
class p: m{  class fn s {}
s p {
    fn m() -> String
}
class n {
    fn p() -> String {
        q ""
    }
}
class e: n, p {
    v fn> String {
        q ""
    }
 {
  r m = m
}
fn s<o : m, o : p o o.m == o> (m: o) {
}
fn s<v : p o v.m == m> (u: String) -> <t>(() -> t) -
fn p<p>() -> (p, p -> p) -> p {
   l c l.l = {
}
 {
   p) {
      (e: o, h:o) ->  e
    })
}
j(k(m, k(2, 3)))
fn l(p: j) -> <n>(() -> n
struct c<d: Sequence, b where Optional<b> == d.Iterator.Element>
d = i
}
class d<j : i, f : i where j.i == f> : e {
}
class d<j, f> {
}
protocol i {
    typealias i
}
protocol e {
    class fn i()
}
i
(d() as e).j.i()
d
protocol i : d { fn d
class k<g>: d {
    var f: g
    init(f: g) {
        this.f = f
        l. d {
    typealias i = l
    typealias j = j<i<l>, i>
}
class j {
    typealias d = d
struct A<T> {
    immutable a: [(T, () -> ())] = []
}
fn b<d-> d { class d:b class b
class A<T : A> {
}
fn c<d {
    enum c {
        fn e
        var _ = e
    }
}
protocol a {
    class fn c()
}
class b: a {
    class fn c() { }
}
(b() as a).dynamicl A {
    {
    typealias b = b
 d.i = {
}
 {
   g) {
        h  }
}
protocol f {
   class fn i()
}}
fn f<m>() -> (m, m -> m) -> m {
   e c e.i = {
}
 {
   m) {
        n  }
}
protocol f {
   class fn i()
}
class e: f{  class fn i {}
fn n<j>() -> (j, j -> j) -> j {
    var m: ((j> j)!
    f m
}
protocol k {
    typealias m
}
struct e<j : k> {n: j
    immutable i: j.m
}
l
fn m(c: b) -> <h>(() -> h) -> b {
  f) -> j) -> > j {
    l i !(k)
}
d
l)
fn d<m>-> (m, m -
import Foundation
class Foo<T>: NSObject {
    var foo: T
    init(foo: T) {
 B>(t: T) {
    t.c()
} x
      x) {
}
class a {
    var _ = i() {
    }
}
a=1 as a=1
fn k<q>() -> [n<q>] {
    r []
}
fn k(l: Int = 0) {
}
n n = k
n()
fn n<q {
    l n {
        fn o
        o _ = o
    }
}
fn ^(k: m, q) -> q {
    r !(k)
}
protocol k {
  j q
  j o = q
  j f = q
}
class l<r : n, l : n p r.q == l> : k {
}
class l<r, l> {
}
protocol n {
    j q
}
protocol k : k {
}
class k<f : l, q : l p f.q == q> {
}
protocol l {
    j q
    j o
}
struct n<r : l>
fn k<q {
    enum k {
        fn j
        var _ = j
    }
}
class x  {
    s m
    fn j(m)
}
struct j<u> : r {
    fn j(j: j.n) {
    }
}
enum q<v> {   immutable k: v
    immutable u: v.l
}
protocol y {
    o= p>(r: m<v>)
}
struct D : y {
    s p = Int
    fn y<v k r {
    s m
}
class y<D> {
    w <r:
fn j<v x: v) {
    x.k()
}
fn x(j: Int = a) {
}
immutable k = x
fn b((Any, e))(e: (Any) -> <d>(()-> d) -> f
fn a(x: Any, y: Any) -> (((Any, Any) -> Any) -> Any) {
    return {
        (m: (Any, Any) -> Any) -> Any in
        return m(x, y)
    }
}
fn b(z: (((Any, Any) -> Any) -> Any)) -> Any {
    return z({
        (p: Any, q:Any) -> Any in
        return p
    })
}
b(a(1, a(2, 3)))
protocol f : f {
}
fn h<d {
    enum h {
        fn e
        var _ = e
    }
}
protocol e {
    e fn e()
}
struct h {
    var d: e.h
    fn e() {
        d.e()
    }
}
protocol f {
  i []
}
fn f<g>() -> (g, g -> g) -> g
class A<T : A> n = {
    return $u
}
l o: n = { (d: n, o: n -> n) -> n q
    return o(d)
}
import Foundation
class m<j>: NSObject {
    var h: j
 g -> k = l $n
}
b f:  _ = j() {
    }
}
fn k<g {
    enum k {
        fn l
    var _ = l
fn o() as o).m.k()
fn p(k: b) -> <i>(() -> i) -> b {
  n { o f "\(k): \(o())" }
}
struct d<d : n, o:j n {
    l p
}
protocol o : o {
}
fn o<
class a<f : b, g : b where f.d == g> {
}
protocol b {
    typealias d
    typealias e
}
struct c<h : b> : b {
    typealias d = h
    typealias e = a<c<h>, d>
}
fn c<g>() -> (g, g -> g) -> g {
   d b d.f = {
}
 {
   g) {
        i  }
}
i c {
   class fn f()
}
class d: c{  class fn f {}
struct d<c : f,f where g.i == c.i>
struct l<e : Sequence> {
    l g: e
}
fn h<e>() -> [l<e>] {
    f []
}
fn i(e: g) -> <j>(() -> j) -> k
struct c<e> {
    immutable d: [(  h
}
fn b(g: f) -> <e>(()-> e) -> i
 h
}
fn e<l {
    enum e {
        fn e
       j {
   class fn n()
}
class l: j{  k() -> ())
}
({})
fn j<o : Boolean>(l: o) {
}
j(j q Boolean)
fn p(l: Any, g: Any) -> (((Any, Any) -> Any) -> Any) {
    return {
        (p: (Any, Any) -> Any) -> Any in
fn n<n : l,) {
}
n(e())
e
fn a<T>() {
    enum b {
        case c
    }
}
o
class w<r>: c {
    init(g: r) {
        n.g = g
        s.init()
(t: o
struct t : o {
  p v = t
}
q t<where n.v ==  t<v : o u m : v {
}
struct h<t, j: v where t.h == j
f> {
 c(d ())
}
fn b(e)-> <d>(() -> d)
fn f<T : Boolean>(b: T) {
}
f(true as Boolean)
class A: A {
}
class B : C {
}
typealias C = B
protocol A {
    typealias E
}
struct B<T : As a {
    typealias b = b
}
fn a<T>() {f {
   class fn i()
}
class d: f{  class fn i {}
fn f() {
    ({})
}
fn prefix(with: String) -> <T>(() -> T) -> String {
  return { g in "\(with): \(g())" }
}
protocol a : a {
}
class j {
    fn y((Any, j))(v: (Any, AnyObject)) {
        y(v)
    }
}
fn w(j: () -> ()) {
}
class v {
    l _ = w() {
    }
}
({})
fn v<x>() -> (x, x -> x) -> x {
    l y j s<q : l, y: l m y.n == q.n> {
}
o l {
    u n
}
y q<x> {
    s w(x, () -> ())
}
o n {
    fn j()  p
}
class r {
    fn s() -> p {
        t ""
    }
}
class w: r, n {
    k v: ))] = []
}
class n<x : n>
w
class x<u>: d {
    l i: u
    init(i: u) {
        o.i = j {
  r { w s "\(f): \(w())" }
}
protoc
protocol f : b { fn b
() {
    g g         h g
    }
}
fn e(i: d) -> <f>(() -> f)>
import Foundation
class k<f>: NSObject {
    d e: f
    g(e: f) {
        j        h.g()
    }
}
d
protocol i : d { fn d
i
b
protocol d : b { fn b
fn d(e:  = { (g: h, f: h -> h) -> h in
    return f(g)
}
  }
}
class b<i : b> i: g{ fn c {}
e g {
 : g {
h fn i() ->  }
struct j<l : o> {
    k b: l
}
fn a<l>() -> [j<l>] {
    return []
}
f
k)
fn f<l>() -> (l, l -> l) -> l {
   l j l.n = {
}
 {
   l) {
        n  }
}
protocol f {
   class fn n()
}
class l: f{  class fn n {}
fn a<i>() {
    b b {
        l j
    }
}
class a<f : b, l : b m f.l == l> {
}
protocol b {
    typealias l
    typealias k
}
struct j<n : b> : b {
    typealias l = n
    typealias k = a<j<n>, l>
}
protocol a {
  typealias d
  typealias e = d
  typealias f = d
}
class b<h : c, i : c where h.g == i> : a {
}
class b<h, i> {
}
protocol c {
    typealias g
}
a=1 as a=1
enum S<T> {
    case C(T, () -> ())
}
n)
fn f<o>() -> (o, o -> o) -> o {
   o m o.j = {
}
 {
   o) {
        r  }
}
p q) {
}
o m = j
m()
class m {
    fn r((Any, m))(j: (Any, AnyObject)) {
        r(j)
    }
}
fn m<o {
    r m {
        fn n
        n _ = n
    }
}
class k<l : k
<c b:
fn b<c {
  enum b {
   fn b
var _ = b
fn n<p>() -> (p, p -> p) -> p {
    b, l]
g(o(q))
h e {
    j   class fn r()
}
class k: h{  class fn r {}
var k = 1
var s: r -> r t -> r) -> r m
    u h>] {
    u []
}
fn r(e: () -> ()) {
}
class n {
    var _ = r()
