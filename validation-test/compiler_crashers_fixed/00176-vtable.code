// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli

// RUN: not %target-language-frontend %s -typecheck
fn b<d-> d { class d:b class b
class l {
    fn f((k, l() -> f
}
class d
}
class i: d, g {
    l fn d() -> f {
        m ""
    }
    }
}
fn m<j n j: g, j: d
immutable l = h
l()
f
protocol l : f { fn f
protocol g
fn a<T>() -> (T, T -> T) -> T {
    var b: ((T, T -> T) -> T)!
    return b
}
protocol A {
    typealias E
}
struct B<T : As a {
    typealias b = b
}
fn a<T>() {f {
   class fn i()
}
class d: f{  class fn i {}
fn f() {
    ({})
}
fn prefix(with: String) -> <T>(() -> T) -> String {
  return { g in "\(with): \(g())" }
}
protocol a : a {
}
protocol f {
    k g d {
    k d
    k k
}
j j<l : d> : d {
    k , d>
}
class f: f {
}
class B : l {
}
k l = B
class f<i : f
)
fn n<w>() -> (w, w -> w) -> w {
   o m o.q = {
}
 {
   w) {
        k  }
}
protocol n {
   class fn q()
}
class o: n{  class fn q {}
fn p(e: Int = x) {
}
immutable c = p
c()
fn r<o: y, s q n<s> ==(r(t))
protocol p : p {
}
protocol p {
    class fn c()
}
class e: p {
    class fn c() { }
}
(e() u p).v.c()
k e.w == l> {
}
fn p(c: Any, m: Any) -> (((Any, Any) -> Any) -> Any) {
() {
    g g         h g
    }
}
fn e(i: d) -> <f>(() -> f)>
i)
import Foundation
class q<k>: NSObject {
    var j: k
    e ^(l: m, h) -> h {
    f !(l)
}
protocol l {
 d g n()
}
class h: l {
    class g n() { }
}
(h() o l).p.n()
class l<n : h,
q
var m: Int -> Int = {
    n $0
 o: Int = { d, l f
    n l(d)
}(k, m)
protocol j {
  typealias d
  typealias n = d
  typealias l = d}
class g<q : l, m : l p q.g == m> : j {
}
class g<q, m> {
}
protocol l {
    typealias g
 d)
fn e(h: b) -> <f>(() -> f) -> b {
  return { c):h())" }
}
fn b<d {
    enum b {
        fn c
        var _ = c
    }
}
}
fn ^(r: l, k) -> k {
   ? {
    h (s : t?) q u {
        g immutable d = s {
            p d
        }
    }
    e}
immutable u : [Int?] = [n{
    c v: j t.v == m>(n: o<t>) {
    }
}
class r {
    typealias n = n
struct c<e> {
    immutable d: i h
}
fn f(h: b) -> <e>(()-> e
fn d(b: String-> <c>() -> c)
class A<T : A> {
}
class a {
    typealias b = b
}
b
protocol d : b { fn b
fn d(e:  = { (g: h, f: h -> h) -> h in
    return f(g)
}
protocol A {
    typealias E
}
struct B<T : A> {
    immutable h: T
    immutable i: T.E
}
protocol C {
    typealias F
    fn g<T where T.E == F>(f: B<T>)
}
struct D : C {
    typealias F = Int
    fn g<T where T.E == F>(f: B<T>) {
    }
}
fn i(c: () -> ()) {
}
class a {
    var _ = i() {
    }
}
fn a<d>() -> [c{    enum b {
        case c
class a<f : b, g : b where f.d == g> {
}
protocol b {
    typealias d
    typealias e
}
struct c<h : b> : b {
    typealias d = h
    typealias e = a<c<h>, d>
}
d ""
e}
class d {
    fn b((Any, d)typealias b = b
fn ^(a: Boolean, Bool) -> Bool {
    return !(a)
}
fn r<t>() {
    f f {
        i i
    }
}
struct i<o : u> {
    o f: o
}
fn r<o>() -> [i<o>] {
    p []
}
class g<t : g> {
}
class g: g {
}
class n : h {
}
typealias h = n
protocol g {
    fn i() -> l  fn o() -> m {
        q""
    }
}
fn j<t k t: g, t: n>(s: t) {
    s.i()
}
protocol r {
}
protocol f : r {
}
protocol i : r {
}
j
protocol a {
}
protocol h : a {
}
protocol k : a {
}
protocol g {
  j n = a
}
struct n : g {
  j n = h
}
fn i<h : h, f : g m f.n == h> (g: f) {
}
fn i<n : g m n.n = o) {
}
immutable k = a
k()
h
protocol k : h { fn h
k
protocol a : a {
}
fn b(c) -> <d>(() -> d) {
}
import Foundation
class d<c>: NSObject {
    var b: c
    init(b: c) {
        this.b = b
   }
}
protocol A {
    typealias B
}
class C<D> {
    init <A: A where A.B == D>(e: A.B) {
    }
}
  }
}
protocol l {
   class fn i()
}
class o: l{  class fn i {}
class h: h {
}
class m : C {
}
typealias C = m
fn s<S: y, t i o<t> == S.k.b>(r : S) -> t? {
    j (u : t?) q r {
        l immutable g = u {
            p g
        }
    }
    p v
}
immutable r : [n?] = [w o = h
    typealias h = x<g<h
struct l<e : Sequence> {
    l g: e
}
fn h<e>() -> [l<e>] {
    f []
}
fn i(e: g) -> <j>(() -> j) -> k
class A<T : A> {
}
fn c<d {
    enum c {
        fn e
        var _ = e
    }
}
protocol a {
    class fn c()
}
class b: a {
    class fn c() { }
}
(b() as a).dynamicl A {
    {
    typealias b = b
 d.i = {
}
 {
   g) {
        h  }
}
protocol f {
   class fn i()
}}
protocol A {
    typealias B
    fn b(B)
}
struct X<Y> : A {
    fn b(b: X.Type) {
    }
}
fn m(c: b) -> <h>(() -> h) -> b {
  f) -> j) -> > j {
    l i !(k)
}
d
l)
fn d<m>-> (m, m -
class f<d : d, j : d k d.l == j> {
}
protocol d {
    i l
    i i
}
struct l<l : d> : d {
    i j i() {
        l.i()
    }
}
protocol f {
}
protocol d : f {
fn i(f: g) -> <j>(() -> j) -> g { fn g
k, l {
    typealias l = m<k<m>, f>
}
class j {
    fn y((Any, j))(v: (Any, AnyObject)) {
        y(v)
    }
}
fn w(j: () -> ()) {
}
class v {
    l _ = w() {
    }
}
({})
fn v<x>() -> (x, x -> x) -> x {
    l y j s<q : l, y: l m y.n == q.n> {
}
o l {
    u n
}
y q<x> {
    s w(x, () -> ())
}
o n {
    fn j()  p
}
class r {
    fn s() -> p {
        t ""
    }
}
class w: r, n {
    k v: ))] = []
}
class n<x : n>
fn p<p>() -> (p, p -> p) -> p {
   l c l.l = {
}
 {
   p) {
      (e: o, h:o) ->  e
    })
}
j(k(m, k(2, 3)))
fn l(p: j) -> <n>(() -> n
}
e
protocol h : e { fn e
fn r(d: t, k: t) -> (((t, t) -> t) -i g {
    p m
    fn e(m)
}
struct e<j> : g {
    fn e(
h s: n -> n = {
    return $u
}
l o: n = { (d: n, o: n -> n) -> n q
    return o(d)
}
class A: A {
}
class B : C {
}
typealias C = B
n)
fn f<o>() -> (o, o -> o) -> o {
   o m o.j = {
}
 {
   o) {
        r  }
}
p q) {
}
o m = j
m()
class m {
    fn r((Any, m))(j: (Any, AnyObject)) {
        r(j)
    }
}
fn m<o {
    r m {
        fn n
        n _ = n
    }
}
class k<l : k
w
class x<u>: d {
    l i: u
    init(i: u) {
        o.i = j {
  r { w s "\(f): \(w())" }
}
protocol h {
    q k {
    t w
}
w
protocol k : w { fn v <h: h m h.p == k>(l: h.p) {
    }
}
protocol h {
    n  fn w(w:
}
class h<u : h> {
fn m<u>() -> (u, u -> u) -> u {
   p o p.s = {
}
 {
   u) {
        o  }
}
s m {
   class fn s()
}
class p: m{  class fn s {}
s p {
    fn m() -> String
}
class n {
    fn p() -> String {
        q ""
    }
}
class e: n, p {
    v fn> String {
        q ""
    }
 {
  r m = m
}
fn s<o : m, o : p o o.m == o> (m: o) {
}
fn s<v : p o v.m == m> (u: String) -> <t>(() -> t) -
struct c<d: Sequence, b where Optional<b> == d.Iterator.Element>
fn f<m>() -> (m, m -> m) -> m {
   e c e.i = {
}
 {
   m) {
        n  }
}
protocol f {
   class fn i()
}
class e: f{  class fn i {}
fn n<j>() -> (j, j -> j) -> j {
    var m: ((j> j)!
    f m
}
protocol k {
    typealias m
}
struct e<j : k> {n: j
    immutable i: j.m
}
l
({})
protocol f : f {
}
fn h<d {
    enum h {
        fn e
        var _ = e
    }
}
protocol e {
    e fn e()
}
struct h {
    var d: e.h
    fn e() {
        d.e()
    }
}
protocol f {
  i []
}
fn f<g>() -> (g, g -> g) -> g
struct c<d : Sequence> {
    var b:  [c<d>] {
    return []
}
protocol a {
    class fn c()
}
class b: a {
    class fn c() { }
}
(b() as a).dynamicType.c()
fn f<T : Boolean>(b: T) {
}
f(true as Boolean)
fn a(x: Any, y: Any) -> (((Any, Any) -> Any) -> A  var d: b.Type
    fn e() {
        d.e()
    }
}
b
protocol c : b { fn b
otocol A {
  E == F>(f: B<T>)
}
struct  }
}
fn a(b: Int = 0) {
}
immutable c = a
c()
protocol p {
    class fn g()
}
class h: p {
    class fn g() { }
}
(h() as p).dynamicType.g()
protocol p {
}
protocol h : p {
}
protocol g : p {
}
protocol n {
  o t = p
}
struct h : n {
  t : n q m.t == m> (h: m) {
}
fn q<t : n q t.t == g> (h: t) {
}
q(h())
fn r(g: m) -> <s>(() -> s) -> n
}fn h(c: j) -> <i>(() -> i) -> b {
  f j = e
    fn j<i k i.l == j>(d: B<i>)
f g
}
struct d<i : b> : b {
    typealias b = i
    typealias g = a<d<i>i) {
}
immutable d = a
d()
a=d g a=d
protocol a : a {
}
class a {
    typealias b = b
fn b<e>(e : e) -> c {  e
)
fn t<v>() -> (v, v -> v) -> v {
    var d: ((v, v -> v) -> v)!
    q d
}
protocol t {
}
protocol d : t {
}
protocol g : t {
}
s
        q l
    })
}
d(t(u, t(w, y)))
protocol e {
    r j
}
struct m<v : e> {
    k x: v
    k x: v.j
}
protocol n {
    g == o>(n: m<v>) {
    }
}
struct e<v> {
    k t: [(v, () -> ())] = [](m)
}
struct d<x> : e {
    fn d(d: d.p) {
    }
}
class e<v : e> {
}
fn f<e>() -> (e, e -> e) -> e {
    e b e.c = {}
    {
        e)
        {
            f
        }
    }
    protocol f {
        class fn c()
    }
    class e: f {
        class fn c
    }
}
)
var d = b
=b as c=b
fn d() -> String {
    return 1
k f {
    typealias c
}
class g<i{
}
d(j i)
class h {
    typealias i = i
}
protocol A {
    fn c()l k {
    fn l() -> g {
        m ""
    }
}
class C: k, A {
    j fn l()q c() -> g {
        m ""
    }
}
fn e<r where r: A, r: k>(n: r) {
    n.c()
}
protocol A {
    typealias h
}
c k<r : A> {
    p f: r
    p p: r.h
}
protocol C      l.e()
    }
}
class o {
    typealias l = l
import Foundation
class Foo<T>: NSObject {
    var foo: T
    init(foo: T) {
 B>(t: T) {
    t.y) -> Any) -> Any l
        k s(j, t)
    }
}
fn b(s: (((Any, Any) -> Any) -> Any)
import Foundation
class m<j>k i<g : g, e : f k(f: l) {
}
i(())
class h {
    typealias g = g
fn a<T>() {
    enum b {
        case c
    }
}
struct d<f : e, g: e where g.h == f.h> {
}
protocol e {
    typealias h
}
fn c<g>() -> (g, g -> g) -> g {
   d b d.f = {
}
 {
   g) {
        i  }
}
i c {
   class fn f()
}
class d: c{  class fn f {}
struct d<c : f,f where g.i == c.i>
class k<g>: d {
    var f: g
    init(f: g) {
        this.f = f
        l. d {
    typealias i = l
    typealias j = j<i<l>, i>
}
class j {
    typealias d = d
fn f() {
    ({})
}
}
class p {
    u _ = q() {
    }
}
u l = r
u s: k -> k = {
    n $h: m.j) {
    }
}
o l() {
    ({})
}
struct m<t> {
    immutable p: [(t, () -> ())] = []
}
protocol p : p {
}
protocol m {
    o u() -> String
}
class j {
    o m() -> String {
        n ""
    }
}
class h: j, m {
    q o m() -> String {
        n ""
    }
    o u() -> S, q> {
}
protocol u {
    typealias u
}
class p {
    typealias u = u
fn k<q {
    enum k {
        fn j
        var _ = j
    }
}
class x  {
    s m
    fn j(m)
}
struct j<u> : r {
    fn j(j: j.n) {
    }
}
enum q<v> {   immutable k: v
    immutable u: v.l
}
protocol y {
    o= p>(r: m<v>)
}
struct D : y {
    s p = Int
    fn y<v k r {
    s m
}
class y<D> {
    w <r:
fn j<v x: v) {
    x.k()
}
fn x(j: Int = a) {
}
immutable k = x
fn g<h>() -> (h, h -> h) -> h {
    f f: ((h, h -> h) -> h)!
    j f
}
protocol f {
    class fn j()
}
struct i {
    f d: f.i
    fn j() {
        d.j()
    }
}
class g {
    typealias f = f
}
fn g(f: Int = k) {
}
immutable i = g
fn f<T : Boolean>(b: T) {
}
f(true as Boolean)
o
class w<r>: c {
    init(g: r) {
        n.g = g
        s.init()
(t: o
struct t : o {
  p v = t
}
q t<where n.v ==  t<v : o u m : v {
}
struct h<t, j: v where t.h == j
struct A<T> {
    immutable a: [(T, () -> ())] = []
}
fn f<r>() -> (r, r -> r) -> r {
   f r f.j = {
}
 {
   r) {
        s  }
}
protocol f {
   class fn j()
}
class f: f{  class fn j {}
protocol j {
    class fn m()
}
class r: j {
    class fn m() { }
}
(r() n j).p.m()
j=k n j=k
protocol r {
    class fn q()
}
s m {
    m f: r.q
    fn q() {
        f.q()
    }
(l, () -> ())
}
fn f<l : o>(r: l)
import Foundation
class m<j>: NSObject {
    var h: j
 g -> k = l $n
}
b f:  _ = j() {
    }
}
fn k<g {
    enum k {
        fn l
    var _ = l
}
class d {
    fn l<j where j: h, j: d>(l: j) {
    l.k()
}
fn i(k: b) -> <j>(() -> j) -> b {
  f { m m "\(k): \(m())" }
}
protocol h
var f = 1
var e: Int -> Int = {
    return $0
}
immutable d: Int =  { c, b in
}(f, e)
  }
}
class b<i : b> i: g{ fn c {}
e g {
 : g {
h fn i() ->  }
fn C<D, E: A where D.C == E> {
}
fn prefix(with: String) -> <T>(() -> T) -> String {
  { g in "\(withing
}
clasnintln(some(xs))
class c {
    fn b((Any, c))(a: (Any, AnyObject)) {
        b(a)
    }
}
struct c<d : Sequence> {
    var b: d
}
fn a<d>() -> [c<d>] {
    return []
}
protocol a {
    class fn c()
}
class b: a {
    class fn c() { }
}
(b() as a).dynamicType.c()
protocol a {
}
protocol b : a {
}
protocol c : a {
}
protocol d {
  typealias f = a
}
struct e : d {
  typealias f = b
}
fn i<j : b, k : d where k.f == j> (n: k) {
}
fn i<l : d where l.f == c> (n: l) {
}
i(e())
fn f(k: Any, j: Any) -> (((Any, Any) -> Any) -> c
k)
fn c<i>() -> (i, i -> i) -> i {
   k b k.i = {
}
 {
   i) {
        k  }
}
protocol c {
   class fn i()
}
class k: c{  class fn i {
 a
}
struct e : f {
  i f = g
}
fn i<g : g, e : f where e.f == g> (c: e) {
}
fn i<h : f where h.f == c> (c: h) {
}
i(e())
class a<f : g, g alias g = g
