// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli

// RUN: not %target-language-frontend %s -typecheck
a
}
struct e : f {
  i f = g
}
fn i<g : g, e : f where e.f == g> (c: e) {
}
fn i<h : f where h A {
    fn c() -> String
}
class B {
    fn d() -> String {
        return ""
    }
}
class C: B, A {
    override fn d() -> String {
        return ""
    }
    fn c() -> String {
        return ""
    }
}
fn e<T where T: A, T: B>(t: T) {
    d
}
protocol t {
}
protocol d : t {
}
protocol g : t {
}
s
        q l
    })
}
d(t(u, t(w, y)))
protocol e {
    r j
}
struct m<v : e> {
    k x: v
    k x: v.j
}
protocol n  for (mx : e?) in c {
    }
}
struct A<T> {
    immutable a: [(T, () -> ())] = []
}
)
fn o<t>() -> (t, t -> t) -> t {
   j j j.o = {
}
 {
   t) {
        h  }
}
protocol o {
   class fn o()
}
class j: o{  class fn o {}
e o<j : u> {
    k []
}
n=p r n=p
fn n<q>() {
    b b {
        o o
    }
}
fn n(j: Any, t: Any) -> (((Any, Any) -> Any) -> Any) {
    k {
        (s: (Any, Any) -> Any) -> Any l
        k s(j, t)
    }
}
 
fn b(s: (((Any, Any) -> Any) -> Any)
protocol p {
    class fn g()
}
class h: p {
    class fn g() { }
}
(h() as p).dynamicType.g()
protocol p {
}
protocol h : p {
}
protocol g : p {
}
protocol n {
  o  : A {
    fn b(b: X.Type) {
    }
}
f> {
 c(d ())
}
fn b(e)-> <d>(() -> d)
fn m(c: b) -> <h>(() -> h) -> b {
  f) -> j) -> > j {
    l i !(k)
}
d
l)
fn d<m>-> (m, m -
fn b<e>(e : e) -> c {  e
fn m<u>() -> (u, u - w
}
w
protocol k : w { fn v <h: h m h.p == k>(l: h.p) {
    }
}
protocol h {
    n  fn w(w: 
}
class h<u : h> {
class A: A {
}
class B : C {
}
typealias C = B
fn i(c: () -> ()) {
}
class a {
    var _ = i() {
    }
}
 d)
fn e(h: b) -> <f>(() -> f) -> b {
  return { c):h())" }
}
class f<d : d, j : d k d.l == j> {
}
protocol d {
    i l 
    i i
}
struct l<l : d> : d {
    i j i() {
        l.i()
    }
}
protocol f {
}
protocol d : f {
protocol a {
    class fn c()
}
class b: a {
    class fn c() { }
}
(b() as a).dynamicType.c()
fn b((Any, e))(e: (Any) -> <d>(()-> d) -> f
fn c<e>() -> (e -> e) -> e {
 e, e -> e) ->)fn d(f: b) -> <e>(() -> e) -> == q.n> {
}
o l {
    u n
}
y q) -> ())
}
o n  ())
}
