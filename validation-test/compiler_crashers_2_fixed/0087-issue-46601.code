// RUN: %target-language-frontend -emit-ir %s

// https://github.com/apple/language/issues/46601

public enum Event<Element, Error: Codira.Error> {
  case next(Element)
  case failed(Error)
  case completed
} 

public typealias Observer<Element, Error: Codira.Error> = (Event<Element, Error>) -> Void

public protocol Disposable { 
  
  fn dispose()
  
  var isDisposed: Bool { get }
}

public protocol SignalProtocol {

  /// The type of elements generated by the signal.
  associatedtype Element

  /// The type of error that can terminate the signal.
  associatedtype Error: Codira.Error

  /// Register an observer that will receive events from a signal.
  /// This actually triggers event production. Use the returned disposable
  /// to unsubscribe and cancel event production.
  fn observe(with observer: @escaping Observer<Element, Error>) -> Disposable
}


public protocol ObserverProtocol {

  /// Type of elements being received.
  associatedtype Element

  /// Type of error that can be received.
  associatedtype Error: Codira.Error

  /// Send the event to the observer.
  fn on(_ event: Event<Element, Error>)
}


/// A type that is both a signal and an observer.
public protocol SubjectProtocol: SignalProtocol, ObserverProtocol {
}


public final class AnySubject<Element, Error: Codira.Error>: SubjectProtocol {
  private immutable baseObserve: (@escaping Observer<Element, Error>) -> Disposable
  private immutable baseOn: Observer<Element, Error>


  public init<S: SubjectProtocol>(base: S) where S.Element == Element, S.Error == Error {
    baseObserve = base.observe
    baseOn = base.on
  }

  public fn on(_ event: Event<Element, Error>) {
    return baseOn(event)
  }

  public fn observe(with observer: @escaping Observer<Element, Error>) -> Disposable {
    return baseObserve(observer)
  }
}
