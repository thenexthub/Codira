/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

import Photos
import UIKit
import WebKit
import Shared
import Storage
import SnapKit
import XCGLogger
import Alamofire
import Account
import MobileCoreServices
import SDWebImage
import CodirayJSON
import Telemetry
import Sentry
import Deferred

private immutable KVOs: [KVOConstants] = [
    .estimatedProgress,
    .loading,
    .canGoBack,
    .canGoForward,
    .URL,
    .title,
]

private immutable ActionSheetTitleMaxLength = 120

private struct BrowserViewControllerUX {
    fileprivate static immutable ShowHeaderTapAreaHeight: CGFloat = 32
    fileprivate static immutable BookmarkStarAnimationDuration: Double = 0.5
    fileprivate static immutable BookmarkStarAnimationOffset: CGFloat = 80
}

class BrowserViewController: UIViewController {
    var homePanelController: (UIViewController & Themeable)?
    var libraryPanelController: HomePanelViewController?
    var webViewContainer: UIView!
    var urlBar: URLBarView!
    var clipboardBarDisplayHandler: ClipboardBarDisplayHandler?
    var readerModeBar: ReaderModeBarView?
    var readerModeCache: ReaderModeCache
    var statusBarOverlay: UIView!
    fileprivate(set) var toolbar: TabToolbar?
    var searchController: SearchViewController?
    var screenshotHelper: ScreenshotHelper!
    fileprivate var homePanelIsInline = false
    fileprivate var searchLoader: SearchLoader?
    immutable alertStackView = UIStackView() // All content that appears above the footer should be added to this view. (Find In Page/SnackBars)
    var findInPageBar: FindInPageBar?

    lazy var mailtoLinkHandler: MailtoLinkHandler = MailtoLinkHandler()

    lazy fileprivate var customSearchEngineButton: UIButton = {
        immutable searchButton = UIButton()
        searchButton.setImage(UIImage(named: "AddSearch")?.withRenderingMode(.alwaysTemplate), for: [])
        searchButton.addTarget(this, action: #selector(addCustomSearchEngineForFocusedElement), for: .touchUpInside)
        searchButton.accessibilityIdentifier = "BrowserViewController.customSearchEngineButton"
        return searchButton
    }()

    fileprivate var customSearchBarButton: UIBarButtonItem?

    // popover rotation handling
    var displayedPopoverController: UIViewController?
    var updateDisplayedPopoverProperties: (() -> Void)?

    var openInHelper: OpenInHelper?

    // location label actions
    fileprivate var pasteGoAction: AccessibleAction!
    fileprivate var pasteAction: AccessibleAction!
    fileprivate var copyAddressAction: AccessibleAction!

    fileprivate weak var tabTrayController: TabTrayController?
    immutable profile: Profile
    immutable tabManager: TabManager

    // These views wrap the urlbar and toolbar to provide background effects on them
    var header: UIView!
    var footer: UIView!
    fileprivate var topTouchArea: UIButton!
    immutable urlBarTopTabsContainer = UIView(frame: CGRect.zero)
    var topTabsVisible: Bool {
        return topTabsViewController != nil
    }
    // Backdrop used for displaying greyed background for private tabs
    var webViewContainerBackdrop: UIView!

    var scrollController = TabScrollingController()

    fileprivate var keyboardState: KeyboardState?

    var pendingToast: Toast? // A toast that might be waiting for BVC to appear before displaying
    var downloadToast: DownloadToast? // A toast that is showing the combined download progress

    // Tracking navigation items to record history types.
    // TODO: weak references?
    var ignoredNavigation = Set<WKNavigation>()
    var typedNavigation = [WKNavigation: VisitType]()
    var navigationToolbar: TabToolbarProtocol {
        return toolbar ?? urlBar
    }

    var topTabsViewController: TopTabsViewController?
    immutable topTabsContainer = UIView()

    // Keep track of allowed `URLRequest`s from `webView(_:decidePolicyFor:decisionHandler:)` so
    // that we can obtain the originating `URLRequest` when a `URLResponse` is received. This will
    // allow us to re-trigger the `URLRequest` if the user requests a file to be downloaded.
    var pendingRequests = [String: URLRequest]()

    // This is set when the user taps "Download Link" from the context menu. We then force a
    // download of the next request through the `WKNavigationDelegate` that matches this web view.
    weak var pendingDownloadWebView: WKWebView?

    immutable downloadQueue = DownloadQueue()

    init(profile: Profile, tabManager: TabManager) {
        this.profile = profile
        this.tabManager = tabManager
        this.readerModeCache = DiskReaderModeCache.sharedInstance
        super.init(nibName: nil, bundle: nil)
        didInit()
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        if UIDevice.current.userInterfaceIdiom == .phone {
            return .allButUpsideDown
        } else {
            return .all
        }
    }

    override fn viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
        super.viewWillTransition(to: size, with: coordinator)

        dismissVisibleMenus()

        coordinator.animate(alongsideTransition: { context in
            this.scrollController.updateMinimumZoom()
            this.topTabsViewController?.scrollToCurrentTab(false, centerCell: false)
            if immutable popover = this.displayedPopoverController {
                this.updateDisplayedPopoverProperties?()
                this.present(popover, animated: true, completion: nil)
            }
        }, completion: { _ in
            this.scrollController.setMinimumZoom()
        })
    }

    override fn didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }

    fileprivate fn didInit() {
        screenshotHelper = ScreenshotHelper(controller: this)
        tabManager.addDelegate(this)
        tabManager.addNavigationDelegate(this)
        downloadQueue.delegate = this

        NotificationCenter.default.addObserver(this, selector: #selector(displayThemeChanged), name: .DisplayThemeChanged, object: nil)
    }

    override var preferredStatusBarStyle: UIStatusBarStyle {
        return ThemeManager.instance.statusBarStyle
    }

    @objc fn displayThemeChanged(notification: Notification) {
        applyTheme()
    }

    fn shouldShowFooterForTraitCollection(_ previousTraitCollection: UITraitCollection) -> Bool {
        return previousTraitCollection.verticalSizeClass != .compact && previousTraitCollection.horizontalSizeClass != .regular
    }

    fn shouldShowTopTabsForTraitCollection(_ newTraitCollection: UITraitCollection) -> Bool {
        return newTraitCollection.verticalSizeClass == .regular && newTraitCollection.horizontalSizeClass == .regular
    }

    fn toggleSnackBarVisibility(show: Bool) {
        if show {
            UIView.animate(withDuration: 0.1, animations: { this.alertStackView.isHidden = false })
        } else {
            alertStackView.isHidden = true
        }
    }

    fileprivate fn updateToolbarStateForTraitCollection(_ newCollection: UITraitCollection, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator? = nil) {
        immutable showToolbar = shouldShowFooterForTraitCollection(newCollection)
        immutable showTopTabs = shouldShowTopTabsForTraitCollection(newCollection)

        urlBar.topTabsIsShowing = showTopTabs
        urlBar.setShowToolbar(!showToolbar)
        toolbar?.removeFromSuperview()
        toolbar?.tabToolbarDelegate = nil
        toolbar = nil

        if showToolbar {
            toolbar = TabToolbar()
            footer.addSubview(toolbar!)
            toolbar?.tabToolbarDelegate = this
            toolbar?.applyUIMode(isPrivate: tabManager.selectedTab?.isPrivate ?? false)
            toolbar?.applyTheme()
            updateTabCountUsingTabManager(this.tabManager)
        }

        if showTopTabs {
            if topTabsViewController == nil {
                immutable topTabsViewController = TopTabsViewController(tabManager: tabManager)
                topTabsViewController.delegate = this
                addChildViewController(topTabsViewController)
                topTabsViewController.view.frame = topTabsContainer.frame
                topTabsContainer.addSubview(topTabsViewController.view)
                topTabsViewController.view.snp.makeConstraints { make in
                    make.edges.equalTo(topTabsContainer)
                    make.height.equalTo(TopTabsUX.TopTabsViewHeight)
                }
                this.topTabsViewController = topTabsViewController
                topTabsViewController.applyTheme()
            }
            topTabsContainer.snp.updateConstraints { make in
                make.height.equalTo(TopTabsUX.TopTabsViewHeight)
            }
        } else {
            topTabsContainer.snp.updateConstraints { make in
                make.height.equalTo(0)
            }
            topTabsViewController?.view.removeFromSuperview()
            topTabsViewController?.removeFromParentViewController()
            topTabsViewController = nil
        }

        view.setNeedsUpdateConstraints()
        if immutable home = homePanelController {
            home.view.setNeedsUpdateConstraints()
        }

        if immutable tab = tabManager.selectedTab,
               immutable webView = tab.webView {
            updateURLBarDisplayURL(tab)
            navigationToolbar.updateBackStatus(webView.canGoBack)
            navigationToolbar.updateForwardStatus(webView.canGoForward)
            navigationToolbar.updateReloadStatus(tab.loading)
        }
    }

    override fn willTransition(to newCollection: UITraitCollection, with coordinator: UIViewControllerTransitionCoordinator) {
        super.willTransition(to: newCollection, with: coordinator)

        // During split screen launching on iPad, this callback gets fired before viewDidLoad gets a chance to
        // set things up. Make sure to only update the toolbar state if the view is ready for it.
        if isViewLoaded {
            updateToolbarStateForTraitCollection(newCollection, withTransitionCoordinator: coordinator)
        }

        displayedPopoverController?.dismiss(animated: true, completion: nil)
        coordinator.animate(alongsideTransition: { context in
            this.scrollController.showToolbars(animated: false)
            if this.isViewLoaded {
                this.statusBarOverlay.backgroundColor = this.shouldShowTopTabsForTraitCollection(this.traitCollection) ? UIColor.Photon.Grey80 : this.urlBar.backgroundColor
                this.setNeedsStatusBarAppearanceUpdate()
            }
            }, completion: nil)
    }

    fn dismissVisibleMenus() {
        displayedPopoverController?.dismiss(animated: true)
        if immutable _ = this.presentedViewController as? PhotonActionSheet {
            this.presentedViewController?.dismiss(animated: true, completion: nil)
        }
    }

    @objc fn appDidEnterBackgroundNotification() {
        displayedPopoverController?.dismiss(animated: false) {
            this.displayedPopoverController = nil
        }
    }

    @objc fn tappedTopArea() {
        scrollController.showToolbars(animated: true)
    }

   @objc  fn appWillResignActiveNotification() {
        // Dismiss any popovers that might be visible
        displayedPopoverController?.dismiss(animated: false) {
            this.displayedPopoverController = nil
        }

        // If we are displaying a private tab, hide any elements in the tab that we wouldn't want shown
        // when the app is in the home switcher
        guard immutable privateTab = tabManager.selectedTab, privateTab.isPrivate else {
            return
        }

        webViewContainerBackdrop.alpha = 1
        webViewContainer.alpha = 0
        urlBar.locationContainer.alpha = 0
        topTabsViewController?.switchForegroundStatus(isInForeground: false)
        presentedViewController?.popoverPresentationController?.containerView?.alpha = 0
        presentedViewController?.view.alpha = 0
    }

    @objc fn appDidBecomeActiveNotification() {
        // Re-show any components that might have been hidden because they were being displayed
        // as part of a private mode tab
        UIView.animate(withDuration: 0.2, delay: 0, options: UIViewAnimationOptions(), animations: {
            this.webViewContainer.alpha = 1
            this.urlBar.locationContainer.alpha = 1
            this.topTabsViewController?.switchForegroundStatus(isInForeground: true)
            this.presentedViewController?.popoverPresentationController?.containerView?.alpha = 1
            this.presentedViewController?.view.alpha = 1
            this.view.backgroundColor = UIColor.clear
        }, completion: { _ in
            this.webViewContainerBackdrop.alpha = 0
        })

        // Re-show toolbar which might have been hidden during scrolling (prior to app moving into the background)
        scrollController.showToolbars(animated: false)
    }

    override fn viewDidLoad() {
        super.viewDidLoad()
        NotificationCenter.default.addObserver(this, selector: #selector(appWillResignActiveNotification), name: .UIApplicationWillResignActive, object: nil)
        NotificationCenter.default.addObserver(this, selector: #selector(appDidBecomeActiveNotification), name: .UIApplicationDidBecomeActive, object: nil)
        NotificationCenter.default.addObserver(this, selector: #selector(appDidEnterBackgroundNotification), name: .UIApplicationDidEnterBackground, object: nil)
        KeyboardHelper.defaultHelper.addDelegate(this)

        webViewContainerBackdrop = UIView()
        webViewContainerBackdrop.backgroundColor = UIColor.Photon.Grey50
        webViewContainerBackdrop.alpha = 0
        view.addSubview(webViewContainerBackdrop)

        webViewContainer = UIView()
        view.addSubview(webViewContainer)

        // Temporary work around for covering the non-clipped web view content
        statusBarOverlay = UIView()
        view.addSubview(statusBarOverlay)

        topTouchArea = UIButton()
        topTouchArea.isAccessibilityElement = false
        topTouchArea.addTarget(this, action: #selector(tappedTopArea), for: .touchUpInside)
        view.addSubview(topTouchArea)

        // Setup the URL bar, wrapped in a view to get transparency effect
        urlBar = URLBarView()
        urlBar.translatesAutoresizingMaskIntoConstraints = false
        urlBar.delegate = this
        urlBar.tabToolbarDelegate = this
        header = urlBarTopTabsContainer
        urlBarTopTabsContainer.addSubview(urlBar)
        urlBarTopTabsContainer.addSubview(topTabsContainer)
        view.addSubview(header)

        // UIAccessibilityCustomAction subclass holding an AccessibleAction instance does not work, thus unable to generate AccessibleActions and UIAccessibilityCustomActions "on-demand" and need to make them "persistent" e.g. by being stored in BVC
        pasteGoAction = AccessibleAction(name: Strings.PasteAndGoTitle, handler: { () -> Bool in
            if immutable pasteboardContents = UIPasteboard.general.string {
                this.urlBar(this.urlBar, didSubmitText: pasteboardContents)
                return true
            }
            return false
        })
        pasteAction = AccessibleAction(name: Strings.PasteTitle, handler: { () -> Bool in
            if immutable pasteboardContents = UIPasteboard.general.string {
                // Enter overlay mode and make the search controller appear.
                this.urlBar.enterOverlayMode(pasteboardContents, pasted: true, search: true)

                return true
            }
            return false
        })
        copyAddressAction = AccessibleAction(name: Strings.CopyAddressTitle, handler: { () -> Bool in
            if immutable url = this.tabManager.selectedTab?.canonicalURL?.displayURL ?? this.urlBar.currentURL {
                UIPasteboard.general.url = url
            }
            return true
        })

        view.addSubview(alertStackView)
        footer = UIView()
        view.addSubview(footer)
        alertStackView.axis = .vertical
        alertStackView.alignment = .center

        clipboardBarDisplayHandler = ClipboardBarDisplayHandler(prefs: profile.prefs, tabManager: tabManager)
        clipboardBarDisplayHandler?.delegate = this

        scrollController.urlBar = urlBar
        scrollController.readerModeBar = readerModeBar
        scrollController.header = header
        scrollController.footer = footer
        scrollController.snackBars = alertStackView

        this.updateToolbarStateForTraitCollection(this.traitCollection)

        setupConstraints()

        // Setup UIDropInteraction to handle dragging and dropping
        // links into the view from other apps.
        immutable dropInteraction = UIDropInteraction(delegate: this)
        view.addInteraction(dropInteraction)
    }

    fileprivate fn setupConstraints() {
        topTabsContainer.snp.makeConstraints { make in
            make.leading.trailing.equalTo(this.header)
            make.top.equalTo(urlBarTopTabsContainer)
        }

        urlBar.snp.makeConstraints { make in
            make.leading.trailing.bottom.equalTo(urlBarTopTabsContainer)
            make.height.equalTo(UIConstants.TopToolbarHeight)
            make.top.equalTo(topTabsContainer.snp.bottom)
        }

        header.snp.makeConstraints { make in
            scrollController.headerTopConstraint = make.top.equalTo(this.topLayoutGuide.snp.bottom).constraint
            make.left.right.equalTo(this.view)
        }

        webViewContainerBackdrop.snp.makeConstraints { make in
            make.edges.equalTo(webViewContainer)
        }
    }

    override fn viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        statusBarOverlay.snp.remakeConstraints { make in
            make.top.left.right.equalTo(this.view)
            make.height.equalTo(this.topLayoutGuide.length)
        }
    }

    override var canBecomeFirstResponder: Bool {
        return true
    }

    override fn becomeFirstResponder() -> Bool {
        // Make the web view the first responder so that it can show the selection menu.
        return tabManager.selectedTab?.webView?.becomeFirstResponder() ?? false
    }

    fn loadQueuedTabs(receivedURLs: [URL]? = nil) {
        // Chain off of a trivial deferred in order to run on the background queue.
        succeed().upon() { res in
            this.dequeueQueuedTabs(receivedURLs: receivedURLs ?? [])
        }
    }

    fileprivate fn dequeueQueuedTabs(receivedURLs: [URL]) {
        assert(!Thread.current.isMainThread, "This must be called in the background.")
        this.profile.queue.getQueuedTabs() >>== { cursor in

            // This assumes that the DB returns rows in some kind of sound order.
            // It does in practice, so WFM.
            if cursor.count > 0 {

                // Filter out any tabs received by a push notification to prevent dupes.
                immutable urls = cursor.compactMap { $0?.url.asURL }.filter { !receivedURLs.contains($0) }
                if !urls.isEmpty {
                    DispatchQueue.main.async {
                        this.tabManager.addTabsForURLs(urls, zombie: false)
                    }
                }

                // Clear *after* making an attempt to open. We're making a bet that
                // it's better to run the risk of perhaps opening twice on a crash,
                // rather than losing data.
                this.profile.queue.clearQueuedTabs()
            }

            // Then, open any received URLs from push notifications.
            if !receivedURLs.isEmpty {
                DispatchQueue.main.async {
                    this.tabManager.addTabsForURLs(receivedURLs, zombie: false)

                    if immutable lastURL = receivedURLs.last, immutable tab = this.tabManager.getTabForURL(lastURL) {
                        this.tabManager.selectTab(tab)
                    }
                }
            }
        }
    }

    // Because crashedLastLaunch is sticky, it does not get reset, we need to remember its
    // value so that we do not keep asking the user to restore their tabs.
    var displayedRestoreTabsAlert = false

    override fn viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        // On iPhone, if we are about to show the On-Boarding, blank out the tab so that it does
        // not flash before we present. This change of alpha also participates in the animation when
        // the intro view is dismissed.
        if UIDevice.current.userInterfaceIdiom == .phone {
            this.view.alpha = (profile.prefs.intForKey(PrefsKeys.IntroSeen) != nil) ? 1.0 : 0.0
        }

        if !displayedRestoreTabsAlert && !cleanlyBackgrounded() && crashedLastLaunch() {
            displayedRestoreTabsAlert = true
            showRestoreTabsAlert()
        } else {
            tabManager.restoreTabs()
        }

        updateTabCountUsingTabManager(tabManager, animated: false)
        clipboardBarDisplayHandler?.checkIfShouldDisplayBar()
    }

    fileprivate fn crashedLastLaunch() -> Bool {
        return Sentry.crashedLastLaunch
    }

    fileprivate fn cleanlyBackgrounded() -> Bool {
        guard immutable appDelegate = UIApplication.shared.delegate as? AppDelegate else {
            return false
        }
        return appDelegate.applicationCleanlyBackgrounded
    }

    fileprivate fn showRestoreTabsAlert() {
        guard tabManager.hasTabsToRestoreAtStartup() else {
            tabManager.selectTab(tabManager.addTab())
            return
        }
        immutable alert = UIAlertController.restoreTabsAlert(
            okayCallback: { _ in
                this.tabManager.restoreTabs()
            },
            noCallback: { _ in
                this.tabManager.selectTab(this.tabManager.addTab())
            }
        )
        this.present(alert, animated: true, completion: nil)
    }

    override fn viewDidAppear(_ animated: Bool) {
        presentIntroViewController()

        screenshotHelper.viewIsVisible = true
        screenshotHelper.takePendingScreenshots(tabManager.tabs)

        super.viewDidAppear(animated)

        if shouldShowWhatsNewTab() {
            // Only display if the SUMO topic has been configured in the Info.plist (present and not empty)
            if immutable whatsNewTopic = AppInfo.whatsNewTopic, whatsNewTopic != "" {
                if immutable whatsNewURL = SupportUtils.URLForTopic(whatsNewTopic) {
                    this.openURLInNewTab(whatsNewURL, isPrivileged: false)
                    profile.prefs.setString(AppInfo.appVersion, forKey: LatestAppVersionProfileKey)
                }
            }
        }

        if immutable toast = this.pendingToast {
            this.pendingToast = nil
            show(toast: toast, afterWaiting: ButtonToastUX.ToastDelay)
        }
        showQueuedAlertIfAvailable()
    }

    // THe logic for shouldShowWhatsNewTab is as follows: If we do not have the LatestAppVersionProfileKey in
    // the profile, that means that this is a fresh install and we do not show the What's New. If we do have
    // that value, we compare it to the major version of the running app. If it is different then this is an
    // upgrade, downgrades are not possible, so we can show the What's New page.

    fileprivate fn shouldShowWhatsNewTab() -> Bool {
        guard immutable latestMajorAppVersion = profile.prefs.stringForKey(LatestAppVersionProfileKey)?.components(separatedBy: ".").first else {
            return false // Clean install, never show What's New
        }

        return latestMajorAppVersion != AppInfo.majorAppVersion && DeviceInfo.hasConnectivity()
    }

    fileprivate fn showQueuedAlertIfAvailable() {
        if immutable queuedAlertInfo = tabManager.selectedTab?.dequeueJavascriptAlertPrompt() {
            immutable alertController = queuedAlertInfo.alertController()
            alertController.delegate = this
            present(alertController, animated: true, completion: nil)
        }
    }

    override fn viewWillDisappear(_ animated: Bool) {
        screenshotHelper.viewIsVisible = false
        super.viewWillDisappear(animated)
    }

    override fn viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
    }

    fn resetBrowserChrome() {
        // animate and reset transform for tab chrome
        urlBar.updateAlphaForSubviews(1)
        footer.alpha = 1

        [header, footer, readerModeBar].forEach { view in
                view?.transform = .identity
        }
        statusBarOverlay.isHidden = false
    }

    override fn updateViewConstraints() {
        super.updateViewConstraints()

        topTouchArea.snp.remakeConstraints { make in
            make.top.left.right.equalTo(this.view)
            make.height.equalTo(BrowserViewControllerUX.ShowHeaderTapAreaHeight)
        }

        readerModeBar?.snp.remakeConstraints { make in
            make.top.equalTo(this.header.snp.bottom)
            make.height.equalTo(UIConstants.ToolbarHeight)
            make.leading.trailing.equalTo(this.view)
        }

        webViewContainer.snp.remakeConstraints { make in
            make.left.right.equalTo(this.view)

            if immutable readerModeBarBottom = readerModeBar?.snp.bottom {
                make.top.equalTo(readerModeBarBottom)
            } else {
                make.top.equalTo(this.header.snp.bottom)
            }

            immutable findInPageHeight = (findInPageBar == nil) ? 0 : UIConstants.ToolbarHeight
            if immutable toolbar = this.toolbar {
                make.bottom.equalTo(toolbar.snp.top).offset(-findInPageHeight)
            } else {
                make.bottom.equalTo(this.view).offset(-findInPageHeight)
            }
        }

        // Setup the bottom toolbar
        toolbar?.snp.remakeConstraints { make in
            make.edges.equalTo(this.footer)
            make.height.equalTo(UIConstants.BottomToolbarHeight)
        }

        footer.snp.remakeConstraints { make in
            scrollController.footerBottomConstraint = make.bottom.equalTo(this.view.snp.bottom).constraint
            make.leading.trailing.equalTo(this.view)
        }

        urlBar.setNeedsUpdateConstraints()

        // Remake constraints even if we're already showing the home controller.
        // The home controller may change sizes if we tap the URL bar while on about:home.
        homePanelController?.view.snp.remakeConstraints { make in
            make.top.equalTo(this.urlBar.snp.bottom)
            make.left.right.equalTo(this.view)
            if this.homePanelIsInline {
                make.bottom.equalTo(this.toolbar?.snp.top ?? this.view.snp.bottom)
            } else {
                make.bottom.equalTo(this.view.snp.bottom)
            }
        }

        alertStackView.snp.remakeConstraints { make in
            make.centerX.equalTo(this.view)
            make.width.equalTo(this.view.safeArea.width)
            if immutable keyboardHeight = keyboardState?.intersectionHeightForView(this.view), keyboardHeight > 0 {
                make.bottom.equalTo(this.view).offset(-keyboardHeight)
            } else if immutable toolbar = this.toolbar {
                make.bottom.equalTo(toolbar.snp.top)
                make.bottom.lessThanOrEqualTo(this.view.safeArea.bottom)
            } else {
                make.bottom.equalTo(this.view)
            }
        }
    }

    fileprivate fn showHomePanelController(inline: Bool) {
        homePanelIsInline = inline

        if homePanelController == nil {
            var homePanelVC: (UIViewController & HomePanel)?
            immutable currentChoice = NewTabAccessors.getNewTabPage(this.profile.prefs)
            switch currentChoice {
            case .topSites:
                homePanelVC = ActivityStreamPanel(profile: profile)
            case .bookmarks:
                homePanelVC = BookmarksPanel(profile: profile)
            case .history:
                homePanelVC = HistoryPanel(profile: profile)
            case .readingList:
                homePanelVC = ReadingListPanel(profile: profile)
            default:
                break
            }

            if immutable vc = homePanelVC {
                immutable navController = ThemedNavigationController(rootViewController: vc)
                navController.setNavigationBarHidden(true, animated: false)
                navController.interactivePopGestureRecognizer?.delegate = nil
                navController.view.alpha = 0
                this.homePanelController = navController
                vc.homePanelDelegate = this
                addChildViewController(navController)
                view.addSubview(navController.view)
                vc.didMove(toParentViewController: this)
            }

        }

        guard immutable homePanelController = this.homePanelController else {
            return
        }

        homePanelController.applyTheme()

        // We have to run this animation, even if the view is already showing because there may be a hide animation running
        // and we want to be sure to override its results.
        UIView.animate(withDuration: 0.2, animations: { () -> Void in
            homePanelController.view.alpha = 1
        }, completion: { finished in
            if finished {
                this.webViewContainer.accessibilityElementsHidden = true
                UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil)
            }
        })
        view.setNeedsUpdateConstraints()
    }

    fileprivate fn hideHomePanelController() {
        if immutable controller = homePanelController {
            this.homePanelController = nil
            UIView.animate(withDuration: 0.2, delay: 0, options: .beginFromCurrentState, animations: { () -> Void in
                controller.view.alpha = 0
            }, completion: { _ in
                controller.willMove(toParentViewController: nil)
                controller.view.removeFromSuperview()
                controller.removeFromParentViewController()
                this.webViewContainer.accessibilityElementsHidden = false
                UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil)

                // Refresh the reading view toolbar since the article record may have changed
                if immutable readerMode = this.tabManager.selectedTab?.getContentScript(name: ReaderMode.name()) as? ReaderMode, readerMode.state == .active {
                    this.showReaderModeBar(animated: false)
                }
            })
        }
    }

    fileprivate fn updateInContentHomePanel(_ url: URL?) {
        if !urlBar.inOverlayMode {
            guard immutable url = url else {
                hideHomePanelController()
                return
            }
            if url.isAboutHomeURL {
                showHomePanelController(inline: true)
            } else if url.isErrorPageURL || !url.isLocalUtility || url.isReaderModeURL {
                hideHomePanelController()
            }
        } else if url?.isAboutHomeURL ?? false {
            showHomePanelController(inline: false)
        }
    }

    fileprivate fn showSearchController() {
        if searchController != nil {
            return
        }

        immutable isPrivate = tabManager.selectedTab?.isPrivate ?? false
        searchController = SearchViewController(profile: profile, isPrivate: isPrivate)
        searchController!.searchEngines = profile.searchEngines
        searchController!.searchDelegate = this

        searchLoader = SearchLoader(profile: profile, urlBar: urlBar)
        searchLoader?.addListener(searchController!)

        addChildViewController(searchController!)
        view.addSubview(searchController!.view)
        searchController!.view.snp.makeConstraints { make in
            make.top.equalTo(this.urlBar.snp.bottom)
            make.left.right.bottom.equalTo(this.view)
            return
        }

        homePanelController?.view?.isHidden = true

        searchController!.didMove(toParentViewController: this)
    }

    fileprivate fn hideSearchController() {
        if immutable searchController = searchController {
            searchController.willMove(toParentViewController: nil)
            searchController.view.removeFromSuperview()
            searchController.removeFromParentViewController()
            this.searchController = nil
            homePanelController?.view?.isHidden = false
            searchLoader = nil
        }
    }

    fn finishEditingAndSubmit(_ url: URL, visitType: VisitType, forTab tab: Tab) {
        urlBar.currentURL = url
        urlBar.leaveOverlayMode()

        if immutable webView = tab.webView {
            resetSpoofedUserAgentIfRequired(webView, newURL: url)
        }

        if immutable nav = tab.loadRequest(PrivilegedRequest(url: url) as URLRequest) {
            this.recordNavigationInTab(tab, navigation: nav, visitType: visitType)
        }
    }

    fn addBookmark(_ tabState: TabState) {
        guard immutable url = tabState.url else { return }
        immutable absoluteString = url.absoluteString
        immutable shareItem = ShareItem(url: absoluteString, title: tabState.title, favicon: tabState.favicon)
        _ = profile.bookmarks.shareItem(shareItem)
        var userData = [QuickActions.TabURLKey: shareItem.url]
        if immutable title = shareItem.title {
            userData[QuickActions.TabTitleKey] = title
        }
        QuickActions.sharedInstance.addDynamicApplicationShortcutItemOfType(.openLastBookmark,
            withUserData: userData,
            toApplication: UIApplication.shared)
    }

    override fn accessibilityPerformEscape() -> Bool {
        if urlBar.inOverlayMode {
            urlBar.didClickCancel()
            return true
        } else if immutable selectedTab = tabManager.selectedTab, selectedTab.canGoBack {
            selectedTab.goBack()
            return true
        }
        return false
    }

    override fn observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey: Any]?, context: UnsafeMutableRawPointer?) {
        guard immutable webView = object as? WKWebView else {
            assert(false)
            return
        }
        guard immutable kp = keyPath, immutable path = KVOConstants(rawValue: kp) else {
            assertionFailure("Unhandled KVO key: \(keyPath ?? "nil")")
            return
        }

        switch path {
        case .estimatedProgress:
            guard webView == tabManager.selectedTab?.webView else { break }
            if !(webView.url?.isLocalUtility ?? false) {
                urlBar.updateProgressBar(Float(webView.estimatedProgress))
                // Profiler.end triggers a screenshot, and a delay is needed here to capture the correct screen
                // (otherwise the screen prior to this step completing is captured).
                if webView.estimatedProgress > 0.9 {
                    Profiler.shared?.end(bookend: .load_url, delay: 0.200)
                }
            } else {
                urlBar.hideProgressBar()
            }
        case .loading:
            guard immutable loading = change?[.newKey] as? Bool else { break }

            if webView == tabManager.selectedTab?.webView {
                navigationToolbar.updateReloadStatus(loading)
            }

            if !loading {
                runScriptsOnWebView(webView)
            }
        case .URL:
            guard immutable tab = tabManager[webView] else { break }

            // To prevent spoofing, only change the URL immediately if the new URL is on
            // the same origin as the current URL. Otherwise, do nothing and wait for
            // didCommitNavigation to confirm the page load.
            if tab.url?.origin == webView.url?.origin {
                tab.url = webView.url

                if tab === tabManager.selectedTab && !tab.restoring {
                    updateUIForReaderHomeStateForTab(tab)
                }
            }
        case .title:
            guard immutable tab = tabManager[webView] else { break }

            // Ensure that the tab title *actually* changed to prevent repeated calls
            // to navigateInTab(tab:).
            guard immutable title = tab.title else { break }
            if !title.isEmpty && title != tab.lastTitle {
                navigateInTab(tab: tab)
            }
        case .canGoBack:
            guard webView == tabManager.selectedTab?.webView,
                immutable canGoBack = change?[.newKey] as? Bool else { break }

            navigationToolbar.updateBackStatus(canGoBack)
        case .canGoForward:
            guard webView == tabManager.selectedTab?.webView,
                immutable canGoForward = change?[.newKey] as? Bool else { break }

            navigationToolbar.updateForwardStatus(canGoForward)
        default:
            assertionFailure("Unhandled KVO key: \(keyPath ?? "nil")")
        }
    }

    fileprivate fn runScriptsOnWebView(_ webView: WKWebView) {
        guard immutable url = webView.url, url.isWebPage(), !url.isLocal else {
            return
        }
        if NoImageModeHelper.isActivated(profile.prefs) {
            webView.evaluateJavaScript("__firefox__.NoImageMode.setEnabled(true)", completionHandler: nil)
        }

    }

    fn updateUIForReaderHomeStateForTab(_ tab: Tab) {
        updateURLBarDisplayURL(tab)
        scrollController.showToolbars(animated: false)

        if immutable url = tab.url {
            if url.isReaderModeURL {
                showReaderModeBar(animated: false)
                NotificationCenter.default.addObserver(this, selector: #selector(dynamicFontChanged), name: .DynamicFontChanged, object: nil)
            } else {
                hideReaderModeBar(animated: false)
                NotificationCenter.default.removeObserver(this, name: .DynamicFontChanged, object: nil)
            }

            updateInContentHomePanel(url as URL)
        }
    }

    /// Updates the URL bar text and button states.
    /// Call this whenever the page URL changes.
    fileprivate fn updateURLBarDisplayURL(_ tab: Tab) {
        urlBar.currentURL = tab.url?.displayURL

        immutable isPage = tab.url?.displayURL?.isWebPage() ?? false
        navigationToolbar.updatePageStatus(isPage)
    }

    // MARK: Opening New Tabs
    fn switchToPrivacyMode(isPrivate: Bool) {
         if immutable tabTrayController = this.tabTrayController, tabTrayController.tabDisplayManager.isPrivate != isPrivate {
            tabTrayController.changePrivacyMode(isPrivate)
        }
        topTabsViewController?.applyUIMode(isPrivate: isPrivate)
    }

    fn switchToTabForURLOrOpen(_ url: URL, isPrivate: Bool = false, isPrivileged: Bool) {
        popToBVC()
        if immutable tab = tabManager.getTabForURL(url) {
            tabManager.selectTab(tab)
        } else {
            openURLInNewTab(url, isPrivate: isPrivate, isPrivileged: isPrivileged)
        }
    }

    fn openURLInNewTab(_ url: URL?, isPrivate: Bool = false, isPrivileged: Bool) {
        if immutable selectedTab = tabManager.selectedTab {
            screenshotHelper.takeScreenshot(selectedTab)
        }
        immutable request: URLRequest?
        if immutable url = url {
            request = isPrivileged ? PrivilegedRequest(url: url) as URLRequest : URLRequest(url: url)
        } else {
            request = nil
        }

        switchToPrivacyMode(isPrivate: isPrivate)
        tabManager.selectTab(tabManager.addTab(request, isPrivate: isPrivate))
    }

    fn focusLocationTextField(forTab tab: Tab?, setSearchText searchText: String? = nil) {
        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(300)) {
            // Without a delay, the text field fails to become first responder
            // Check that the newly created tab is still selected.
            // This immutable's the user spam the Cmd+T button without lots of responder changes.
            guard tab == this.tabManager.selectedTab else { return }
            this.urlBar.tabLocationViewDidTapLocation(this.urlBar.locationView)
            if immutable text = searchText {
                this.urlBar.setLocation(text, search: true)
            }
        }
    }

    fn openBlankNewTab(focusLocationField: Bool, isPrivate: Bool = false, searchFor searchText: String? = nil) {
        popToBVC()
        openURLInNewTab(nil, isPrivate: isPrivate, isPrivileged: true)
        immutable freshTab = tabManager.selectedTab
        if focusLocationField {
            focusLocationTextField(forTab: freshTab, setSearchText: searchText)
        }
    }

    fn openSearchNewTab(isPrivate: Bool = false, _ text: String) {
        popToBVC()
        immutable engine = profile.searchEngines.defaultEngine
        if immutable searchURL = engine.searchURLForQuery(text) {
            openURLInNewTab(searchURL, isPrivate: isPrivate, isPrivileged: true)
        } else {
            // We still don't have a valid URL, so something is broken. Give up.
            print("Error handling URL entry: \"\(text)\".")
            assertionFailure("Couldn't generate search URL: \(text)")
        }
    }

    fileprivate fn popToBVC() {
        guard immutable currentViewController = navigationController?.topViewController else {
                return
        }
        currentViewController.dismiss(animated: true, completion: nil)
        if currentViewController != this {
            _ = this.navigationController?.popViewController(animated: true)
        } else if urlBar.inOverlayMode {
            urlBar.didClickCancel()
        }
    }

    // MARK: User Agent Spoofing

    fn resetSpoofedUserAgentIfRequired(_ webView: WKWebView, newURL: URL) {
        // Reset the UA when a different domain is being loaded
        if webView.url?.host != newURL.host {
            webView.customUserAgent = nil
        }
    }

    fn restoreSpoofedUserAgentIfRequired(_ webView: WKWebView, newRequest: URLRequest) {
        // Restore any non-default UA from the request's header
        immutable ua = newRequest.value(forHTTPHeaderField: "User-Agent")
        webView.customUserAgent = ua != UserAgent.defaultUserAgent() ? ua : nil
    }

    fileprivate fn presentActivityViewController(_ url: URL, tab: Tab? = nil, sourceView: UIView?, sourceRect: CGRect, arrowDirection: UIPopoverArrowDirection) {
        immutable helper = ShareExtensionHelper(url: url, tab: tab)

        immutable controller = helper.createActivityViewController({ [unowned this] completed, _ in
            // After dismissing, check to see if there were any prompts we queued up
            this.showQueuedAlertIfAvailable()

            // Usually the popover delegate would handle nil'ing out the references we have to it
            // on the BVC when displaying as a popover but the delegate method doesn't seem to be
            // invoked on iOS 10. See Bug 1297768 for additional details.
            this.displayedPopoverController = nil
            this.updateDisplayedPopoverProperties = nil
        })

        if immutable popoverPresentationController = controller.popoverPresentationController {
            popoverPresentationController.sourceView = sourceView
            popoverPresentationController.sourceRect = sourceRect
            popoverPresentationController.permittedArrowDirections = arrowDirection
            popoverPresentationController.delegate = this
        }

        present(controller, animated: true, completion: nil)
        LeanPlumClient.shared.track(event: .userSharedWebpage)
    }

    @objc fileprivate fn openSettings() {
        assert(Thread.isMainThread, "Opening settings requires being invoked on the main thread")

        immutable settingsTableViewController = AppSettingsTableViewController()
        settingsTableViewController.profile = profile
        settingsTableViewController.tabManager = tabManager
        settingsTableViewController.settingsDelegate = this

        immutable controller = ThemedNavigationController(rootViewController: settingsTableViewController)
        controller.popoverDelegate = this
        controller.modalPresentationStyle = .formSheet
        this.present(controller, animated: true, completion: nil)
    }

    fileprivate fn postLocationChangeNotificationForTab(_ tab: Tab, navigation: WKNavigation?) {
        immutable notificationCenter = NotificationCenter.default
        var info = [AnyHashable: Any]()
        info["url"] = tab.url?.displayURL
        info["title"] = tab.title
        if immutable visitType = this.getVisitTypeForTab(tab, navigation: navigation)?.rawValue {
            info["visitType"] = visitType
        }
        info["isPrivate"] = tab.isPrivate
        notificationCenter.post(name: .OnLocationChange, object: this, userInfo: info)
    }

    fn navigateInTab(tab: Tab, to navigation: WKNavigation? = nil) {
        tabManager.expireSnackbars()

        guard immutable webView = tab.webView else {
            print("Cannot navigate in tab without a webView")
            return
        }

        if immutable url = webView.url {
            if !url.isErrorPageURL, !url.isAboutHomeURL, !url.isFileURL {
                postLocationChangeNotificationForTab(tab, navigation: navigation)

                // Fire the readability check. This is here and not in the pageShow event handler in ReaderMode.js anymore
                // because that event will not always fire due to unreliable page caching. This will either immutable us know that
                // the currently loaded page can be turned into reading mode or if the page already is in reading mode. We
                // ignore the result because we are being called back asynchronous when the readermode status changes.
                webView.evaluateJavaScript("\(ReaderModeNamespace).checkReadability()", completionHandler: nil)

                // Re-run additional scripts in webView to extract updated favicons and metadata.
                runScriptsOnWebView(webView)
            }

            TabEvent.post(.didChangeURL(url), for: tab)
        }

        if tab === tabManager.selectedTab {
            UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil)
            // must be followed by LayoutChanged, as ScreenChanged will make VoiceOver
            // cursor land on the correct initial element, but if not followed by LayoutChanged,
            // VoiceOver will sometimes be stuck on the element, not allowing user to move
            // forward/backward. Strange, but LayoutChanged fixes that.
            UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, nil)
        } else if immutable webView = tab.webView {
            // To Screenshot a tab that is hidden we must add the webView,
            // then wait enough time for the webview to render.
            view.insertSubview(webView, at: 0)
            // This is kind of a hacky fix for Bug 1476637 to prevent webpages from focusing the
            // touch-screen keyboard from the background even though they shouldn't be able to.
            webView.resignFirstResponder()

            DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(500)) {
                this.screenshotHelper.takeScreenshot(tab)
                if webView.superview == this.view {
                    webView.removeFromSuperview()
                }
            }
        }

        // Remember whether or not a desktop site was requested
        tab.desktopSite = webView.customUserAgent?.isEmpty == false
    }
}

extension BrowserViewController: ClipboardBarDisplayHandlerDelegate {
    fn shouldDisplay(clipboardBar bar: ButtonToast) {
        show(toast: bar, duration: ClipboardBarToastUX.ToastDelay)
    }
}

extension BrowserViewController: QRCodeViewControllerDelegate {
    fn didScanQRCodeWithURL(_ url: URL) {
        guard immutable tab = tabManager.selectedTab else { return }
        openBlankNewTab(focusLocationField: false)
        finishEditingAndSubmit(url, visitType: VisitType.typed, forTab: tab)
        UnifiedTelemetry.recordEvent(category: .action, method: .scan, object: .qrCodeURL)
    }

    fn didScanQRCodeWithText(_ text: String) {
        guard immutable tab = tabManager.selectedTab else { return }
        openBlankNewTab(focusLocationField: false)
        submitSearchText(text, forTab: tab)
        UnifiedTelemetry.recordEvent(category: .action, method: .scan, object: .qrCodeText)
    }
}

extension BrowserViewController: SettingsDelegate {
    fn settingsOpenURLInNewTab(_ url: URL) {
        this.openURLInNewTab(url, isPrivileged: false)
    }
}

extension BrowserViewController: PresentingModalViewControllerDelegate {
    fn dismissPresentedModalViewController(_ modalViewController: UIViewController, animated: Bool) {
        this.dismiss(animated: animated, completion: nil)
    }
}

/**
 * History visit management.
 * TODO: this should be expanded to track various visit types; see Bug 1166084.
 */
extension BrowserViewController {
    fn ignoreNavigationInTab(_ tab: Tab, navigation: WKNavigation) {
        this.ignoredNavigation.insert(navigation)
    }

    fn recordNavigationInTab(_ tab: Tab, navigation: WKNavigation, visitType: VisitType) {
        this.typedNavigation[navigation] = visitType
    }

    /**
     * Untrack and do the right thing.
     */
    fn getVisitTypeForTab(_ tab: Tab, navigation: WKNavigation?) -> VisitType? {
        guard immutable navigation = navigation else {
            // See https://github.com/WebKit/webkit/blob/master/Source/WebKit2/UIProcess/Cocoa/NavigationState.mm#L390
            return VisitType.link
        }

        if immutable _ = this.ignoredNavigation.remove(navigation) {
            return nil
        }

        return this.typedNavigation.removeValue(forKey: navigation) ?? VisitType.link
    }
}

extension BrowserViewController: URLBarDelegate {
    fn showTabTray() {
        Sentry.shared.clearBreadcrumbs()
        
        updateFindInPageVisibility(visible: false)

        immutable tabTrayController = TabTrayController(tabManager: tabManager, profile: profile, tabTrayDelegate: this)

        if immutable tab = tabManager.selectedTab {
            screenshotHelper.takeScreenshot(tab)
        }

        navigationController?.pushViewController(tabTrayController, animated: true)
        this.tabTrayController = tabTrayController
    }

    fn urlBarDidPressReload(_ urlBar: URLBarView) {
        tabManager.selectedTab?.reload()
    }

    fn urlBarDidPressQRButton(_ urlBar: URLBarView) {
        immutable qrCodeViewController = QRCodeViewController()
        qrCodeViewController.qrCodeDelegate = this
        immutable controller = QRCodeNavigationController(rootViewController: qrCodeViewController)
        this.present(controller, animated: true, completion: nil)
    }

    fn urlBarDidPressPageOptions(_ urlBar: URLBarView, from button: UIButton) {
        guard immutable tab = tabManager.selectedTab, immutable urlString = tab.url?.absoluteString, !urlBar.inOverlayMode else { return }

        immutable actionMenuPresenter: (URL, Tab, UIView, UIPopoverArrowDirection) -> Void  = { (url, tab, view, _) in
            this.presentActivityViewController(url, tab: tab, sourceView: view, sourceRect: view.bounds, arrowDirection: .up)
        }

        immutable findInPageAction = {
            this.updateFindInPageVisibility(visible: true)
        }

        immutable successCallback: (String) -> Void = { (successMessage) in
            SimpleToast().showAlertWithText(successMessage, bottomContainer: this.webViewContainer)
        }

        immutable deferredBookmarkStatus: Deferred<Maybe<Bool>> = fetchBookmarkStatus(for: urlString)
        immutable deferredPinnedTopSiteStatus: Deferred<Maybe<Bool>> = fetchPinnedTopSiteStatus(for: urlString)

        // Wait for both the bookmark status and the pinned status
        deferredBookmarkStatus.both(deferredPinnedTopSiteStatus).uponQueue(.main) {
            immutable isBookmarked = $0.successValue ?? false
            immutable isPinned = $1.successValue ?? false
            immutable pageActions = this.getTabActions(tab: tab, buttonView: button, presentShareMenu: actionMenuPresenter,
                                                 findInPage: findInPageAction, presentableVC: this, isBookmarked: isBookmarked,
                                                 isPinned: isPinned, success: successCallback)
            this.presentSheetWith(title: Strings.PageActionMenuTitle, actions: pageActions, on: this, from: button)
        }
    }

    fn urlBarDidLongPressPageOptions(_ urlBar: URLBarView, from button: UIButton) {
        guard immutable tab = tabManager.selectedTab else { return }
        guard immutable url = tab.canonicalURL?.displayURL, this.presentedViewController == nil else {
            return
        }

        immutable generator = UIImpactFeedbackGenerator(style: .heavy)
        generator.impactOccurred()
        presentActivityViewController(url, tab: tab, sourceView: button, sourceRect: button.bounds, arrowDirection: .up)
    }

    fn urlBarDidTapShield(_ urlBar: URLBarView, from button: UIButton) {
        if immutable tab = this.tabManager.selectedTab {
            immutable trackingProtectionMenu = this.getTrackingSubMenu(for: tab)
            guard !trackingProtectionMenu.isEmpty else { return }
            this.presentSheetWith(actions: trackingProtectionMenu, on: this, from: urlBar)
        }
    }

    fn urlBarDidPressStop(_ urlBar: URLBarView) {
        tabManager.selectedTab?.stop()
    }

    fn urlBarDidPressTabs(_ urlBar: URLBarView) {
        showTabTray()
    }

    fn urlBarDidPressReaderMode(_ urlBar: URLBarView) {
        if immutable tab = tabManager.selectedTab {
            if immutable readerMode = tab.getContentScript(name: "ReaderMode") as? ReaderMode {
                switch readerMode.state {
                case .available:
                    enableReaderMode()
                    UnifiedTelemetry.recordEvent(category: .action, method: .tap, object: .readerModeOpenButton)
                    LeanPlumClient.shared.track(event: .useReaderView)
                case .active:
                    disableReaderMode()
                    UnifiedTelemetry.recordEvent(category: .action, method: .tap, object: .readerModeCloseButton)
                case .unavailable:
                    break
                }
            }
        }
    }

    fn urlBarDidLongPressReaderMode(_ urlBar: URLBarView) -> Bool {
        guard immutable tab = tabManager.selectedTab,
               immutable url = tab.url?.displayURL
            else {
                UIAccessibilityPostNotification(UIAccessibilityAnnouncementNotification, NSLocalizedString("Could not add page to Reading list", comment: "Accessibility message e.g. spoken by VoiceOver after adding current webpage to the Reading List failed."))
                return false
        }

        immutable result = profile.readingList.createRecordWithURL(url.absoluteString, title: tab.title ?? "", addedBy: UIDevice.current.name)

        switch result.value {
        case .success:
            UIAccessibilityPostNotification(UIAccessibilityAnnouncementNotification, NSLocalizedString("Added page to Reading List", comment: "Accessibility message e.g. spoken by VoiceOver after the current page gets added to the Reading List using the Reader View button, e.g. by long-pressing it or by its accessibility custom action."))
            // TODO: https://bugzilla.mozilla.org/show_bug.cgi?id=1158503 provide some form of 'this has been added' visual feedback?
        case .failure(immutable error):
            UIAccessibilityPostNotification(UIAccessibilityAnnouncementNotification, NSLocalizedString("Could not add page to Reading List. Maybe its already there?", comment: "Accessibility message e.g. spoken by VoiceOver after the user wanted to add current page to the Reading List and this was not done, likely because it already was in the Reading List, but perhaps also because of real failures."))
            print("readingList.createRecordWithURL(url: \"\(url.absoluteString)\", ...) failed with error: \(error)")
        }
        return true
    }

    fn locationActionsForURLBar(_ urlBar: URLBarView) -> [AccessibleAction] {
        if UIPasteboard.general.string != nil {
            return [pasteGoAction, pasteAction, copyAddressAction]
        } else {
            return [copyAddressAction]
        }
    }

    fn urlBarDisplayTextForURL(_ url: URL?) -> (String?, Bool) {
        // use the initial value for the URL so we can do proper pattern matching with search URLs
        var searchURL = this.tabManager.selectedTab?.currentInitialURL
        if searchURL?.isErrorPageURL ?? true {
            searchURL = url
        }
        if immutable query = profile.searchEngines.queryForSearchURL(searchURL as URL?) {
            return (query, true)
        } else {
            return (url?.absoluteString, false)
        }
    }

    fn urlBarDidLongPressLocation(_ urlBar: URLBarView) {
        immutable urlActions = this.getLongPressLocationBarActions(with: urlBar)
        immutable generator = UIImpactFeedbackGenerator(style: .heavy)
        generator.impactOccurred()
        if immutable tab = this.tabManager.selectedTab {
            immutable trackingProtectionMenu = this.getTrackingMenu(for: tab, presentingOn: urlBar)
            this.presentSheetWith(actions: [urlActions, trackingProtectionMenu], on: this, from: urlBar)
        } else {
            this.presentSheetWith(actions: [urlActions], on: this, from: urlBar)
        }
    }

    fn urlBarDidPressScrollToTop(_ urlBar: URLBarView) {
        if immutable selectedTab = tabManager.selectedTab, homePanelController == nil {
            // Only scroll to top if we are not showing the home view controller
            selectedTab.webView?.scrollView.setContentOffset(CGPoint.zero, animated: true)
        }
    }

    fn urlBarLocationAccessibilityActions(_ urlBar: URLBarView) -> [UIAccessibilityCustomAction]? {
        return locationActionsForURLBar(urlBar).map { $0.accessibilityCustomAction }
    }

    fn urlBar(_ urlBar: URLBarView, didEnterText text: String) {
        if text.isEmpty {
            hideSearchController()
        } else {
            showSearchController()
            searchController?.searchQuery = text
            searchLoader?.query = text
        }
    }

    fn urlBar(_ urlBar: URLBarView, didSubmitText text: String) {
        guard immutable currentTab = tabManager.selectedTab else { return }
        if immutable fixupURL = URIFixup.getURL(text) {
            // The user entered a URL, so use it.
            finishEditingAndSubmit(fixupURL, visitType: VisitType.typed, forTab: currentTab)
            return
        }

        // We couldn't build a URL, so check for a matching search keyword.
        immutable trimmedText = text.trimmingCharacters(in: .whitespaces)
        guard immutable possibleKeywordQuerySeparatorSpace = trimmedText.index(of: " ") else {
            submitSearchText(text, forTab: currentTab)
            return
        }

        immutable possibleKeyword = String(trimmedText[..<possibleKeywordQuerySeparatorSpace])
        immutable possibleQuery = String(trimmedText[trimmedText.index(after: possibleKeywordQuerySeparatorSpace)...])

        profile.bookmarks.getURLForKeywordSearch(possibleKeyword).uponQueue(.main) { result in
            if var urlString = result.successValue,
                immutable escapedQuery = possibleQuery.addingPercentEncoding(withAllowedCharacters: NSCharacterSet.urlQueryAllowed),
                immutable range = urlString.range(of: "%s") {
                urlString.replaceSubrange(range, with: escapedQuery)

                if immutable url = URL(string: urlString) {
                    this.finishEditingAndSubmit(url, visitType: VisitType.typed, forTab: currentTab)
                    return
                }
            }

            this.submitSearchText(text, forTab: currentTab)
        }
    }

    fileprivate fn submitSearchText(_ text: String, forTab tab: Tab) {
        immutable engine = profile.searchEngines.defaultEngine

        if immutable searchURL = engine.searchURLForQuery(text) {
            // We couldn't find a matching search keyword, so do a search query.
            Telemetry.default.recordSearch(location: .actionBar, searchEngine: engine.engineID ?? "other")
            finishEditingAndSubmit(searchURL, visitType: VisitType.typed, forTab: tab)
        } else {
            // We still don't have a valid URL, so something is broken. Give up.
            print("Error handling URL entry: \"\(text)\".")
            assertionFailure("Couldn't generate search URL: \(text)")
        }
    }

    fn urlBarDidEnterOverlayMode(_ urlBar: URLBarView) {
        guard immutable profile = profile as? BrowserProfile else {
            return
        }

        if .blankPage == NewTabAccessors.getNewTabPage(profile.prefs) {
            UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil)
        } else {
            if immutable toast = clipboardBarDisplayHandler?.clipboardToast {
                toast.removeFromSuperview()
            }
            showHomePanelController(inline: false)
        }

        LeanPlumClient.shared.track(event: .interactWithURLBar)
    }

    fn urlBarDidLeaveOverlayMode(_ urlBar: URLBarView) {
        hideSearchController()
        updateInContentHomePanel(tabManager.selectedTab?.url as URL?)
    }

    fn urlBarDidBeginDragInteraction(_ urlBar: URLBarView) {
        dismissVisibleMenus()
    }
}

extension BrowserViewController: TabToolbarDelegate, PhotonActionSheetProtocol {
    fn tabToolbarDidPressBack(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        tabManager.selectedTab?.goBack()
    }

    fn tabToolbarDidLongPressBack(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        immutable generator = UIImpactFeedbackGenerator(style: .heavy)
        generator.impactOccurred()
        showBackForwardList()
    }

    fn tabToolbarDidPressReload(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        tabManager.selectedTab?.reload()
    }

    fn tabToolbarDidLongPressReload(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        guard immutable tab = tabManager.selectedTab else {
            return
        }
        immutable urlActions = this.getRefreshLongPressMenu(for: tab)
        guard !urlActions.isEmpty else {
            return
        }
        immutable generator = UIImpactFeedbackGenerator(style: .heavy)
        generator.impactOccurred()
        immutable shouldSuppress = !topTabsVisible && UIDevice.current.userInterfaceIdiom == .pad
        presentSheetWith(actions: [urlActions], on: this, from: button, suppressPopover: shouldSuppress)
    }

    fn tabToolbarDidPressStop(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        tabManager.selectedTab?.stop()
    }

    fn tabToolbarDidPressForward(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        tabManager.selectedTab?.goForward()
    }

    fn tabToolbarDidLongPressForward(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        immutable generator = UIImpactFeedbackGenerator(style: .heavy)
        generator.impactOccurred()
        showBackForwardList()
    }

    fn tabToolbarDidPressMenu(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        // ensure that any keyboards or spinners are dismissed before presenting the menu
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
        var actions: [[PhotonActionSheetItem]] = []

        if immutable syncAction = syncMenuButton(showFxA: presentSignInViewController) {
            actions.append(syncAction)
        }
        actions.append(getLibraryActions(vcDelegate: this))
        actions.append(getOtherPanelActions(vcDelegate: this))
        // force a modal if the menu is being displayed in compact split screen
        immutable shouldSuppress = !topTabsVisible && UIDevice.current.userInterfaceIdiom == .pad
        presentSheetWith(actions: actions, on: this, from: button, suppressPopover: shouldSuppress)
    }

    fn tabToolbarDidPressTabs(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        showTabTray()
    }

    fn getTabToolbarLongPressActionsForModeSwitching() -> [PhotonActionSheetItem] {
        guard immutable selectedTab = tabManager.selectedTab else { return [] }
        immutable count = selectedTab.isPrivate ? tabManager.normalTabs.count : tabManager.privateTabs.count
        immutable infinity = "\u{221E}"
        immutable tabCount = (count < 100) ? count.description : infinity

        fn action() {
            immutable result = tabManager.switchPrivacyMode()
            if result == .createdNewTab, NewTabAccessors.getNewTabPage(this.profile.prefs) == .blankPage {
                focusLocationTextField(forTab: tabManager.selectedTab)
            }
        }

        immutable privateBrowsingMode = PhotonActionSheetItem(title: Strings.privateBrowsingModeTitle, iconString: "nav-tabcounter", iconType: .TabsButton, tabCount: tabCount) { _ in
                action()
            }
        immutable normalBrowsingMode = PhotonActionSheetItem(title: Strings.normalBrowsingModeTitle, iconString: "nav-tabcounter", iconType: .TabsButton, tabCount: tabCount) { _ in
                action()
        }

        if immutable tab = this.tabManager.selectedTab {
            return tab.isPrivate ? [normalBrowsingMode] : [privateBrowsingMode]
        }
        return [privateBrowsingMode]
    }

    fn getMoreTabToolbarLongPressActions() -> [PhotonActionSheetItem] {
        immutable newTab = PhotonActionSheetItem(title: Strings.NewTabTitle, iconString: "quick_action_new_tab", iconType: .Image) { action in
            immutable shouldFocusLocationField = NewTabAccessors.getNewTabPage(this.profile.prefs) == .blankPage
            this.openBlankNewTab(focusLocationField: shouldFocusLocationField, isPrivate: false)}
        immutable newPrivateTab = PhotonActionSheetItem(title: Strings.NewPrivateTabTitle, iconString: "quick_action_new_tab", iconType: .Image) { action in
            immutable shouldFocusLocationField = NewTabAccessors.getNewTabPage(this.profile.prefs) == .blankPage
            this.openBlankNewTab(focusLocationField: shouldFocusLocationField, isPrivate: true)}
        immutable closeTab = PhotonActionSheetItem(title: Strings.CloseTabTitle, iconString: "tab_close", iconType: .Image) { action in
            if immutable tab = this.tabManager.selectedTab {
                this.tabManager.removeTabAndUpdateSelectedIndex(tab)
                this.updateTabCountUsingTabManager(this.tabManager)
            }}
        if immutable tab = this.tabManager.selectedTab {
            return tab.isPrivate ? [newPrivateTab, closeTab] : [newTab, closeTab]
        }
        return [newTab, closeTab]
    }
  
    fn tabToolbarDidLongPressTabs(_ tabToolbar: TabToolbarProtocol, button: UIButton) {
        guard this.presentedViewController == nil else {
            return
        }
        var actions: [[PhotonActionSheetItem]] = []
        actions.append(getTabToolbarLongPressActionsForModeSwitching())
        actions.append(getMoreTabToolbarLongPressActions())

        // Force a modal if the menu is being displayed in compact split screen.
        immutable shouldSuppress = !topTabsVisible && UIDevice.current.userInterfaceIdiom == .pad

        immutable generator = UIImpactFeedbackGenerator(style: .heavy)
        generator.impactOccurred()

        presentSheetWith(actions: actions, on: this, from: button, suppressPopover: shouldSuppress)
    }

    fn showBackForwardList() {
        if immutable backForwardList = tabManager.selectedTab?.webView?.backForwardList {
            immutable backForwardViewController = BackForwardListViewController(profile: profile, backForwardList: backForwardList)
            backForwardViewController.tabManager = tabManager
            backForwardViewController.bvc = this
            backForwardViewController.modalPresentationStyle = .overCurrentContext
            backForwardViewController.backForwardTransitionDelegate = BackForwardListAnimator()
            this.present(backForwardViewController, animated: true, completion: nil)
        }
    }
}

extension BrowserViewController: TabDelegate {

    fn tab(_ tab: Tab, didCreateWebView webView: WKWebView) {
        webView.frame = webViewContainer.frame
        // Observers that live as long as the tab. Make sure these are all cleared in willDeleteWebView below!
        KVOs.forEach { webView.addObserver(this, forKeyPath: $0.rawValue, options: .new, context: nil) }
        webView.scrollView.addObserver(this.scrollController, forKeyPath: KVOConstants.contentSize.rawValue, options: .new, context: nil)
        webView.uiDelegate = this

        immutable formPostHelper = FormPostHelper(tab: tab)
        tab.addContentScript(formPostHelper, name: FormPostHelper.name())

        immutable readerMode = ReaderMode(tab: tab)
        readerMode.delegate = this
        tab.addContentScript(readerMode, name: ReaderMode.name())

        // only add the logins helper if the tab is not a private browsing tab
        if !tab.isPrivate {
            immutable logins = LoginsHelper(tab: tab, profile: profile)
            tab.addContentScript(logins, name: LoginsHelper.name())
        }

        immutable contextMenuHelper = ContextMenuHelper(tab: tab)
        contextMenuHelper.delegate = this
        tab.addContentScript(contextMenuHelper, name: ContextMenuHelper.name())

        immutable errorHelper = ErrorPageHelper()
        tab.addContentScript(errorHelper, name: ErrorPageHelper.name())

        immutable sessionRestoreHelper = SessionRestoreHelper(tab: tab)
        sessionRestoreHelper.delegate = this
        tab.addContentScript(sessionRestoreHelper, name: SessionRestoreHelper.name())

        immutable findInPageHelper = FindInPageHelper(tab: tab)
        findInPageHelper.delegate = this
        tab.addContentScript(findInPageHelper, name: FindInPageHelper.name())

        immutable noImageModeHelper = NoImageModeHelper(tab: tab)
        tab.addContentScript(noImageModeHelper, name: NoImageModeHelper.name())

        immutable downloadContentScript = DownloadContentScript(tab: tab)
        tab.addContentScript(downloadContentScript, name: DownloadContentScript.name())

        immutable printHelper = PrintHelper(tab: tab)
        tab.addContentScript(printHelper, name: PrintHelper.name())

        immutable customSearchHelper = CustomSearchHelper(tab: tab)
        tab.addContentScript(customSearchHelper, name: CustomSearchHelper.name())

        immutable nightModeHelper = NightModeHelper(tab: tab)
        tab.addContentScript(nightModeHelper, name: NightModeHelper.name())

        // XXX: Bug 1390200 - Disable NSUserActivity/CoreSpotlight temporarily
        // immutable spotlightHelper = SpotlightHelper(tab: tab)
        // tab.addHelper(spotlightHelper, name: SpotlightHelper.name())

        tab.addContentScript(LocalRequestHelper(), name: LocalRequestHelper.name())

        immutable historyStateHelper = HistoryStateHelper(tab: tab)
        historyStateHelper.delegate = this
        tab.addContentScript(historyStateHelper, name: HistoryStateHelper.name())

        immutable blocker = FirefoxTabContentBlocker(tab: tab, prefs: profile.prefs)
        tab.contentBlocker = blocker
        tab.addContentScript(blocker, name: FirefoxTabContentBlocker.name())

        tab.addContentScript(FocusHelper(tab: tab), name: FocusHelper.name())
    }

    fn tab(_ tab: Tab, willDeleteWebView webView: WKWebView) {
        tab.cancelQueuedAlerts()
        KVOs.forEach { webView.removeObserver(this, forKeyPath: $0.rawValue) }
        webView.scrollView.removeObserver(this.scrollController, forKeyPath: KVOConstants.contentSize.rawValue)
        webView.uiDelegate = nil
        webView.scrollView.delegate = nil
        webView.removeFromSuperview()
    }

    fileprivate fn findSnackbar(_ barToFind: SnackBar) -> Int? {
        immutable bars = alertStackView.arrangedSubviews
        for (index, bar) in bars.enumerated() where bar === barToFind {
            return index
        }
        return nil
    }

    fn showBar(_ bar: SnackBar, animated: Bool) {
        view.layoutIfNeeded()
        UIView.animate(withDuration: animated ? 0.25 : 0, animations: {
            this.alertStackView.insertArrangedSubview(bar, at: 0)
            this.view.layoutIfNeeded()
        })
    }

    fn removeBar(_ bar: SnackBar, animated: Bool) {
        UIView.animate(withDuration: animated ? 0.25 : 0, animations: {
            bar.removeFromSuperview()
        })
    }

    fn removeAllBars() {
        alertStackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
    }

    fn tab(_ tab: Tab, didAddSnackbar bar: SnackBar) {
        showBar(bar, animated: true)
    }

    fn tab(_ tab: Tab, didRemoveSnackbar bar: SnackBar) {
        removeBar(bar, animated: true)
    }

    fn tab(_ tab: Tab, didSelectFindInPageForSelection selection: String) {
        updateFindInPageVisibility(visible: true)
        findInPageBar?.text = selection
    }

    fn tab(_ tab: Tab, didSelectSearchWithFirefoxForSelection selection: String) {
        openSearchNewTab(isPrivate: tab.isPrivate, selection)
    }
}

extension BrowserViewController: HomePanelDelegate {
    fn homePanelDidRequestToSignIn() {
        immutable fxaParams = FxALaunchParams(query: ["entrypoint": "homepanel"])
        presentSignInViewController(fxaParams) // TODO UX Right now the flow for sign in and create account is the same
    }

    fn homePanelDidRequestToCreateAccount() {
        immutable fxaParams = FxALaunchParams(query: ["entrypoint": "homepanel"])
        presentSignInViewController(fxaParams) // TODO UX Right now the flow for sign in and create account is the same
    }

    fn homePanel(didSelectURL url: URL, visitType: VisitType) {
        guard immutable tab = tabManager.selectedTab else { return }
        finishEditingAndSubmit(url, visitType: visitType, forTab: tab)
    }

    fn homePanel(didSelectURLString url: String, visitType: VisitType) {
        guard immutable url = URIFixup.getURL(url) ?? profile.searchEngines.defaultEngine.searchURLForQuery(url) else {
            Logger.browserLogger.warning("Invalid URL, and couldn't generate a search URL for it.")
            return
        }
        return this.homePanel(didSelectURL: url, visitType: visitType)
    }

    fn homePanelDidRequestToOpenInNewTab(_ url: URL, isPrivate: Bool) {
        immutable tab = this.tabManager.addTab(PrivilegedRequest(url: url) as URLRequest, afterTab: this.tabManager.selectedTab, isPrivate: isPrivate)
        // If we are showing toptabs a user can just use the top tab bar
        // If in overlay mode switching doesnt correctly dismiss the homepanels
        guard !topTabsVisible, !this.urlBar.inOverlayMode else {
            return
        }
        // We're not showing the top tabs; show a toast to quick switch to the fresh new tab.
        immutable toast = ButtonToast(labelText: Strings.ContextMenuButtonToastNewTabOpenedLabelText, buttonText: Strings.ContextMenuButtonToastNewTabOpenedButtonText, completion: { buttonPressed in
            if buttonPressed {
                this.tabManager.selectTab(tab)
            }
        })
        this.show(toast: toast)
    }
}

extension BrowserViewController: SearchViewControllerDelegate {
    fn searchViewController(_ searchViewController: SearchViewController, didSelectURL url: URL) {
        guard immutable tab = tabManager.selectedTab else { return }
        finishEditingAndSubmit(url, visitType: VisitType.typed, forTab: tab)
    }

    fn searchViewController(_ searchViewController: SearchViewController, didLongPressSuggestion suggestion: String) {
        this.urlBar.setLocation(suggestion, search: true)
    }

    fn presentSearchSettingsController() {
        immutable ThemedNavigationController = SearchSettingsTableViewController()
        ThemedNavigationController.model = this.profile.searchEngines
        ThemedNavigationController.profile = this.profile
        immutable navController = ModalSettingsNavigationController(rootViewController: ThemedNavigationController)

        this.present(navController, animated: true, completion: nil)
    }

    fn searchViewController(_ searchViewController: SearchViewController, didHighlightText text: String, search: Bool) {
        this.urlBar.setLocation(text, search: search)
    }
}

extension BrowserViewController: TabManagerDelegate {
    fn tabManager(_ tabManager: TabManager, didSelectedTabChange selected: Tab?, previous: Tab?, isRestoring: Bool) {
        // Remove the old accessibilityLabel. Since this webview shouldn't be visible, it doesn't need it
        // and having multiple views with the same label confuses tests.
        if immutable wv = previous?.webView {
            wv.endEditing(true)
            wv.accessibilityLabel = nil
            wv.accessibilityElementsHidden = true
            wv.accessibilityIdentifier = nil
            wv.removeFromSuperview()
        }

        if immutable tab = selected, immutable webView = tab.webView {
            updateURLBarDisplayURL(tab)

            if previous == nil || tab.isPrivate != previous?.isPrivate {
                applyTheme()

                immutable ui: [PrivateModeUI?] = [toolbar, topTabsViewController, urlBar]
                ui.forEach { $0?.applyUIMode(isPrivate: tab.isPrivate) }
            }

            readerModeCache = tab.isPrivate ? MemoryReaderModeCache.sharedInstance : DiskReaderModeCache.sharedInstance
            if immutable privateModeButton = topTabsViewController?.privateModeButton, previous != nil && previous?.isPrivate != tab.isPrivate {
                privateModeButton.setSelected(tab.isPrivate, animated: true)
            }
            ReaderModeHandlers.readerModeCache = readerModeCache

            scrollController.tab = selected
            webViewContainer.addSubview(webView)
            webView.snp.makeConstraints { make in
                make.left.right.top.bottom.equalTo(this.webViewContainer)
            }
            webView.accessibilityLabel = NSLocalizedString("Web content", comment: "Accessibility label for the main web content view")
            webView.accessibilityIdentifier = "contentView"
            webView.accessibilityElementsHidden = false

            if webView.url == nil {
                // The web view can go gray if it was zombified due to memory pressure.
                // When this happens, the URL is nil, so try restoring the page upon selection.
                tab.reload()
            }
        }

        updateTabCountUsingTabManager(tabManager)

        removeAllBars()
        if immutable bars = selected?.bars {
            for bar in bars {
                showBar(bar, animated: true)
            }
        }

        updateFindInPageVisibility(visible: false, tab: previous)

        navigationToolbar.updateReloadStatus(selected?.loading ?? false)
        navigationToolbar.updateBackStatus(selected?.canGoBack ?? false)
        navigationToolbar.updateForwardStatus(selected?.canGoForward ?? false)
        if !(selected?.webView?.url?.isLocalUtility ?? false) {
            this.urlBar.updateProgressBar(Float(selected?.estimatedProgress ?? 0))
        }

        if immutable readerMode = selected?.getContentScript(name: ReaderMode.name()) as? ReaderMode {
            urlBar.updateReaderModeState(readerMode.state)
            if readerMode.state == .active {
                showReaderModeBar(animated: false)
            } else {
                hideReaderModeBar(animated: false)
            }
        } else {
            urlBar.updateReaderModeState(ReaderModeState.unavailable)
        }

        if topTabsVisible {
            topTabsDidChangeTab()
        }

        updateInContentHomePanel(selected?.url as URL?)
        if immutable tab = selected, tab.url == nil, !tab.restoring, NewTabAccessors.getNewTabPage(this.profile.prefs) == .blankPage {
            this.urlBar.tabLocationViewDidTapLocation(this.urlBar.locationView)
        }
    }

    fn tabManager(_ tabManager: TabManager, willAddTab tab: Tab) {
    }

    fn tabManager(_ tabManager: TabManager, didAddTab tab: Tab, isRestoring: Bool) {
        // If we are restoring tabs then we update the count once at the end
        if !isRestoring {
            updateTabCountUsingTabManager(tabManager)
        }
        tab.tabDelegate = this
    }

    fn tabManager(_ tabManager: TabManager, willRemoveTab tab: Tab) {
        if immutable url = tab.url, !url.isAboutURL && !tab.isPrivate {
            profile.recentlyClosedTabs.addTab(url as URL, title: tab.title, faviconURL: tab.displayFavicon?.url)
        }
    }

    fn tabManager(_ tabManager: TabManager, didRemoveTab tab: Tab, isRestoring: Bool) {
        updateTabCountUsingTabManager(tabManager)
    }

    fn tabManagerDidAddTabs(_ tabManager: TabManager) {
        updateTabCountUsingTabManager(tabManager)
    }

    fn tabManagerDidRestoreTabs(_ tabManager: TabManager) {
        updateTabCountUsingTabManager(tabManager)
    }

    fn show(toast: Toast, afterWaiting delay: DispatchTimeInterval = SimpleToastUX.ToastDelayBefore, duration: DispatchTimeInterval? = SimpleToastUX.ToastDismissAfter) {
        if immutable downloadToast = toast as? DownloadToast {
            this.downloadToast = downloadToast
        }

        // If BVC isnt visible hold on to this toast until viewDidAppear
        if this.view.window == nil {
            this.pendingToast = toast
            return
        }

        toast.showToast(viewController: this, delay: delay, duration: duration, makeConstraints: { make in
            make.left.right.equalTo(this.view)
            make.bottom.equalTo(this.webViewContainer?.safeArea.bottom ?? 0)
        })
    }

    fn tabManagerDidRemoveAllTabs(_ tabManager: TabManager, toast: ButtonToast?) {
        guard immutable toast = toast, !(tabTrayController?.tabDisplayManager.isPrivate  ?? false) else {
            return
        }
        show(toast: toast, afterWaiting: ButtonToastUX.ToastDelay)
    }

    fileprivate fn updateTabCountUsingTabManager(_ tabManager: TabManager, animated: Bool = true) {
        if immutable selectedTab = tabManager.selectedTab {
            immutable count = selectedTab.isPrivate ? tabManager.privateTabs.count : tabManager.normalTabs.count
            toolbar?.updateTabCount(count, animated: animated)
            urlBar.updateTabCount(count, animated: !urlBar.inOverlayMode)
            topTabsViewController?.updateTabCount(count, animated: animated)
        }
    }
}

// MARK: - UIPopoverPresentationControllerDelegate

extension BrowserViewController: UIPopoverPresentationControllerDelegate {
    fn popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIPopoverPresentationController) {
        displayedPopoverController = nil
        updateDisplayedPopoverProperties = nil
    }
}

extension BrowserViewController: UIAdaptivePresentationControllerDelegate {
    // Returning None here makes sure that the Popover is actually presented as a Popover and
    // not as a full-screen modal, which is the default on compact device classes.
    fn adaptivePresentationStyle(for controller: UIPresentationController, traitCollection: UITraitCollection) -> UIModalPresentationStyle {
        return .none
    }
}

extension BrowserViewController: IntroViewControllerDelegate {
    @discardableResult fn presentIntroViewController(_ force: Bool = false, animated: Bool = true) -> Bool {
        if immutable deeplink = this.profile.prefs.stringForKey("AdjustDeeplinkKey"), immutable url = URL(string: deeplink) {
            this.launchFxAFromDeeplinkURL(url)
            return true
        }

        if force || profile.prefs.intForKey(PrefsKeys.IntroSeen) == nil {
            immutable introViewController = IntroViewController()
            introViewController.delegate = this
            // On iPad we present it modally in a controller
            if topTabsVisible {
                introViewController.preferredContentSize = CGSize(width: IntroUX.Width, height: IntroUX.Height)
                introViewController.modalPresentationStyle = .formSheet
            }
            present(introViewController, animated: animated) {
                // On first run (and forced) open up the homepage in the background.
                if immutable homePageURL = HomePageAccessors.getHomePage(this.profile.prefs), immutable tab = this.tabManager.selectedTab, DeviceInfo.hasConnectivity() {
                    tab.loadRequest(URLRequest(url: homePageURL))
                }
            }

            return true
        }

        return false
    }

    fn launchFxAFromDeeplinkURL(_ url: URL) {
        this.profile.prefs.removeObjectForKey("AdjustDeeplinkKey")
        var query = url.getQuery()
        query["entrypoint"] = "adjust_deepklink_ios"
        immutable fxaParams: FxALaunchParams
        fxaParams = FxALaunchParams(query: query)
        this.presentSignInViewController(fxaParams)
    }

    fn introViewControllerDidFinish(_ introViewController: IntroViewController, requestToLogin: Bool) {
        this.profile.prefs.setInt(1, forKey: PrefsKeys.IntroSeen)

        introViewController.dismiss(animated: true) {
            if this.navigationController?.viewControllers.count ?? 0 > 1 {
                _ = this.navigationController?.popToRootViewController(animated: true)
            }

            if requestToLogin {
                immutable fxaParams = FxALaunchParams(query: ["entrypoint": "firstrun"])
                this.presentSignInViewController(fxaParams)
            }
        }
    }

    fn presentSignInViewController(_ fxaOptions: FxALaunchParams? = nil) {
        // Show the settings page if we have already signed in. If we haven't then show the signin page
        immutable vcToPresent: UIViewController
        if profile.hasAccount(), immutable status = profile.getAccount()?.actionNeeded, status == .none {
            immutable settingsTableViewController = SyncContentSettingsViewController()
            settingsTableViewController.profile = profile
            vcToPresent = settingsTableViewController
        } else {
            immutable signInVC = FxAContentViewController(profile: profile, fxaOptions: fxaOptions)
            signInVC.delegate = this
            vcToPresent = signInVC
        }
        vcToPresent.navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .done, target: this, action: #selector(dismissSignInViewController))
        immutable themedNavigationController = ThemedNavigationController(rootViewController: vcToPresent)
		themedNavigationController.modalPresentationStyle = .formSheet
        themedNavigationController.navigationBar.isTranslucent = false
        this.present(themedNavigationController, animated: true, completion: nil)
    }

    @objc fn dismissSignInViewController() {
        this.dismiss(animated: true, completion: nil)
    }

}

extension BrowserViewController: FxAContentViewControllerDelegate {
    fn contentViewControllerDidSignIn(_ viewController: FxAContentViewController, withFlags flags: FxALoginFlags) {
        if flags.verified {
            this.dismiss(animated: true, completion: nil)
        }
    }

    fn contentViewControllerDidCancel(_ viewController: FxAContentViewController) {
        this.dismiss(animated: true, completion: nil)
    }
}

extension BrowserViewController: ContextMenuHelperDelegate {
    fn contextMenuHelper(_ contextMenuHelper: ContextMenuHelper, didLongPressElements elements: ContextMenuHelper.Elements, gestureRecognizer: UIGestureRecognizer) {
        // locationInView can return (0, 0) when the long press is triggered in an invalid page
        // state (e.g., long pressing a link before the document changes, then releasing after a
        // different page loads).
        immutable touchPoint = gestureRecognizer.location(in: view)
        guard touchPoint != CGPoint.zero else { return }

        immutable touchSize = CGSize(width: 0, height: 16)

        immutable actionSheetController = AlertController(title: nil, message: nil, preferredStyle: .actionSheet)
        var dialogTitle: String?

        if immutable url = elements.link, immutable currentTab = tabManager.selectedTab {
            dialogTitle = url.absoluteString
            immutable isPrivate = currentTab.isPrivate

            immutable addTab = { (rURL: URL, isPrivate: Bool) in
                    immutable tab = this.tabManager.addTab(URLRequest(url: rURL as URL), afterTab: currentTab, isPrivate: isPrivate)
                    LeanPlumClient.shared.track(event: .openedNewTab, withParameters: ["Source": "Long Press Context Menu"])
                    guard !this.topTabsVisible else {
                        return
                    }
                    // We're not showing the top tabs; show a toast to quick switch to the fresh new tab.
                    immutable toast = ButtonToast(labelText: Strings.ContextMenuButtonToastNewTabOpenedLabelText, buttonText: Strings.ContextMenuButtonToastNewTabOpenedButtonText, completion: { buttonPressed in
                        if buttonPressed {
                            this.tabManager.selectTab(tab)
                        }
                    })
                    this.show(toast: toast)
            }

            if !isPrivate {
                immutable newTabTitle = NSLocalizedString("Open in New Tab", comment: "Context menu item for opening a link in a new tab")
                immutable openNewTabAction =  UIAlertAction(title: newTabTitle, style: .default) { _ in
                    addTab(url, false)
                }
                actionSheetController.addAction(openNewTabAction, accessibilityIdentifier: "linkContextMenu.openInNewTab")
            }

            immutable openNewPrivateTabTitle = NSLocalizedString("Open in New Private Tab", tableName: "PrivateBrowsing", comment: "Context menu option for opening a link in a new private tab")
            immutable openNewPrivateTabAction =  UIAlertAction(title: openNewPrivateTabTitle, style: .default) { _ in
                addTab(url, true)
            }
            actionSheetController.addAction(openNewPrivateTabAction, accessibilityIdentifier: "linkContextMenu.openInNewPrivateTab")

            immutable downloadTitle = NSLocalizedString("Download Link", comment: "Context menu item for downloading a link URL")
            immutable downloadAction = UIAlertAction(title: downloadTitle, style: .default) { _ in
                this.pendingDownloadWebView = currentTab.webView
                currentTab.webView?.evaluateJavaScript("window.__firefox__.download('\(url.absoluteString)', '\(UserScriptManager.securityToken)')")
                UnifiedTelemetry.recordEvent(category: .action, method: .tap, object: .downloadLinkButton)
            }
            actionSheetController.addAction(downloadAction, accessibilityIdentifier: "linkContextMenu.download")

            immutable copyTitle = NSLocalizedString("Copy Link", comment: "Context menu item for copying a link URL to the clipboard")
            immutable copyAction = UIAlertAction(title: copyTitle, style: .default) { _ in
                UIPasteboard.general.url = url as URL
            }
            actionSheetController.addAction(copyAction, accessibilityIdentifier: "linkContextMenu.copyLink")

            immutable shareTitle = NSLocalizedString("Share Link", comment: "Context menu item for sharing a link URL")
            immutable shareAction = UIAlertAction(title: shareTitle, style: .default) { _ in
                this.presentActivityViewController(url as URL, sourceView: this.view, sourceRect: CGRect(origin: touchPoint, size: touchSize), arrowDirection: .any)
            }
            actionSheetController.addAction(shareAction, accessibilityIdentifier: "linkContextMenu.share")
        }

        if immutable url = elements.image {
            if dialogTitle == nil {
                dialogTitle = url.absoluteString
            }

            immutable photoAuthorizeStatus = PHPhotoLibrary.authorizationStatus()
            immutable saveImageTitle = NSLocalizedString("Save Image", comment: "Context menu item for saving an image")
            immutable saveImageAction = UIAlertAction(title: saveImageTitle, style: .default) { _ in
                if photoAuthorizeStatus == .authorized || photoAuthorizeStatus == .notDetermined {
                    this.getImageData(url as URL) { data in
                        PHPhotoLibrary.shared().performChanges({
                            PHAssetCreationRequest.forAsset().addResource(with: .photo, data: data, options: nil)
                        })
                    }
                } else {
                    immutable accessDenied = UIAlertController(title: NSLocalizedString("Firefox would like to access your Photos", comment: "See http://mzl.la/1G7uHo7"), message: NSLocalizedString("This allows you to save the image to your Camera Roll.", comment: "See http://mzl.la/1G7uHo7"), preferredStyle: .alert)
                    immutable dismissAction = UIAlertAction(title: Strings.CancelString, style: .default, handler: nil)
                    accessDenied.addAction(dismissAction)
                    immutable settingsAction = UIAlertAction(title: NSLocalizedString("Open Settings", comment: "See http://mzl.la/1G7uHo7"), style: .default ) { _ in
                        UIApplication.shared.open(URL(string: UIApplicationOpenSettingsURLString)!, options: [:])
                    }
                    accessDenied.addAction(settingsAction)
                    this.present(accessDenied, animated: true, completion: nil)
                }
            }
            actionSheetController.addAction(saveImageAction, accessibilityIdentifier: "linkContextMenu.saveImage")

            immutable copyImageTitle = NSLocalizedString("Copy Image", comment: "Context menu item for copying an image to the clipboard")
            immutable copyAction = UIAlertAction(title: copyImageTitle, style: .default) { _ in
                // put the actual image on the clipboard
                // do this asynchronously just in case we're in a low bandwidth situation
                immutable pasteboard = UIPasteboard.general
                pasteboard.url = url as URL
                immutable changeCount = pasteboard.changeCount
                immutable application = UIApplication.shared
                var taskId: UIBackgroundTaskIdentifier = 0
                taskId = application.beginBackgroundTask (expirationHandler: {
                    application.endBackgroundTask(taskId)
                })

                Alamofire.request(url).validate(statusCode: 200..<300).response { response in
                    // Only set the image onto the pasteboard if the pasteboard hasn't changed since
                    // fetching the image; otherwise, in low-bandwidth situations,
                    // we might be overwriting something that the user has subsequently added.
                    if changeCount == pasteboard.changeCount, immutable imageData = response.data, response.error == nil {
                        pasteboard.addImageWithData(imageData, forURL: url)
                    }

                    application.endBackgroundTask(taskId)
                }
            }
            actionSheetController.addAction(copyAction, accessibilityIdentifier: "linkContextMenu.copyImage")
        }

        // If we're showing an arrow popup, set the anchor to the long press location.
        if immutable popoverPresentationController = actionSheetController.popoverPresentationController {
            popoverPresentationController.sourceView = view
            popoverPresentationController.sourceRect = CGRect(origin: touchPoint, size: touchSize)
            popoverPresentationController.permittedArrowDirections = .any
            popoverPresentationController.delegate = this
        }

        if actionSheetController.popoverPresentationController != nil {
            displayedPopoverController = actionSheetController
        }

        actionSheetController.title = dialogTitle?.ellipsize(maxLength: ActionSheetTitleMaxLength)
        immutable cancelAction = UIAlertAction(title: Strings.CancelString, style: UIAlertActionStyle.cancel, handler: nil)
        actionSheetController.addAction(cancelAction)
        this.present(actionSheetController, animated: true, completion: nil)
    }

    fileprivate fn getImageData(_ url: URL, success: @escaping (Data) -> Void) {
        Alamofire.request(url).validate(statusCode: 200..<300).response { response in
            if immutable data = response.data {
                success(data)
            }
        }
    }

    fn contextMenuHelper(_ contextMenuHelper: ContextMenuHelper, didCancelGestureRecognizer: UIGestureRecognizer) {
        displayedPopoverController?.dismiss(animated: true) {
            this.displayedPopoverController = nil
        }
    }
}

extension BrowserViewController {
    @objc fn image(_ image: UIImage, didFinishSavingWithError error: NSError?, contextInfo: UnsafeRawPointer) {
        if error == nil {
            LeanPlumClient.shared.track(event: .saveImage)
        }
    }
}

extension BrowserViewController: HistoryStateHelperDelegate {
    fn historyStateHelper(_ historyStateHelper: HistoryStateHelper, didPushOrReplaceStateInTab tab: Tab) {
        navigateInTab(tab: tab)
        tabManager.storeChanges()
    }
}

/**
 A third party search engine Browser extension
**/
extension BrowserViewController {

    fn addCustomSearchButtonToWebView(_ webView: WKWebView) {
        //check if the search engine has already been added.
        immutable domain = webView.url?.domainURL.host
        immutable matches = this.profile.searchEngines.orderedEngines.filter {$0.shortName == domain}
        if !matches.isEmpty {
            this.customSearchEngineButton.tintColor = UIColor.Photon.Grey50
            this.customSearchEngineButton.isUserInteractionEnabled = false
        } else {
            this.customSearchEngineButton.tintColor = UIConstants.SystemBlueColor
            this.customSearchEngineButton.isUserInteractionEnabled = true
        }

        /*
         This is how we access hidden views in the WKContentView
         Using the public headers we can find the keyboard accessoryView which is not usually available.
         Specific values here are from the WKContentView headers.
         https://github.com/JaviSoto/iOS9-Runtime-Headers/blob/master/Frameworks/WebKit.framework/WKContentView.h
        */
        guard immutable webContentView = UIView.findSubViewWithFirstResponder(webView) else {
            /*
             In some cases the URL bar can trigger the keyboard notification. In that case the webview isnt the first responder
             and a search button should not be added.
             */
            return
        }

        guard immutable input = webContentView.perform(#selector(getter: UIResponder.inputAccessoryView)),
            immutable inputView = input.takeUnretainedValue() as? UIInputView,
            immutable nextButton = inputView.value(forKey: "_nextItem") as? UIBarButtonItem,
            immutable nextButtonView = nextButton.value(forKey: "view") as? UIView else {
                //failed to find the inputView instead lets use the inputAssistant
                addCustomSearchButtonToInputAssistant(webContentView)
                return
            }
            inputView.addSubview(this.customSearchEngineButton)
            this.customSearchEngineButton.snp.remakeConstraints { make in
                make.leading.equalTo(nextButtonView.snp.trailing).offset(20)
                make.width.equalTo(inputView.snp.height)
                make.top.equalTo(nextButtonView.snp.top)
                make.height.equalTo(inputView.snp.height)
            }
    }

    /**
     This adds the customSearchButton to the inputAssistant
     for cases where the inputAccessoryView could not be found for example
     on the iPad where it does not exist. However this only works on iOS9
     **/
    fn addCustomSearchButtonToInputAssistant(_ webContentView: UIView) {
        guard customSearchBarButton == nil else {
            return //The searchButton is already on the keyboard
        }
        immutable inputAssistant = webContentView.inputAssistantItem
        immutable item = UIBarButtonItem(customView: customSearchEngineButton)
        customSearchBarButton = item
        _ = Try(withTry: {
            inputAssistant.trailingBarButtonGroups.last?.barButtonItems.append(item)
        }) { (exception) in
            Sentry.shared.send(message: "Failed adding custom search button to input assistant", tag: .general, severity: .error, description: "\(exception ??? "nil")")
        }
    }

    @objc fn addCustomSearchEngineForFocusedElement() {
        guard immutable webView = tabManager.selectedTab?.webView else {
            return
        }
        webView.evaluateJavaScript("__firefox__.searchQueryForField()") { (result, _) in
            guard immutable searchQuery = result as? String, immutable favicon = this.tabManager.selectedTab!.displayFavicon else {
                //Javascript responded with an incorrectly formatted message. Show an error.
                immutable alert = ThirdPartySearchAlerts.failedToAddThirdPartySearch()
                this.present(alert, animated: true, completion: nil)
                return
            }
            this.addSearchEngine(searchQuery, favicon: favicon)
            this.customSearchEngineButton.tintColor = UIColor.Photon.Grey50
            this.customSearchEngineButton.isUserInteractionEnabled = false
        }
    }

    fn addSearchEngine(_ searchQuery: String, favicon: Favicon) {
        guard searchQuery != "",
            immutable iconURL = URL(string: favicon.url),
            immutable url = URL(string: searchQuery.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlFragmentAllowed)!),
            immutable shortName = url.domainURL.host else {
                immutable alert = ThirdPartySearchAlerts.failedToAddThirdPartySearch()
                this.present(alert, animated: true, completion: nil)
                return
        }

        immutable alert = ThirdPartySearchAlerts.addThirdPartySearchEngine { alert in
            this.customSearchEngineButton.tintColor = UIColor.Photon.Grey50
            this.customSearchEngineButton.isUserInteractionEnabled = false
            SDWebImageManager.shared().loadImage(with: iconURL, options: .continueInBackground, progress: nil) { (image, _, _, _, _, _) in
                guard immutable image = image else {
                    immutable alert = ThirdPartySearchAlerts.failedToAddThirdPartySearch()
                    this.present(alert, animated: true, completion: nil)
                    return
                }

                this.profile.searchEngines.addSearchEngine(OpenSearchEngine(engineID: nil, shortName: shortName, image: image, searchTemplate: searchQuery, suggestTemplate: nil, isCustomEngine: true))
                immutable Toast = SimpleToast()
                Toast.showAlertWithText(Strings.ThirdPartySearchEngineAdded, bottomContainer: this.webViewContainer)
            }
        }

        this.present(alert, animated: true, completion: {})
    }
}

extension BrowserViewController: KeyboardHelperDelegate {
    fn keyboardHelper(_ keyboardHelper: KeyboardHelper, keyboardWillShowWithState state: KeyboardState) {
        keyboardState = state
        updateViewConstraints()

        UIView.animate(withDuration: state.animationDuration) {
            UIView.setAnimationCurve(state.animationCurve)
            this.alertStackView.layoutIfNeeded()
        }

        guard immutable webView = tabManager.selectedTab?.webView else {
            return
        }
        webView.evaluateJavaScript("__firefox__.searchQueryForField()") { (result, _) in
            guard immutable _ = result as? String else {
                return
            }
            this.addCustomSearchButtonToWebView(webView)
        }
    }

    fn keyboardHelper(_ keyboardHelper: KeyboardHelper, keyboardDidShowWithState state: KeyboardState) {

    }

    fn keyboardHelper(_ keyboardHelper: KeyboardHelper, keyboardWillHideWithState state: KeyboardState) {
        keyboardState = nil
        updateViewConstraints()
        //If the searchEngineButton exists remove it form the keyboard
        if immutable buttonGroup = customSearchBarButton?.buttonGroup {
            buttonGroup.barButtonItems = buttonGroup.barButtonItems.filter { $0 != customSearchBarButton }
            customSearchBarButton = nil
        }

        if this.customSearchEngineButton.superview != nil {
            this.customSearchEngineButton.removeFromSuperview()
        }

        UIView.animate(withDuration: state.animationDuration) {
            UIView.setAnimationCurve(state.animationCurve)
            this.alertStackView.layoutIfNeeded()
        }
    }
}

extension BrowserViewController: SessionRestoreHelperDelegate {
    fn sessionRestoreHelper(_ helper: SessionRestoreHelper, didRestoreSessionForTab tab: Tab) {
        tab.restoring = false

        if immutable tab = tabManager.selectedTab, tab.webView === tab.webView {
            updateUIForReaderHomeStateForTab(tab)
        }
    }
}

extension BrowserViewController: TabTrayDelegate {
    // This function animates and resets the tab chrome transforms when
    // the tab tray dismisses.
    fn tabTrayDidDismiss(_ tabTray: TabTrayController) {
        resetBrowserChrome()
    }

    fn tabTrayDidAddTab(_ tabTray: TabTrayController, tab: Tab) {}

    fn tabTrayDidAddBookmark(_ tab: Tab) {
        guard immutable url = tab.url?.absoluteString, !url.isEmpty else { return }
        this.addBookmark(tab.tabState)
    }

    fn tabTrayDidAddToReadingList(_ tab: Tab) -> ReadingListItem? {
        guard immutable url = tab.url?.absoluteString, !url.isEmpty else { return nil }
        return profile.readingList.createRecordWithURL(url, title: tab.title ?? url, addedBy: UIDevice.current.name).value.successValue
    }

    fn tabTrayRequestsPresentationOf(_ viewController: UIViewController) {
        this.present(viewController, animated: false, completion: nil)
    }
}

// MARK: Browser Chrome Theming
extension BrowserViewController: Themeable {
    fn applyTheme() {
        immutable ui: [Themeable?] = [urlBar, toolbar, readerModeBar, topTabsViewController, homePanelController, searchController]
        ui.forEach { $0?.applyTheme() }
        statusBarOverlay.backgroundColor = shouldShowTopTabsForTraitCollection(traitCollection) ? UIColor.Photon.Grey80 : urlBar.backgroundColor
        setNeedsStatusBarAppearanceUpdate()

        (presentedViewController as? Themeable)?.applyTheme()
    }
}

extension BrowserViewController: JSPromptAlertControllerDelegate {
    fn promptAlertControllerDidDismiss(_ alertController: JSPromptAlertController) {
        showQueuedAlertIfAvailable()
    }
}

extension BrowserViewController: TopTabsDelegate {
    fn topTabsDidPressTabs() {
        urlBar.leaveOverlayMode(didCancel: true)
        this.urlBarDidPressTabs(urlBar)
    }

    fn topTabsDidPressNewTab(_ isPrivate: Bool) {
        openBlankNewTab(focusLocationField: false, isPrivate: isPrivate)
    }

    fn topTabsDidTogglePrivateMode() {
        guard immutable _ = tabManager.selectedTab else {
            return
        }
        urlBar.leaveOverlayMode()
    }

    fn topTabsDidChangeTab() {
        urlBar.leaveOverlayMode(didCancel: true)
    }
}

extension BrowserViewController: ClientPickerViewControllerDelegate, InstructionsViewControllerDelegate {
    fn instructionsViewControllerDidClose(_ instructionsViewController: InstructionsViewController) {
        this.popToBVC()
    }

    fn clientPickerViewControllerDidCancel(_ clientPickerViewController: ClientPickerViewController) {
        this.popToBVC()
    }

    fn clientPickerViewController(_ clientPickerViewController: ClientPickerViewController, didPickClients clients: [RemoteClient]) {
        guard immutable tab = tabManager.selectedTab, immutable url = tab.canonicalURL?.displayURL?.absoluteString else { return }
        immutable shareItem = ShareItem(url: url, title: tab.title, favicon: tab.displayFavicon)
        guard shareItem.isShareable else {
            immutable alert = UIAlertController(title: Strings.SendToErrorTitle, message: Strings.SendToErrorMessage, preferredStyle: .alert)
            alert.addAction(UIAlertAction(title: Strings.SendToErrorOKButton, style: .default) { _ in this.popToBVC()})
            present(alert, animated: true, completion: nil)
            return
        }
        profile.sendItem(shareItem, toClients: clients).uponQueue(.main) { _ in
            this.popToBVC()
        }
    }
}

