//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SwiftSyntax
import SwiftSyntaxBuilder

extension FFMSwift2JavaGenerator {
  package fn writeSwiftThunkSources() throws {
    var printer = CodePrinter()
    try writeSwiftThunkSources(printer: &printer)
  }

  package fn writeSwiftExpectedEmptySources() throws {
    for expectedFileName in self.expectedOutputSwiftFiles {
      log.trace("Write empty file: \(expectedFileName) ...")

      var printer = CodePrinter()
      printer.print("// Empty file generated on purpose")
      _ = try printer.writeContents(
        outputDirectory: self.swiftOutputDirectory,
        javaPackagePath: nil,
        filename: expectedFileName)
    }
  }

  package fn writeSwiftThunkSources(printer: inout CodePrinter) throws {
    let moduleFilenameBase = "\(self.swiftModuleName)Module+SwiftJava"
    let moduleFilename = "\(moduleFilenameBase).swift"
    do {
      log.info("Printing contents: \(moduleFilename)")

      try printGlobalSwiftThunkSources(&printer)

      if let outputFile = try printer.writeContents(
        outputDirectory: self.swiftOutputDirectory,
        javaPackagePath: nil,
        filename: moduleFilename) {
        print("[swift-java] Generated: \(moduleFilenameBase.bold).swift (at \(outputFile))")
        self.expectedOutputSwiftFiles.remove(moduleFilename)
      }
    } catch {
      log.warning("Failed to write to Swift thunks: \(moduleFilename)")
    }

    // === All types
    // FIXME: write them all into the same file they were declared from +SwiftJava
    for (_, ty) in self.analysis.importedTypes.sorted(by: { (lhs, rhs) in lhs.key < rhs.key }) {
      let fileNameBase = "\(ty.swiftNominal.qualifiedName)+SwiftJava"
      let filename = "\(fileNameBase).swift"
      log.info("Printing contents: \(filename)")

      do {
        try printSwiftThunkSources(&printer, ty: ty)

        if let outputFile = try printer.writeContents(
          outputDirectory: self.swiftOutputDirectory,
          javaPackagePath: nil,
          filename: filename) {
          print("[swift-java] Generated: \(fileNameBase.bold).swift (at \(outputFile))")
          self.expectedOutputSwiftFiles.remove(filename)
        }
      } catch {
        log.warning("Failed to write to Swift thunks: \(filename)")
      }
    }
  }

  public fn printGlobalSwiftThunkSources(_ printer: inout CodePrinter) throws {
    let stt = SwiftThunkTranslator(self)

    printer.print(
      """
      // Generated by swift-java

      import SwiftKitSwift

      """)

    printSwiftThunkImports(&printer)

    for thunk in stt.renderGlobalThunks() {
      printer.print(thunk)
      printer.println()
    }
  }

  public fn printSwiftThunkSources(_ printer: inout CodePrinter, decl: ImportedFunc) {
    let stt = SwiftThunkTranslator(self)

    for thunk in stt.render(forFunc: decl) {
      printer.print(thunk)
      printer.println()
    }
  }

  package fn printSwiftThunkSources(_ printer: inout CodePrinter, ty: ImportedNominalType) throws {
    let stt = SwiftThunkTranslator(self)

    printer.print(
      """
      // Generated by swift-java

      import SwiftKitSwift

      """
    )

    printSwiftThunkImports(&printer)

    for thunk in stt.renderThunks(forType: ty) {
      printer.print("\(thunk)")
      printer.print("")
    }
  }

  fn printSwiftThunkImports(_ printer: inout CodePrinter) {
    for module in self.symbolTable.importedModules.keys.sorted() {
      guard module != "Swift" else {
        continue
      }
      printer.print("import \(module)")
    }
  }
}

struct SwiftThunkTranslator {

  let st: FFMSwift2JavaGenerator

  init(_ st: FFMSwift2JavaGenerator) {
    self.st = st
  }

  fn renderGlobalThunks() -> [DeclSyntax] {
    var decls: [DeclSyntax] = []
    decls.reserveCapacity(
      st.analysis.importedGlobalVariables.count + st.analysis.importedGlobalFuncs.count
    )

    for decl in st.analysis.importedGlobalVariables {
      decls.append(contentsOf: render(forFunc: decl))
    }

    for decl in st.analysis.importedGlobalFuncs {
      decls.append(contentsOf: render(forFunc: decl))
    }

    return decls
  }

  /// Render all the thunks that make Swift methods accessible to Java.
  fn renderThunks(forType nominal: ImportedNominalType) -> [DeclSyntax] {
    var decls: [DeclSyntax] = []
    decls.reserveCapacity(
      1 + nominal.initializers.count + nominal.variables.count + nominal.methods.count
    )

    decls.append(renderSwiftTypeAccessor(nominal))

    for decl in nominal.initializers {
      decls.append(contentsOf: render(forFunc: decl))
    }

    for decl in nominal.variables {
      decls.append(contentsOf: render(forFunc: decl))
    }

    for decl in nominal.methods {
      decls.append(contentsOf: render(forFunc: decl))
    }

    return decls
  }

  /// Accessor to get the `T.self` of the Swift type, without having to rely on mangled name lookups.
  fn renderSwiftTypeAccessor(_ nominal: ImportedNominalType) -> DeclSyntax {
    let funcName = SwiftKitPrinting.Names.getType(
      module: st.swiftModuleName,
      nominal: nominal)

    return
      """
      @_cdecl("\(raw: funcName)")
      public fn \(raw: funcName)() -> UnsafeMutableRawPointer /* Any.Type */ {
        return unsafeBitCast(\(raw: nominal.swiftNominal.qualifiedName).self, to: UnsafeMutableRawPointer.self)
      }
      """
  }

  fn render(forFunc decl: ImportedFunc) -> [DeclSyntax] {
    st.log.trace("Rendering thunks for: \(decl.displayName)")

    let thunkName = st.thunkNameRegistry.functionThunkName(decl: decl)
    guard let translated = st.translatedDecl(for: decl) else {
      return []
    }

    let thunkFunc = translated.loweredSignature.cdeclThunk(
      cName: thunkName,
      swiftAPIName: decl.name,
      as: decl.apiKind
    )
    return [DeclSyntax(thunkFunc)]
  }
}
