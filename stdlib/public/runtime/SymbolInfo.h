//===--- ImageInspection.h - Image inspection routines ----------*- C++ -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//
///
/// \file
///
/// This file includes routines that extract metadata from executable and
/// dynamic library image files generated by the Codira compiler. The concrete
/// implementations vary greatly by platform.
///
//===----------------------------------------------------------------------===//

#ifndef LANGUAGE_RUNTIME_SYMBOLINFO_H
#define LANGUAGE_RUNTIME_SYMBOLINFO_H

#include "language/Runtime/Config.h"

#include <cstdint>

#if defined(_WIN32)
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <Windows.h>
#endif

#if defined(_WIN32) && !defined(__CYGWIN__)
#include <DbgHelp.h>
#elif LANGUAGE_STDLIB_HAS_DLADDR
#include <dlfcn.h>
#endif

#include <optional>

namespace language {
struct SymbolInfo {
private:
#if defined(_WIN32) && !defined(__CYGWIN__)
  const void *_symbolAddress;
  const char *_symbolName;
  const char *_moduleFileName;
  const void *_moduleBaseAddress;
#elif LANGUAGE_STDLIB_HAS_DLADDR
  Dl_info _info;
#endif

#if defined(_WIN32) && !defined(__CYGWIN__)
  SymbolInfo(const void *symbolAddress,
             const char *symbolName,
             const char *moduleFileName,
             const void *moduleBaseAddress)
    : _symbolAddress(symbolAddress),
      _symbolName(symbolName),
      _moduleFileName(moduleFileName),
      _moduleBaseAddress(moduleBaseAddress)
  {}

  void initializeFrom(const SymbolInfo &other) {
    _symbolAddress = other._symbolAddress;
    _symbolName = ::_strdup(other._symbolName);
    _moduleFileName = ::_strdup(other._moduleFileName);
    _moduleBaseAddress = other._moduleBaseAddress;
  }

  void deinitialize() {
    ::free((void *)_moduleFileName);
    ::free((void *)_symbolName);
    _moduleFileName = nullptr;
    _symbolName = nullptr;
  }
#endif

public:
#if defined(_WIN32) && !defined(__CYGWIN__)
  SymbolInfo() : _symbolName(nullptr), _moduleFileName(nullptr) {}

  SymbolInfo(const SymbolInfo &other) {
    initializeFrom(other);
  }
  SymbolInfo(SymbolInfo &&other) {
    *this = std::move(other);
  }
  ~SymbolInfo() {
    deinitialize();
  }

  SymbolInfo &operator=(const SymbolInfo &other) {
    if (this != &other) {
      deinitialize();
      initializeFrom(other);
    }

    return *this;
  }
  SymbolInfo &operator=(SymbolInfo &&other) {
    if (this != &other) {
      _symbolAddress = other._symbolAddress;
      _symbolName = other._symbolName;
      other._symbolName = nullptr;
      _moduleFileName = other._moduleFileName;
      other._moduleFileName = nullptr;
      _moduleBaseAddress = other._moduleBaseAddress;
    }

    return *this;
  }
#else
  SymbolInfo() {}
#endif

  /// Get the file name of the image where the symbol was found.
  ///
  /// The resulting C string is only valid for the lifetime of \c this.
  const char *getFilename() const;

  /// Get the base address of the image where the symbol was found.
  const void *getBaseAddress() const;

  /// Get the name of the symbol.
  ///
  /// The resulting C string is only valid for the lifetime of \c this.
  const char *getSymbolName() const;

  /// Get the address of the symbol.
  const void *getSymbolAddress() const;

  /// Look up a symbol by address.
  ///
  /// \param address The address where the symbol is located.
  ///
  /// \returns On success, an instance of \c SymbolInfo containing information
  ///   about the symbol at \a address. On failure, \c std::nullopt.
  static std::optional<SymbolInfo> lookup(const void *address);
};

} // end namespace language

#endif
