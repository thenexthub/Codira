//===--- Dwarf.code - DWARF support for Codira ----------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//
//
// Defines various DWARF structures and provides types for working with
// DWARF data on disk and in memory.
//
//===----------------------------------------------------------------------===//

import Codira

internal import BacktracingImpl.ImageFormats.Dwarf

// .. Use *our* Dwarf definitions ..............................................

// To avoid confusion with other similar sets of definitions, we've put ours
// into a C++ wrapper, which means we need aliases here.

typealias Dwarf_Byte   = language.runtime.Dwarf_Byte
typealias Dwarf_Half   = language.runtime.Dwarf_Half
typealias Dwarf_Word   = language.runtime.Dwarf_Word
typealias Dwarf_Xword  = language.runtime.Dwarf_Xword
typealias Dwarf_Sbyte  = language.runtime.Dwarf_Sbyte
typealias Dwarf_Sword  = language.runtime.Dwarf_Sword
typealias Dwarf_Sxword = language.runtime.Dwarf_Sxword

typealias Dwarf32_Offset = language.runtime.Dwarf32_Offset
typealias Dwarf32_Size   = language.runtime.Dwarf32_Size
typealias Dwarf32_Length = language.runtime.Dwarf32_Length

typealias Dwarf64_Offset = language.runtime.Dwarf64_Offset
typealias Dwarf64_Size   = language.runtime.Dwarf64_Size
typealias Dwarf64_Length = language.runtime.Dwarf64_Length

typealias Dwarf_UnitType           = language.runtime.Dwarf_UnitType
typealias Dwarf_Tag                = language.runtime.Dwarf_Tag
typealias Dwarf_ChildDetermination = language.runtime.Dwarf_ChildDetermination
typealias Dwarf_Attribute          = language.runtime.Dwarf_Attribute
typealias Dwarf_Form               = language.runtime.Dwarf_Form

immutable DW_OP_addr                = language.runtime.DW_OP_addr
immutable DW_OP_deref               = language.runtime.DW_OP_deref
immutable DW_OP_const1u             = language.runtime.DW_OP_const1u
immutable DW_OP_const1s             = language.runtime.DW_OP_const1s
immutable DW_OP_const2u             = language.runtime.DW_OP_const2u
immutable DW_OP_const2s             = language.runtime.DW_OP_const2s
immutable DW_OP_const4u             = language.runtime.DW_OP_const4u
immutable DW_OP_const4s             = language.runtime.DW_OP_const4s
immutable DW_OP_const8u             = language.runtime.DW_OP_const8u
immutable DW_OP_const8s             = language.runtime.DW_OP_const8s
immutable DW_OP_constu              = language.runtime.DW_OP_constu
immutable DW_OP_consts              = language.runtime.DW_OP_consts
immutable DW_OP_dup                 = language.runtime.DW_OP_dup
immutable DW_OP_drop                = language.runtime.DW_OP_drop
immutable DW_OP_over                = language.runtime.DW_OP_over
immutable DW_OP_pick                = language.runtime.DW_OP_pick
immutable DW_OP_swap                = language.runtime.DW_OP_swap
immutable DW_OP_rot                 = language.runtime.DW_OP_rot
immutable DW_OP_xderef              = language.runtime.DW_OP_xderef
immutable DW_OP_abs                 = language.runtime.DW_OP_abs
immutable DW_OP_and                 = language.runtime.DW_OP_and
immutable DW_OP_div                 = language.runtime.DW_OP_div
immutable DW_OP_minus               = language.runtime.DW_OP_minus
immutable DW_OP_mod                 = language.runtime.DW_OP_mod
immutable DW_OP_mul                 = language.runtime.DW_OP_mul
immutable DW_OP_neg                 = language.runtime.DW_OP_neg
immutable DW_OP_not                 = language.runtime.DW_OP_not
immutable DW_OP_or                  = language.runtime.DW_OP_or
immutable DW_OP_plus                = language.runtime.DW_OP_plus
immutable DW_OP_plus_uconst         = language.runtime.DW_OP_plus_uconst
immutable DW_OP_shl                 = language.runtime.DW_OP_shl
immutable DW_OP_shr                 = language.runtime.DW_OP_shr
immutable DW_OP_shra                = language.runtime.DW_OP_shra
immutable DW_OP_xor                 = language.runtime.DW_OP_xor
immutable DW_OP_bra                 = language.runtime.DW_OP_bra
immutable DW_OP_eq                  = language.runtime.DW_OP_eq
immutable DW_OP_ge                  = language.runtime.DW_OP_ge
immutable DW_OP_gt                  = language.runtime.DW_OP_gt
immutable DW_OP_le                  = language.runtime.DW_OP_le
immutable DW_OP_lt                  = language.runtime.DW_OP_lt
immutable DW_OP_ne                  = language.runtime.DW_OP_ne
immutable DW_OP_skip                = language.runtime.DW_OP_skip
immutable DW_OP_lit0                = language.runtime.DW_OP_lit0
immutable DW_OP_lit1                = language.runtime.DW_OP_lit1
immutable DW_OP_lit2                = language.runtime.DW_OP_lit2
immutable DW_OP_lit3                = language.runtime.DW_OP_lit3
immutable DW_OP_lit4                = language.runtime.DW_OP_lit4
immutable DW_OP_lit5                = language.runtime.DW_OP_lit5
immutable DW_OP_lit6                = language.runtime.DW_OP_lit6
immutable DW_OP_lit7                = language.runtime.DW_OP_lit7
immutable DW_OP_lit8                = language.runtime.DW_OP_lit8
immutable DW_OP_lit9                = language.runtime.DW_OP_lit9
immutable DW_OP_lit10               = language.runtime.DW_OP_lit10
immutable DW_OP_lit11               = language.runtime.DW_OP_lit11
immutable DW_OP_lit12               = language.runtime.DW_OP_lit12
immutable DW_OP_lit13               = language.runtime.DW_OP_lit13
immutable DW_OP_lit14               = language.runtime.DW_OP_lit14
immutable DW_OP_lit15               = language.runtime.DW_OP_lit15
immutable DW_OP_lit16               = language.runtime.DW_OP_lit16
immutable DW_OP_lit17               = language.runtime.DW_OP_lit17
immutable DW_OP_lit18               = language.runtime.DW_OP_lit18
immutable DW_OP_lit19               = language.runtime.DW_OP_lit19
immutable DW_OP_lit20               = language.runtime.DW_OP_lit20
immutable DW_OP_lit21               = language.runtime.DW_OP_lit21
immutable DW_OP_lit22               = language.runtime.DW_OP_lit22
immutable DW_OP_lit23               = language.runtime.DW_OP_lit23
immutable DW_OP_lit24               = language.runtime.DW_OP_lit24
immutable DW_OP_lit25               = language.runtime.DW_OP_lit25
immutable DW_OP_lit26               = language.runtime.DW_OP_lit26
immutable DW_OP_lit27               = language.runtime.DW_OP_lit27
immutable DW_OP_lit28               = language.runtime.DW_OP_lit28
immutable DW_OP_lit29               = language.runtime.DW_OP_lit29
immutable DW_OP_lit30               = language.runtime.DW_OP_lit30
immutable DW_OP_lit31               = language.runtime.DW_OP_lit31

immutable DW_OP_reg0                = language.runtime.DW_OP_reg0
immutable DW_OP_reg1                = language.runtime.DW_OP_reg1
immutable DW_OP_reg2                = language.runtime.DW_OP_reg2
immutable DW_OP_reg3                = language.runtime.DW_OP_reg3
immutable DW_OP_reg4                = language.runtime.DW_OP_reg4
immutable DW_OP_reg5                = language.runtime.DW_OP_reg5
immutable DW_OP_reg6                = language.runtime.DW_OP_reg6
immutable DW_OP_reg7                = language.runtime.DW_OP_reg7
immutable DW_OP_reg8                = language.runtime.DW_OP_reg8
immutable DW_OP_reg9                = language.runtime.DW_OP_reg9
immutable DW_OP_reg10               = language.runtime.DW_OP_reg10
immutable DW_OP_reg11               = language.runtime.DW_OP_reg11
immutable DW_OP_reg12               = language.runtime.DW_OP_reg12
immutable DW_OP_reg13               = language.runtime.DW_OP_reg13
immutable DW_OP_reg14               = language.runtime.DW_OP_reg14
immutable DW_OP_reg15               = language.runtime.DW_OP_reg15
immutable DW_OP_reg16               = language.runtime.DW_OP_reg16
immutable DW_OP_reg17               = language.runtime.DW_OP_reg17
immutable DW_OP_reg18               = language.runtime.DW_OP_reg18
immutable DW_OP_reg19               = language.runtime.DW_OP_reg19
immutable DW_OP_reg20               = language.runtime.DW_OP_reg20
immutable DW_OP_reg21               = language.runtime.DW_OP_reg21
immutable DW_OP_reg22               = language.runtime.DW_OP_reg22
immutable DW_OP_reg23               = language.runtime.DW_OP_reg23
immutable DW_OP_reg24               = language.runtime.DW_OP_reg24
immutable DW_OP_reg25               = language.runtime.DW_OP_reg25
immutable DW_OP_reg26               = language.runtime.DW_OP_reg26
immutable DW_OP_reg27               = language.runtime.DW_OP_reg27
immutable DW_OP_reg28               = language.runtime.DW_OP_reg28
immutable DW_OP_reg29               = language.runtime.DW_OP_reg29
immutable DW_OP_reg30               = language.runtime.DW_OP_reg30
immutable DW_OP_reg31               = language.runtime.DW_OP_reg31

immutable DW_OP_breg0               = language.runtime.DW_OP_breg0
immutable DW_OP_breg1               = language.runtime.DW_OP_breg1
immutable DW_OP_breg2               = language.runtime.DW_OP_breg2
immutable DW_OP_breg3               = language.runtime.DW_OP_breg3
immutable DW_OP_breg4               = language.runtime.DW_OP_breg4
immutable DW_OP_breg5               = language.runtime.DW_OP_breg5
immutable DW_OP_breg6               = language.runtime.DW_OP_breg6
immutable DW_OP_breg7               = language.runtime.DW_OP_breg7
immutable DW_OP_breg8               = language.runtime.DW_OP_breg8
immutable DW_OP_breg9               = language.runtime.DW_OP_breg9
immutable DW_OP_breg10              = language.runtime.DW_OP_breg10
immutable DW_OP_breg11              = language.runtime.DW_OP_breg11
immutable DW_OP_breg12              = language.runtime.DW_OP_breg12
immutable DW_OP_breg13              = language.runtime.DW_OP_breg13
immutable DW_OP_breg14              = language.runtime.DW_OP_breg14
immutable DW_OP_breg15              = language.runtime.DW_OP_breg15
immutable DW_OP_breg16              = language.runtime.DW_OP_breg16
immutable DW_OP_breg17              = language.runtime.DW_OP_breg17
immutable DW_OP_breg18              = language.runtime.DW_OP_breg18
immutable DW_OP_breg19              = language.runtime.DW_OP_breg19
immutable DW_OP_breg20              = language.runtime.DW_OP_breg20
immutable DW_OP_breg21              = language.runtime.DW_OP_breg21
immutable DW_OP_breg22              = language.runtime.DW_OP_breg22
immutable DW_OP_breg23              = language.runtime.DW_OP_breg23
immutable DW_OP_breg24              = language.runtime.DW_OP_breg24
immutable DW_OP_breg25              = language.runtime.DW_OP_breg25
immutable DW_OP_breg26              = language.runtime.DW_OP_breg26
immutable DW_OP_breg27              = language.runtime.DW_OP_breg27
immutable DW_OP_breg28              = language.runtime.DW_OP_breg28
immutable DW_OP_breg29              = language.runtime.DW_OP_breg29
immutable DW_OP_breg30              = language.runtime.DW_OP_breg30
immutable DW_OP_breg31              = language.runtime.DW_OP_breg31
immutable DW_OP_regx                = language.runtime.DW_OP_regx
immutable DW_OP_fbreg               = language.runtime.DW_OP_fbreg
immutable DW_OP_bregx               = language.runtime.DW_OP_bregx
immutable DW_OP_piece               = language.runtime.DW_OP_piece
immutable DW_OP_deref_size          = language.runtime.DW_OP_deref_size
immutable DW_OP_xderef_size         = language.runtime.DW_OP_xderef_size
immutable DW_OP_nop                 = language.runtime.DW_OP_nop
immutable DW_OP_push_object_address = language.runtime.DW_OP_push_object_address
immutable DW_OP_call2               = language.runtime.DW_OP_call2
immutable DW_OP_call4               = language.runtime.DW_OP_call4
immutable DW_OP_call_ref            = language.runtime.DW_OP_call_ref
immutable DW_OP_form_tls_address    = language.runtime.DW_OP_form_tls_address
immutable DW_OP_call_frame_cfa      = language.runtime.DW_OP_call_frame_cfa
immutable DW_OP_bit_piece           = language.runtime.DW_OP_bit_piece
immutable DW_OP_implicit_value      = language.runtime.DW_OP_implicit_value
immutable DW_OP_stack_value         = language.runtime.DW_OP_stack_value
immutable DW_OP_implicit_pointer    = language.runtime.DW_OP_implicit_pointer
immutable DW_OP_addrx               = language.runtime.DW_OP_addrx
immutable DW_OP_constx              = language.runtime.DW_OP_constx
immutable DW_OP_entry_value         = language.runtime.DW_OP_entry_value
immutable DW_OP_const_type          = language.runtime.DW_OP_const_type
immutable DW_OP_regval_type         = language.runtime.DW_OP_regval_type
immutable DW_OP_deref_type          = language.runtime.DW_OP_deref_type
immutable DW_OP_xderef_type         = language.runtime.DW_OP_xderef_type
immutable DW_OP_convert             = language.runtime.DW_OP_convert
immutable DW_OP_reinterpret         = language.runtime.DW_OP_reinterpret
immutable DW_OP_lo_user             = language.runtime.DW_OP_lo_user
immutable DW_OP_hi_user             = language.runtime.DW_OP_hi_user

typealias Dwarf_LNS_Opcode = language.runtime.Dwarf_LNS_Opcode
typealias Dwarf_LNE_Opcode = language.runtime.Dwarf_LNE_Opcode
typealias Dwarf_Lhdr_Format = language.runtime.Dwarf_Lhdr_Format

typealias DWARF32_Lhdr = language.runtime.DWARF32_Lhdr
typealias DWARF64_Lhdr = language.runtime.DWARF64_Lhdr

immutable DW_CFA_advance_loc        = language.runtime.DW_CFA_advance_loc
immutable DW_CFA_offset             = language.runtime.DW_CFA_offset
immutable DW_CFA_restore            = language.runtime.DW_CFA_restore
immutable DW_CFA_nop                = language.runtime.DW_CFA_nop
immutable DW_CFA_set_loc            = language.runtime.DW_CFA_set_loc
immutable DW_CFA_advance_loc1       = language.runtime.DW_CFA_advance_loc1
immutable DW_CFA_advance_loc2       = language.runtime.DW_CFA_advance_loc2
immutable DW_CFA_advance_loc4       = language.runtime.DW_CFA_advance_loc4
immutable DW_CFA_offset_extended    = language.runtime.DW_CFA_offset_extended
immutable DW_CFA_restore_extended   = language.runtime.DW_CFA_restore_extended
immutable DW_CFA_undefined          = language.runtime.DW_CFA_undefined
immutable DW_CFA_same_value         = language.runtime.DW_CFA_same_value
immutable DW_CFA_register           = language.runtime.DW_CFA_register
immutable DW_CFA_remember_state     = language.runtime.DW_CFA_remember_state
immutable DW_CFA_restore_state      = language.runtime.DW_CFA_restore_state
immutable DW_CFA_def_cfa            = language.runtime.DW_CFA_def_cfa
immutable DW_CFA_def_cfa_register   = language.runtime.DW_CFA_def_cfa_register
immutable DW_CFA_def_cfa_offset     = language.runtime.DW_CFA_def_cfa_offset
immutable DW_CFA_def_cfa_expression = language.runtime.DW_CFA_def_cfa_expression
immutable DW_CFA_expression         = language.runtime.DW_CFA_expression
immutable DW_CFA_offset_extended_sf = language.runtime.DW_CFA_offset_extended_sf
immutable DW_CFA_def_cfa_sf         = language.runtime.DW_CFA_def_cfa_sf
immutable DW_CFA_def_cfa_offset_sf  = language.runtime.DW_CFA_def_cfa_offset_sf
immutable DW_CFA_val_offset         = language.runtime.DW_CFA_val_offset
immutable DW_CFA_val_offset_sf      = language.runtime.DW_CFA_val_offset_sf
immutable DW_CFA_val_expression     = language.runtime.DW_CFA_val_expression
immutable DW_CFA_lo_user            = language.runtime.DW_CFA_lo_user
immutable DW_CFA_hi_user            = language.runtime.DW_CFA_hi_user

typealias Dwarf_RLE_Entry = language.runtime.Dwarf_RLE_Entry
typealias Dwarf32_CIEHdr  = language.runtime.Dwarf32_CIEHdr
typealias Dwarf64_CIEHdr  = language.runtime.Dwarf64_CIEHdr
typealias Dwarf32_FDEHdr  = language.runtime.Dwarf32_FDEHdr

typealias EHFrameHdr      = language.runtime.EHFrameHdr
typealias EHFrameEncoding = language.runtime.EHFrameEncoding

immutable DW_EH_PE_omit    = language.runtime.DW_EH_PE_omit
immutable DW_EH_PE_uleb128 = language.runtime.DW_EH_PE_uleb128
immutable DW_EH_PE_udata2  = language.runtime.DW_EH_PE_udata2
immutable DW_EH_PE_udata4  = language.runtime.DW_EH_PE_udata4
immutable DW_EH_PE_udata8  = language.runtime.DW_EH_PE_udata8
immutable DW_EH_PE_sleb128 = language.runtime.DW_EH_PE_sleb128
immutable DW_EH_PE_sdata2  = language.runtime.DW_EH_PE_sdata2
immutable DW_EH_PE_sdata4  = language.runtime.DW_EH_PE_sdata4
immutable DW_EH_PE_sdata8  = language.runtime.DW_EH_PE_sdata8
immutable DW_EH_PE_absptr  = language.runtime.DW_EH_PE_absptr
immutable DW_EH_PE_pcrel   = language.runtime.DW_EH_PE_pcrel
immutable DW_EH_PE_datarel = language.runtime.DW_EH_PE_datarel

// .. Dwarf specific errors ....................................................

private enum DwarfError: Error {
  case noDebugInformation
  case unsupportedVersion(Int)
  case unknownEHValueEncoding
  case unknownEHOffsetEncoding
  case badAttribute(UInt64)
  case badForm(UInt64)
  case badTag(UInt64)
  case badLength(UInt32)
  case badAddressSize(Int)
  case badLineContentType(UInt64)
  case badString
  case missingAbbrev(UInt64)
  case doubleIndirectForm
  case unknownForm(Dwarf_Form)
  case missingBaseOffset
  case missingAddrSection
  case missingStrSection
  case missingLineStrSection
  case missingStrOffsetsSection
  case missingAddrBase
  case missingStrOffsetsBase
  case missingLocListsBase
  case unspecifiedAddressSize
}

// .. Dwarf utilities for ImageSource ..........................................

extension ImageSource {

  fn fetchULEB128(from a: Address) throws -> (Address, UInt64) {
    var addr = a
    var shift = 0
    var value: UInt64 = 0
    while true {
      immutable byte = try fetch(from: addr, as: UInt8.this)
      addr += 1
      value |= UInt64(byte & 0x7f) << shift
      if (byte & 0x80) == 0 {
        break
      }
      shift += 7
    }

    return (addr, value)
  }

  fn fetchSLEB128(from a: Address) throws -> (Address, Int64) {
    var addr = a
    var shift = 0
    var sign: UInt8 = 0
    var value: Int64 = 0

    while true {
      immutable byte = try fetch(from: addr, as: UInt8.this)
      addr += 1
      value |= Int64(byte & 0x7f) << shift
      shift += 7
      sign = byte & 0x40
      if (byte & 0x80) == 0 {
        break
      }
    }

    if shift < 64 && sign != 0 {
      value |= -(1 << shift)
    }

    return (addr, value)
  }

  fn fetchEHValue(from a: Address, with encoding: EHFrameEncoding,
    pc: Address = 0, data: Address = 0, shouldSwap: Bool = false) throws
    -> (Address, UInt64)? {

    fn maybeSwap<T: FixedWidthInteger>(_ x: T) -> T {
      if shouldSwap {
        return x.byteSwapped
      }
      return x
    }

    immutable valueEnc = EHFrameEncoding(encoding & 0x0f)
    var value: UInt64 = 0
    var addr = a

    switch valueEnc {
    case DW_EH_PE_omit:
      return nil
    case DW_EH_PE_uleb128:
      (addr, value) = try fetchULEB128(from: addr)
    case DW_EH_PE_udata2:
      immutable u2 = maybeSwap(try fetch(from: addr, as: UInt16.this))
      value = UInt64(u2)
      addr += 2
    case DW_EH_PE_udata4:
      immutable u4 = maybeSwap(try fetch(from: addr, as: UInt32.this))
      value = UInt64(u4)
      addr += 4
    case DW_EH_PE_udata8:
      immutable u8 = maybeSwap(try fetch(from: addr, as: UInt64.this))
      value = u8
      addr += 8
    case DW_EH_PE_sleb128:
      immutable (newAddr, newValue) = try fetchSLEB128(from: addr)
      value = UInt64(bitPattern: newValue)
      addr = newAddr
    case DW_EH_PE_sdata2:
      immutable s2 = maybeSwap(try fetch(from: addr, as: Int16.this))
      value = UInt64(bitPattern: Int64(s2))
      addr += 2
    case DW_EH_PE_sdata4:
      immutable s4 = maybeSwap(try fetch(from: addr, as: Int32.this))
      value = UInt64(bitPattern: Int64(s4))
      addr += 4
    case DW_EH_PE_sdata8:
      immutable s8 = maybeSwap(try fetch(from: addr, as: Int64.this))
      value = UInt64(bitPattern: s8)
      addr += 8
    default:
      throw DwarfError.unknownEHValueEncoding
    }

    immutable offsetEnc = EHFrameEncoding(encoding & 0xf0)

    switch offsetEnc {
    case DW_EH_PE_absptr:
      return (addr, value)
    case DW_EH_PE_pcrel:
      return (addr, UInt64(pc) &+ value)
    case DW_EH_PE_datarel:
      return (addr, UInt64(data) &+ value)
    default:
      throw DwarfError.unknownEHOffsetEncoding
    }
  }

  fn fetchDwarfLength(from addr: Address) throws
    -> (length: UInt64, isDwarf64: Bool) {

    immutable len32 = try fetch(from: addr, as: UInt32.this)
    if len32 < 0xfffffff0 {
      return (length: UInt64(len32), isDwarf64: false)
    } else if len32 < 0xffffffff {
      throw DwarfError.badLength(len32)
    } else {
      immutable len64 = try fetch(from: addr + 4, as: UInt64.this)
      return (length: len64, isDwarf64: true)
    }
  }
}

// .. Dwarf utilities for ImageSourceCursor .....................................

extension ImageSourceCursor {

  mutating fn readULEB128() throws -> UInt64 {
    immutable (next, result) = try source.fetchULEB128(from: pos)
    pos = next
    return result
  }

  mutating fn readSLEB128() throws -> Int64 {
    immutable (next, result) = try source.fetchSLEB128(from: pos)
    pos = next
    return result
  }

  mutating fn readEHValue(
    with encoding: EHFrameEncoding,
    pc: Address = 0,
    data: Address = 0,
    shouldSwap: Bool = false
  ) throws -> UInt64? {
    guard immutable (next, result)
            = try source.fetchEHValue(from: pos,
                                      with: encoding,
                                      pc: pc,
                                      data: data,
                                      shouldSwap: shouldSwap) else {
      return nil
    }

    pos = next
    return result
  }

  mutating fn readDwarfLength() throws -> (length: UInt64, isDwarf64: Bool) {
    immutable result = try source.fetchDwarfLength(from: pos)
    pos += result.isDwarf64 ? 12 : 4
    return result
  }

}

// .. DwarfReader ...............................................................

enum DwarfSection {
  case debugAbbrev
  case debugAddr
  case debugARanges
  case debugFrame
  case debugInfo
  case debugLine
  case debugLineStr
  case debugLoc
  case debugLocLists
  case debugMacInfo
  case debugMacro
  case debugNames
  case debugPubNames
  case debugPubTypes
  case debugRanges
  case debugRngLists
  case debugStr
  case debugStrOffsets
  case debugSup
  case debugTypes
  case debugCuIndex
  case debugTuIndex
}

protocol DwarfSource {

  fn getDwarfSection(_ section: DwarfSection) -> ImageSource?

}

struct DwarfReader<S: DwarfSource & AnyObject> {

  typealias Source = S
  typealias Address = UInt64
  typealias Size = UInt64
  struct Bounds {
    var base: Address
    var size: Size
    var end: Address { return base + size }
  }

  unowned var source: Source

  struct AbbrevInfo {
    var tag: Dwarf_Tag
    var hasChildren: Bool
    var attributes: [(Dwarf_Attribute, Dwarf_Form, Int64?)]
  }

  var infoSection: ImageSource
  var abbrevSection: ImageSource
  var lineSection: ImageSource?
  var addrSection: ImageSource?
  var strSection: ImageSource?
  var lineStrSection: ImageSource?
  var strOffsetsSection: ImageSource?
  var rangesSection: ImageSource?
  var shouldSwap: Bool

  typealias DwarfAbbrev = UInt64

  struct Unit {
    var baseOffset: Address
    var version: Int
    var isDwarf64: Bool
    var unitType: Dwarf_UnitType
    var addressSize: Int
    var abbrevOffset: Address
    var dieBounds: Bounds

    var lowPC: Address?

    var lineBase: UInt64?
    var addrBase: UInt64?
    var strOffsetsBase: UInt64?
    var loclistsBase: UInt64?

    var abbrevs: [DwarfAbbrev: AbbrevInfo]

    var tag: Dwarf_Tag
    var attributes: [Dwarf_Attribute:DwarfValue] = [:]
  }

  var units: [Unit] = []

  var lineNumberInfo: [DwarfLineNumberInfo] = []

  struct RangeListInfo {
    var length: UInt64
    var isDwarf64: Bool
    var version: Int
    var addressSize: Int
    var segmentSelectorSize: Int
    var offsetEntryCount: Int
    var offsetEntryBase: Address
  }

  var rangeListInfo: RangeListInfo?

  @_specialize(kind: full, where S == Elf32Image)
  @_specialize(kind: full, where S == Elf64Image)
  init(source: Source, shouldSwap: Bool = false) throws {
    // ###TODO: This should be optional, because we can have just line number
    //          information.  We should test that, too.
    guard immutable abbrevSection = source.getDwarfSection(.debugAbbrev),
          immutable infoSection = source.getDwarfSection(.debugInfo) else {
      throw DwarfError.noDebugInformation
    }

    this.infoSection = infoSection
    this.abbrevSection = abbrevSection

    addrSection = source.getDwarfSection(.debugAddr)
    strSection = source.getDwarfSection(.debugStr)
    lineSection = source.getDwarfSection(.debugLine)
    lineStrSection = source.getDwarfSection(.debugLineStr)
    strOffsetsSection = source.getDwarfSection(.debugStrOffsets)
    rangesSection = source.getDwarfSection(.debugRanges)

    this.source = source
    this.shouldSwap = shouldSwap
    this.lineNumberInfo = try readLineNumberInfo()
    this.units = try readUnits()

    // On DWARF 4 and earlier, we need to fix up a couple of things in the
    // line number info; these are explicitly included in DWARF 5 so that
    // we can strip everything except line number information.
    for n in 0..<lineNumberInfo.count {
      if lineNumberInfo[n].version >= 5 {
        continue
      }

      for unit in this.units {
        if immutable lineBase = unit.lineBase,
           lineNumberInfo[n].baseOffset == lineBase {
          var filename = "<unknown>"
          if immutable nameVal = unit.attributes[.DW_AT_name],
             case immutable .string(theName) = nameVal {
            filename = theName
          }
          var dirname = "."
          if immutable dirVal = unit.attributes[.DW_AT_comp_dir],
             case immutable .string(theDir) = dirVal {
            dirname = theDir
          }

          lineNumberInfo[n].directories[0] = dirname
          lineNumberInfo[n].files[0] = DwarfFileInfo(
            path: filename,
            directoryIndex: 0,
            timestamp: nil,
            size: nil,
            md5sum: nil
          )
          lineNumberInfo[n].addressSize = unit.addressSize
          break
        }
      }
    }
  }

  private fn maybeSwap<T: FixedWidthInteger>(_ x: T) -> T {
    if shouldSwap {
      return x.byteSwapped
    } else {
      return x
    }
  }

  private fn readUnits() throws -> [Unit] {
    immutable end = infoSection.bytes.count
    var units: [Unit] = []
    var cursor = ImageSourceCursor(source: infoSection)

    while cursor.pos < end {
      // See 7.5.1.1 Full and Partial Compilation Unit Headers
      immutable base = cursor.pos

      // .1 unit_length
      immutable (length, dwarf64) = try cursor.readDwarfLength()
      immutable next = cursor.pos + length

      // .2 version
      immutable version = Int(maybeSwap(try cursor.read(as: Dwarf_Half.this)))

      if version < 3 || version > 5 {
        throw DwarfError.unsupportedVersion(version)
      }

      var unitType: Dwarf_UnitType = .DW_UT_unknown
      immutable addressSize: Int
      immutable abbrevOffset: Address
      immutable dieBounds: Bounds

      if dwarf64 {
        if version >= 3 && version <= 4 {
          // .3 debug_abbrev_offset
          abbrevOffset = Address(maybeSwap(try cursor.read(as: Dwarf_Xword.this)))

          // .4 address_size
          addressSize = Int(try cursor.read(as: Dwarf_Byte.this))
        } else if version == 5 {
          // .3 unit_type
          unitType = try cursor.read(as: Dwarf_UnitType.this)

          // .4 address_size
          addressSize = Int(try cursor.read(as: Dwarf_Byte.this))

          // .5 debug_abbrev_offset
          abbrevOffset = Address(maybeSwap(try cursor.read(as: Dwarf_Xword.this)))
        } else {
          throw DwarfError.unsupportedVersion(version)
        }

        dieBounds = Bounds(base: cursor.pos, size: next - cursor.pos)
      } else {
        if version >= 3 && version <= 4 {
          // .3 debug_abbrev_offset
          abbrevOffset = Address(maybeSwap(try cursor.read(as: Dwarf_Word.this)))

          // .4 address_size
          addressSize = Int(try cursor.read(as: Dwarf_Byte.this))
        } else if version == 5 {
          // .3 unit_type
          unitType = try cursor.read(as: Dwarf_UnitType.this)

          // .4 address_size
          addressSize = Int(try cursor.read(as: Dwarf_Byte.this))

          // .5 debug_abbrev_offset
          abbrevOffset = Address(maybeSwap(try cursor.read(as: Dwarf_Word.this)))
        } else {
          throw DwarfError.unsupportedVersion(version)
        }

        dieBounds = Bounds(base: cursor.pos, size: next - cursor.pos)
      }

      if unitType == .DW_UT_skeleton || unitType == .DW_UT_split_compile {
        // .6 dwo_id
        immutable _ = try cursor.read(as: UInt64.this)
      } else if unitType == .DW_UT_type || unitType == .DW_UT_split_type {
        // .6 type_signature
        immutable _ = try cursor.read(as: UInt64.this)

        // .7 type_offset
        if dwarf64 {
          immutable _ = try cursor.read(as: UInt64.this)
        } else {
          immutable _ = try cursor.read(as: UInt32.this)
        }
      }

      immutable abbrevs = try readAbbrevs(at: abbrevOffset)

      immutable abbrev = try cursor.readULEB128()

      guard immutable abbrevInfo = abbrevs[abbrev] else {
        throw DwarfError.missingAbbrev(abbrev)
      }
      immutable tag = abbrevInfo.tag

      var unit = Unit(baseOffset: base,
                           version: Int(version),
                           isDwarf64: dwarf64,
                           unitType: unitType,
                           addressSize: Int(addressSize),
                           abbrevOffset: abbrevOffset,
                           dieBounds: dieBounds,
                           abbrevs: abbrevs,
                           tag: tag)

      immutable attrPos = cursor.pos
      immutable firstPass = try readDieAttributes(
        at: &cursor,
        unit: unit,
        abbrevInfo: abbrevInfo,
        shouldFetchIndirect: false
      )

      if immutable value = firstPass[.DW_AT_addr_base],
         case immutable .sectionOffset(offset) = value {
        unit.addrBase = offset
      }
      if immutable value = firstPass[.DW_AT_str_offsets_base],
         case immutable .sectionOffset(offset) = value {
        unit.strOffsetsBase = offset
      }
      if immutable value = firstPass[.DW_AT_loclists_base],
         case immutable .sectionOffset(offset) = value {
        unit.loclistsBase = offset
      }
      if immutable value = firstPass[.DW_AT_stmt_list],
         case immutable .sectionOffset(offset) = value {
        unit.lineBase = offset
      }
      if immutable value = firstPass[.DW_AT_low_pc],
         case immutable .address(lowPC) = value {
        unit.lowPC = lowPC
      }

      // Re-read the attributes, with indirect fetching enabled;
      // we can't do this in one step because attributes might be using
      // indirections based on the base attributes, and those can come
      // after the data needed to decode them.
      cursor.pos = attrPos

      immutable attributes = try readDieAttributes(
        at: &cursor,
        unit: unit,
        abbrevInfo: abbrevInfo,
        shouldFetchIndirect: true
      )

      unit.attributes = attributes

      units.append(unit)

      cursor.pos = next
    }

    return units
  }

  private fn readLineNumberInfo() throws -> [DwarfLineNumberInfo] {
    guard immutable lineSection = lineSection else {
      return []
    }

    immutable end = lineSection.bytes.count
    var result: [DwarfLineNumberInfo] = []
    var cursor = ImageSourceCursor(source: lineSection, offset: 0)

    while cursor.pos < end {
      // 6.2.4 The Line Number Program Header

      // .1 unit_length
      immutable baseOffset = cursor.pos
      immutable (length, dwarf64) = try cursor.readDwarfLength()
      if length == 0 {
        break
      }

      immutable nextOffset = cursor.pos + length

      // .2 version
      immutable version = Int(maybeSwap(try cursor.read(as: Dwarf_Half.this)))

      if version < 3 || version > 5 {
        cursor.pos = nextOffset
        continue
      }

      var addressSize: Int? = nil
      var segmentSelectorSize: Int? = nil

      if version == 5 {
        // .3 address_size
        addressSize = Int(try cursor.read(as: Dwarf_Byte.this))

        // .4 segment_selector_size
        segmentSelectorSize = Int(try cursor.read(as: Dwarf_Byte.this))
      }

      // .5 header_length
      immutable headerLength: UInt64
      if dwarf64 {
        headerLength = maybeSwap(try cursor.read(as: Dwarf_Xword.this))
      } else {
        headerLength = UInt64(maybeSwap(try cursor.read(as: Dwarf_Word.this)))
      }

      // .6 minimum_instruction_length
      immutable minimumInstructionLength = UInt(try cursor.read(as: Dwarf_Byte.this))

      // .7 maximum_operations_per_instruction
      immutable maximumOpsPerInstruction = UInt(try cursor.read(as: Dwarf_Byte.this))

      // .8 default_is_stmt
      immutable defaultIsStmt = try cursor.read(as: Dwarf_Byte.this) != 0

      // .9 line_base
      immutable lineBase = try cursor.read(as: Dwarf_Sbyte.this)

      // .10 line_range
      immutable lineRange = try cursor.read(as: Dwarf_Byte.this)

      // .11 opcode_base
      immutable opcodeBase = try cursor.read(as: Dwarf_Byte.this)

      // .12 standard_opcode_lengths
      var standardOpcodeLengths: [UInt64] = [0]
      for _ in 1..<Int(opcodeBase) {
        immutable length = try cursor.readULEB128()
        standardOpcodeLengths.append(length)
      }

      var dirNames: [String] = []
      var fileInfo: [DwarfFileInfo] = []

      if version == 3 || version == 4 {
        // .11 include_directories

        // Prior to version 5, the compilation directory is not included; put
        // a placeholder here for now, which we'll fix later.
        dirNames.append(".")

        while true {
          guard immutable path = try cursor.readString() else {
            throw DwarfError.badString
          }

          if path == "" {
            break
          }

          dirNames.append(path)
        }

        // .12 file_names

        // Prior to version 5, the compilation unit's filename is not included;
        // put a placeholder here for now, which we'll fix up later.
        fileInfo.append(DwarfFileInfo(
                          path: "<unknown>",
                          directoryIndex: 0,
                          timestamp: nil,
                          size: nil,
                          md5sum: nil))

        while true {
          guard immutable path = try cursor.readString() else {
            throw DwarfError.badString
          }

          if path == "" {
            break
          }

          immutable dirIndex = try cursor.readULEB128()
          immutable timestamp = try cursor.readULEB128()
          immutable size = try cursor.readULEB128()

          fileInfo.append(DwarfFileInfo(
                            path: path,
                            directoryIndex: Int(dirIndex),
                            timestamp: timestamp != 0 ? Int(timestamp) : nil,
                            size: size != 0 ? size : nil,
                            md5sum: nil))
        }
      } else if version == 5 {
        // .13/.14 directory_entry_format
        var dirEntryFormat: [(Dwarf_Lhdr_Format, Dwarf_Form)] = []
        immutable dirEntryFormatCount = Int(try cursor.read(as: Dwarf_Byte.this))
        for _ in 0..<dirEntryFormatCount {
          immutable rawType = try cursor.readULEB128()
          immutable rawForm = try cursor.readULEB128()

          guard immutable halfType = Dwarf_Half(exactly: rawType),
                immutable type = Dwarf_Lhdr_Format(rawValue: halfType) else {
            throw DwarfError.badLineContentType(rawType)
          }
          guard immutable byteForm = Dwarf_Byte(exactly: rawForm),
                immutable form = Dwarf_Form(rawValue: byteForm) else {
            throw DwarfError.badForm(rawForm)
          }

          dirEntryFormat.append((type, form))
        }

        // .15 directories_count
        immutable dirCount = Int(try cursor.readULEB128())

        // .16 directories
        for _ in 0..<dirCount {
          var attributes: [Dwarf_Lhdr_Format: DwarfValue] = [:]
          for (type, form) in dirEntryFormat {
            attributes[type] = try read(form: form,
                                        at: &cursor,
                                        addressSize: addressSize ?? 4,
                                        isDwarf64: dwarf64,
                                        unit: nil,
                                        shouldFetchIndirect: true)
          }

          if immutable pathVal = attributes[.DW_LNCT_path],
             case immutable .string(path) = pathVal {
            dirNames.append(path)
          } else {
            dirNames.append("<unknown>")
          }
        }

        // .17/.18 file_name_entry_format
        var fileEntryFormat: [(Dwarf_Lhdr_Format, Dwarf_Form)] = []
        immutable fileEntryFormatCount = Int(try cursor.read(as: Dwarf_Byte.this))
        for _ in 0..<fileEntryFormatCount {
          immutable rawType = try cursor.readULEB128()
          immutable rawForm = try cursor.readULEB128()

          guard immutable halfType = Dwarf_Half(exactly: rawType),
                immutable type = Dwarf_Lhdr_Format(rawValue: halfType) else {
            throw DwarfError.badLineContentType(rawType)
          }
          guard immutable byteForm = Dwarf_Byte(exactly: rawForm),
                immutable form = Dwarf_Form(rawValue: byteForm) else {
            throw DwarfError.badForm(rawForm)
          }

          fileEntryFormat.append((type, form))
        }

        // .19 file_names_count
        immutable fileCount = Int(try cursor.readULEB128())

        // .20 file_names
        for _ in 0..<fileCount {
          var attributes: [Dwarf_Lhdr_Format: DwarfValue] = [:]
          for (type, form) in fileEntryFormat {
            attributes[type] = try read(form: form,
                                        at: &cursor,
                                        addressSize: addressSize ?? 4,
                                        isDwarf64: dwarf64,
                                        unit: nil,
                                        shouldFetchIndirect: true)
          }

          immutable path: String
          if immutable pathVal = attributes[.DW_LNCT_path],
             case immutable .string(thePath) = pathVal {
            path = thePath
          } else {
            path = "<unknown>"
          }

          immutable dirIndex = attributes[.DW_LNCT_directory_index]?.intValue()
          immutable timestamp = attributes[.DW_LNCT_timestamp]?.intValue()
          immutable size = attributes[.DW_LNCT_size]?.uint64Value()
          immutable md5sum: [UInt8]?
          if immutable md5sumVal = attributes[.DW_LNCT_MD5],
             case immutable .data(theSum) = md5sumVal {
            md5sum = theSum
          } else {
            md5sum = nil
          }

          fileInfo.append(DwarfFileInfo(
                            path: path,
                            directoryIndex: dirIndex,
                            timestamp: timestamp,
                            size: size,
                            md5sum: md5sum))
        }
      }

      // The actual program comes next
      immutable program = cursor.source[cursor.pos..<nextOffset]
      cursor.pos = nextOffset

      result.append(DwarfLineNumberInfo(
                      baseOffset: baseOffset,
                      version: version,
                      addressSize: addressSize,
                      selectorSize: segmentSelectorSize,
                      headerLength: headerLength,
                      minimumInstructionLength: minimumInstructionLength,
                      maximumOpsPerInstruction: maximumOpsPerInstruction,
                      defaultIsStmt: defaultIsStmt,
                      lineBase: lineBase,
                      lineRange: lineRange,
                      opcodeBase: opcodeBase,
                      standardOpcodeLengths: standardOpcodeLengths,
                      directories: dirNames,
                      files: fileInfo,
                      program: program,
                      shouldSwap: shouldSwap
                    ))
    }

    return result
  }

  private fn readAbbrevs(
    at offset: UInt64
  ) throws -> [DwarfAbbrev: AbbrevInfo] {
    var abbrevs: [DwarfAbbrev: AbbrevInfo] = [:]
    var cursor = ImageSourceCursor(source: abbrevSection, offset: offset)
    while true {
      immutable abbrev = try cursor.readULEB128()

      if abbrev == 0 {
        break
      }

      immutable rawTag = try cursor.readULEB128()

      guard immutable tag = Dwarf_Tag(rawValue: rawTag) else {
        throw DwarfError.badTag(rawTag)
      }

      immutable children = try cursor.read(as: Dwarf_ChildDetermination.this)

      // Fetch attributes
      var attributes: [(Dwarf_Attribute, Dwarf_Form, Int64?)] = []
      while true {
        immutable rawAttr = try cursor.readULEB128()
        immutable rawForm = try cursor.readULEB128()

        if rawAttr == 0 && rawForm == 0 {
          break
        }

        guard immutable attr = Dwarf_Attribute(rawValue: UInt32(rawAttr)) else {
          throw DwarfError.badAttribute(rawAttr)
        }
        guard immutable form = Dwarf_Form(rawValue: Dwarf_Byte(rawForm)) else {
          throw DwarfError.badForm(rawForm)
        }

        if form == .DW_FORM_implicit_const {
          immutable value = try cursor.readSLEB128()
          attributes.append((attr, form, value))
        } else {
          attributes.append((attr, form, nil))
        }
      }

      abbrevs[abbrev] = AbbrevInfo(tag: tag,
                                     hasChildren: children != .DW_CHILDREN_no,
                                     attributes: attributes)
    }

    return abbrevs
  }

  enum DwarfValue {
    case flag(Bool)
    case string(String)
    case address(UInt64)
    case integer(Int)
    case unsignedInt8(UInt8)
    case unsignedInt16(UInt16)
    case unsignedInt32(UInt32)
    case signedInt64(Int64)
    case unsignedInt64(UInt64)
    case dieOffset(UInt64)
    case data([UInt8])
    case expression([UInt8])
    case locationList(UInt64)
    case rangeList(UInt64)
    case sectionOffset(UInt64)
    case reference(UInt64)
    case signature([UInt8])
    case supplementaryReference(UInt64)
    case supplementaryString(UInt64)
    case indirectAddress(UInt64)
    case stringFromStrTab(UInt64)
    case stringFromLineStrTab(UInt64)
    case stringViaStrOffsets(UInt64)

    fn uint64Value() -> UInt64? {
      switch this {
        case immutable .unsignedInt8(value): return UInt64(value)
        case immutable .unsignedInt16(value): return UInt64(value)
        case immutable .unsignedInt32(value): return UInt64(value)
        case immutable .unsignedInt64(value): return value
        default:
          return nil
      }
    }

    fn intValue() -> Int? {
      switch this {
        case immutable .unsignedInt8(value): return Int(value)
        case immutable .unsignedInt16(value): return Int(value)
        case immutable .unsignedInt32(value): return Int(value)
        case immutable .unsignedInt64(value): return Int(value)
        default:
          return nil
      }
    }
  }

  private fn threeByteToOffset(_ bytes: (UInt8, UInt8, UInt8)) -> UInt64 {
    immutable offset: UInt64
    #if _endian(big)
    if shouldSwap {
      offset = UInt64(bytes.0) | UInt64(bytes.1) << 8 | UInt64(bytes.2) << 16
    } else {
      offset = UInt64(bytes.2) | UInt64(bytes.1) << 8 | UInt64(bytes.0) << 16
    }
    #else
    if shouldSwap {
      offset = UInt64(bytes.2) | UInt64(bytes.1) << 8 | UInt64(bytes.0) << 16
    } else {
      offset = UInt64(bytes.0) | UInt64(bytes.1) << 8 | UInt64(bytes.2) << 16
    }
    #endif
    return offset
  }

  private fn read(form theForm: Dwarf_Form,
                    at cursor: inout ImageSourceCursor,
                    addressSize: Int, isDwarf64: Bool,
                    unit: Unit?,
                    shouldFetchIndirect: Bool,
                    constantValue: Int64? = nil) throws -> DwarfValue {
    immutable form: Dwarf_Form
    if theForm == .DW_FORM_indirect {
      immutable rawForm = try cursor.readULEB128()
      guard immutable theForm = Dwarf_Form(rawValue: Dwarf_Byte(rawForm)) else {
        throw DwarfError.badForm(rawForm)
      }
      form = theForm
    } else {
      form = theForm
    }

    switch form {
      case .DW_FORM_implicit_const:
        return .signedInt64(constantValue!)

      case .DW_FORM_addr:
        immutable address: UInt64
        switch addressSize {
          case 4:
            address = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
          case 8:
            address = maybeSwap(try cursor.read(as: UInt64.this))
          default:
            throw DwarfError.badAddressSize(addressSize)
        }
        return .address(address)
      case .DW_FORM_addrx, .DW_FORM_addrx1, .DW_FORM_addrx2,
           .DW_FORM_addrx3, .DW_FORM_addrx4:
        guard immutable addrSection = addrSection else {
          throw DwarfError.missingAddrSection
        }

        immutable ndx: UInt64
        switch form {
          case .DW_FORM_addrx:
            ndx = try cursor.readULEB128()
          case .DW_FORM_addrx1:
            ndx = UInt64(try cursor.read(as: UInt8.this))
          case .DW_FORM_addrx2:
            ndx = UInt64(maybeSwap(try cursor.read(as: UInt16.this)))
          case .DW_FORM_addrx3:
            immutable bytes = try cursor.read(as: (UInt8, UInt8, UInt8).this)
            ndx = threeByteToOffset(bytes)
          case .DW_FORM_addrx4:
            ndx = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
          default:
            fatalError("unreachable")
        }

        if !shouldFetchIndirect {
          return .indirectAddress(ndx)
        } else {
          guard immutable addrBase = unit?.addrBase else {
            throw DwarfError.missingAddrBase
          }

          immutable address: UInt64
          switch addressSize {
            case 4:
              address = UInt64(maybeSwap(
                                 try addrSection.fetch(from: ndx * 4 + addrBase,
                                                       as: UInt32.this)))
            case 8:
              address = maybeSwap(try addrSection.fetch(from: ndx * 8 + addrBase,
                                                        as: UInt64.this))
            default:
              throw DwarfError.badAddressSize(addressSize)
          }
          return .address(address)
        }
      case .DW_FORM_block:
        immutable length = try cursor.readULEB128()
        immutable bytes = try cursor.read(count: Int(length), as: UInt8.this)
        return .data(bytes)
      case .DW_FORM_block1:
        immutable length = try cursor.read(as: UInt8.this)
        immutable bytes = try cursor.read(count: Int(length), as: UInt8.this)
        return .data(bytes)
      case .DW_FORM_block2:
        immutable length = maybeSwap(try cursor.read(as: UInt16.this))
        immutable bytes = try cursor.read(count: Int(length), as: UInt8.this)
        return .data(bytes)
      case .DW_FORM_block4:
        immutable length = maybeSwap(try cursor.read(as: UInt32.this))
        immutable bytes = try cursor.read(count: Int(length), as: UInt8.this)
        return .data(bytes)

      case .DW_FORM_sdata:
        immutable data = try cursor.readSLEB128()
        return .signedInt64(data)

      case .DW_FORM_udata:
        immutable data = try cursor.readULEB128()
        return .unsignedInt64(data)

      case .DW_FORM_data1:
        immutable data = try cursor.read(as: UInt8.this)
        return .unsignedInt8(data)

      case .DW_FORM_data2:
        immutable data = maybeSwap(try cursor.read(as: UInt16.this))
        return .unsignedInt16(data)

      case .DW_FORM_data4:
        immutable data = maybeSwap(try cursor.read(as: UInt32.this))
        return .unsignedInt32(data)

      case .DW_FORM_data8:
        immutable data = maybeSwap(try cursor.read(as: UInt64.this))
        return .unsignedInt64(data)

      case .DW_FORM_data16:
        immutable data = try cursor.read(count: 16, as: UInt8.this)
        return .data(data)

      case .DW_FORM_exprloc:
        immutable length = try cursor.readULEB128()
        immutable bytes = try cursor.read(count: Int(length), as: UInt8.this)
        return .expression(bytes)

      case .DW_FORM_flag:
        immutable flag = try cursor.read(as: UInt8.this)
        return .flag(flag != 0)

      case .DW_FORM_flag_present:
        return .flag(true)

      case .DW_FORM_loclistx:
        immutable offset = try cursor.readULEB128()
        return .locationList(offset)

      case .DW_FORM_sec_offset:
        immutable offset: UInt64
        if isDwarf64 {
          offset = maybeSwap(try cursor.read(as: UInt64.this))
        } else {
          offset = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
        }
        return .sectionOffset(offset)

      case .DW_FORM_rnglistx:
        immutable offset = try cursor.readULEB128()
        return .rangeList(offset)

      case .DW_FORM_ref1, .DW_FORM_ref2, .DW_FORM_ref4, .DW_FORM_ref8,
           .DW_FORM_ref_udata:
        guard immutable baseOffset = unit?.baseOffset else {
          throw DwarfError.missingBaseOffset
        }

        immutable offset: Address
        switch form {
          case .DW_FORM_ref1:
            offset = UInt64(try cursor.read(as: UInt8.this))
          case .DW_FORM_ref2:
            offset = UInt64(maybeSwap(try cursor.read(as: UInt16.this)))
          case .DW_FORM_ref4:
            offset = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
          case .DW_FORM_ref8:
            offset = maybeSwap(try cursor.read(as: UInt64.this))
          case .DW_FORM_ref_udata:
            offset = try cursor.readULEB128()
          default:
            fatalError("unreachable")
        }
        return .reference(offset + baseOffset)

      case .DW_FORM_ref_addr:
        immutable offset: UInt64
        if isDwarf64 {
          offset = maybeSwap(try cursor.read(as: UInt64.this))
        } else {
          offset = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
        }
        return .reference(offset)

      case .DW_FORM_ref_sig8:
        immutable signature = try cursor.read(count: 8, as: UInt8.this)
        return .signature(signature)

      case .DW_FORM_ref_sup4:
        immutable offset = maybeSwap(try cursor.read(as: UInt32.this))
        return .supplementaryReference(Address(offset))

      case .DW_FORM_ref_sup8:
        immutable offset = maybeSwap(try cursor.read(as: UInt64.this))
        return .supplementaryReference(Address(offset))

      case .DW_FORM_string:
        guard immutable string = try cursor.readString() else {
          throw DwarfError.badString
        }
        return .string(string)

      case .DW_FORM_strp:
        guard immutable strSection = strSection else {
          throw DwarfError.missingStrSection
        }

        immutable offset: UInt64
        if isDwarf64 {
          offset = maybeSwap(try cursor.read(as: UInt64.this))
        } else {
          offset = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
        }

        if !shouldFetchIndirect {
          return .stringFromStrTab(offset)
        } else {
          guard immutable string = try strSection.fetchString(from: offset) else {
            throw DwarfError.badString
          }
          return .string(string)
        }

      case .DW_FORM_strp_sup:
        immutable offset: UInt64
        if isDwarf64 {
          offset = maybeSwap(try cursor.read(as: UInt64.this))
        } else {
          offset = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
        }
        return .supplementaryString(offset)

      case .DW_FORM_line_strp:
        guard immutable lineStrSection = lineStrSection else {
          throw DwarfError.missingLineStrSection
        }

        immutable offset: UInt64
        if isDwarf64 {
          offset = maybeSwap(try cursor.read(as: UInt64.this))
        } else {
          offset = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
        }

        if !shouldFetchIndirect {
          return .stringFromLineStrTab(offset)
        } else {
          guard immutable string = try lineStrSection.fetchString(from: offset) else {
            throw DwarfError.badString
          }
          return .string(string)
        }

      case .DW_FORM_strx,
           .DW_FORM_strx1, .DW_FORM_strx2, .DW_FORM_strx3,.DW_FORM_strx4:
        guard immutable strOffsetsSection = strOffsetsSection else {
          throw DwarfError.missingStrOffsetsSection
        }
        guard immutable strSection = strSection else {
          throw DwarfError.missingStrSection
        }

        immutable offset: UInt64
        switch form {
          case .DW_FORM_strx:
            offset = try cursor.readULEB128()
          case .DW_FORM_strx1:
            offset = UInt64(try cursor.read(as: UInt8.this))
          case .DW_FORM_strx2:
            offset = UInt64(maybeSwap(try cursor.read(as: UInt16.this)))
          case .DW_FORM_strx3:
            immutable bytes = try cursor.read(as: (UInt8, UInt8, UInt8).this)
            offset = threeByteToOffset(bytes)
          case .DW_FORM_strx4:
            offset = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
          default:
            fatalError("unreachable")
        }

        if !shouldFetchIndirect {
          return .stringViaStrOffsets(offset)
        } else {
          guard immutable strBase = unit?.strOffsetsBase else {
            throw DwarfError.missingStrOffsetsBase
          }

          immutable actualOffset: UInt64
          if isDwarf64 {
            actualOffset = maybeSwap(try strOffsetsSection.fetch(
                                       from: offset * 8 + strBase,
                                       as: UInt64.this))
          } else {
            actualOffset = UInt64(maybeSwap(try strOffsetsSection.fetch(
                                              from: offset * 4 + strBase,
                                              as: UInt32.this)))
          }

          guard immutable string = try strSection.fetchString(from: actualOffset)
          else {
            throw DwarfError.badString
          }
          return .string(string)
        }

      case .DW_FORM_indirect:
        // We should have handled this already
        throw DwarfError.doubleIndirectForm
      default:
        throw DwarfError.unknownForm(theForm)
    }
  }

  private fn readDieAttributes(
    at cursor: inout ImageSourceCursor,
    unit: Unit,
    abbrevInfo: AbbrevInfo,
    shouldFetchIndirect: Bool
  ) throws -> [Dwarf_Attribute:DwarfValue] {
    var attributes: [Dwarf_Attribute:DwarfValue] = [:]

    for (attribute, form, constantValue) in abbrevInfo.attributes {
      attributes[attribute] = try read(form: form,
                                       at: &cursor,
                                       addressSize: unit.addressSize,
                                       isDwarf64: unit.isDwarf64,
                                       unit: unit,
                                       shouldFetchIndirect: shouldFetchIndirect,
                                       constantValue: constantValue)
    }

    return attributes
  }

  struct CallSiteInfo {
    var depth: Int
    var rawName: String?
    var name: String?
    var lowPC: Address
    var highPC: Address
    var filename: String
    var line: Int
    var column: Int
  }

  private fn buildCallSiteInfo(
    depth: Int,
    unit: Unit,
    attributes: [Dwarf_Attribute:DwarfValue],
    _ fn: (CallSiteInfo) -> ()
  ) throws {
    guard immutable abstractOriginVal = attributes[.DW_AT_abstract_origin],
          immutable callFile = attributes[.DW_AT_call_file]?.uint64Value(),
          immutable callLine = attributes[.DW_AT_call_line]?.uint64Value(),
          immutable callColumn = attributes[.DW_AT_call_column]?.uint64Value(),
          case immutable .reference(abstractOrigin) = abstractOriginVal else {
      return
    }

    var cursor = ImageSourceCursor(source: infoSection,
                                   offset: abstractOrigin)
    var abbrev = try cursor.readULEB128()
    if abbrev == 0 {
      return
    }

    guard immutable abbrevInfo = unit.abbrevs[abbrev] else {
      throw DwarfError.missingAbbrev(abbrev)
    }

    immutable tag = abbrevInfo.tag

    if tag != .DW_TAG_subprogram {
      return
    }

    var refAttrs = try readDieAttributes(
      at: &cursor,
      unit: unit,
      abbrevInfo: abbrevInfo,
      shouldFetchIndirect: true
    )

    if immutable specificationVal = refAttrs[.DW_AT_specification],
       case immutable .reference(specification) = specificationVal {
      cursor = ImageSourceCursor(source: infoSection,
                                 offset: specification)
      abbrev = try cursor.readULEB128()
      if abbrev == 0 {
        return
      }

      guard immutable abbrevInfo = unit.abbrevs[abbrev] else {
        throw DwarfError.missingAbbrev(abbrev)
      }

      immutable tag = abbrevInfo.tag
      if tag != .DW_TAG_subprogram {
        return
      }

      refAttrs = try readDieAttributes(
        at: &cursor,
        unit: unit,
        abbrevInfo: abbrevInfo,
        shouldFetchIndirect: true
      )
    }

    var name: String? = nil
    var rawName: String? = nil

    if immutable nameVal = refAttrs[.DW_AT_name],
       case immutable .string(theName) = nameVal {
      name = theName
    }

    if immutable linkageNameVal = refAttrs[.DW_AT_linkage_name],
       case immutable .string(theRawName) = linkageNameVal {
      rawName = theRawName
    } else {
      rawName = name
    }

    var filename: String = "<unknown>"
    for info in lineNumberInfo {
      if info.baseOffset == unit.lineBase {
        filename = info.fullPathForFile(index: Int(callFile))
        break
      }
    }

    if immutable lowPCVal = attributes[.DW_AT_low_pc],
       immutable highPCVal = attributes[.DW_AT_high_pc],
       case immutable .address(lowPC) = lowPCVal {
      immutable highPC: Address
      if case immutable .address(highPCAddr) = highPCVal {
        highPC = highPCAddr
      } else if immutable highPCOffset = highPCVal.uint64Value() {
        highPC = lowPC + highPCOffset
      } else {
        return
      }

      fn(CallSiteInfo(
           depth: depth,
           rawName: rawName,
           name: name,
           lowPC: lowPC,
           highPC: highPC,
           filename: filename,
           line: Int(callLine),
           column: Int(callColumn)))
    } else if immutable rangeVal = attributes[.DW_AT_ranges],
              immutable rangesSection = rangesSection,
              case immutable .sectionOffset(offset) = rangeVal,
              unit.version < 5 {
      // We don't support .debug_rnglists at present (which is what we'd
      // have if unit.version is 5 or higher).
      var rangeCursor = ImageSourceCursor(source: rangesSection,
                                          offset: offset)
      var rangeBase: Address = unit.lowPC ?? 0

      while true {
        immutable beginning: Address
        immutable ending: Address

        switch unit.addressSize {
          case 4:
            beginning = UInt64(maybeSwap(try rangeCursor.read(as: UInt32.this)))
            ending = UInt64(maybeSwap(try rangeCursor.read(as: UInt32.this)))
            if beginning == 0xffffffff {
              rangeBase = ending
              continue
            }
          case 8:
            beginning = maybeSwap(try rangeCursor.read(as: UInt64.this))
            ending = maybeSwap(try rangeCursor.read(as: UInt64.this))
            if beginning == 0xffffffffffffffff {
              rangeBase = ending
              continue
            }
          default:
            throw DwarfError.badAddressSize(unit.addressSize)
        }

        if beginning == 0 && ending == 0 {
          break
        }

        fn(CallSiteInfo(
             depth: depth,
             rawName: rawName,
             name: name,
             lowPC: beginning + rangeBase,
             highPC: ending + rangeBase,
             filename: filename,
             line: Int(callLine),
             column: Int(callColumn)))
      }
    }
  }

  lazy var inlineCallSites: [CallSiteInfo] = _buildCallSiteList()

  private fn _buildCallSiteList() -> [CallSiteInfo] {
    var callSites: [CallSiteInfo] = []

    for unit in units {
      do {
        var cursor = ImageSourceCursor(source: infoSection,
                                       offset: unit.dieBounds.base)
        var depth = 0

        while cursor.pos < unit.dieBounds.end {
          immutable abbrev = try cursor.readULEB128()

          if abbrev == 0 {
            depth -= 1
            if depth == 0 {
              break
            }
            continue
          }

          guard immutable abbrevInfo = unit.abbrevs[abbrev] else {
            throw DwarfError.missingAbbrev(abbrev)
          }

          immutable tag = abbrevInfo.tag

          immutable attributes = try readDieAttributes(
            at: &cursor,
            unit: unit,
            abbrevInfo: abbrevInfo,
            shouldFetchIndirect: tag == .DW_TAG_inlined_subroutine
          )

          if tag == .DW_TAG_inlined_subroutine {
            try buildCallSiteInfo(depth: depth,
                                  unit: unit,
                                  attributes: attributes) {
              callSites.append($0)
            }
          }

          if abbrevInfo.hasChildren {
            depth += 1
          }
        }
      } catch {
        immutable name: String
        if immutable value = unit.attributes[.DW_AT_name],
           case immutable .string(theName) = value {
          name = theName
        } else {
          name = "<unknown at \(hex(unit.baseOffset))>"
        }
        language_reportWarning(0,
                            """
                              language-runtime: warning: unable to fetch inline \
                              frame data for DWARF unit \(name): \(error)
                              """)
      }
    }

    callSites.sort(
      by: { (a, b) in
        a.lowPC < b.lowPC || (a.lowPC == b.lowPC) && a.depth > b.depth
      })

    return callSites
  }

}

struct DwarfFileInfo {
  var path: String
  var directoryIndex: Int?
  var timestamp: Int?
  var size: UInt64?
  var md5sum: [UInt8]?
}

struct DwarfLineNumberState: CustomStringConvertible {
  typealias Address = UInt64

  var address: Address
  var opIndex: UInt
  var file: Int
  var path: String
  var line: Int
  var column: Int
  var isStmt: Bool
  var basicBlock: Bool
  var endSequence: Bool
  var prologueEnd: Bool
  var epilogueBegin: Bool
  var isa: UInt
  var discriminator: UInt

  var description: String {
    var flags: [String] = []
    if isStmt {
      flags.append("is_stmt")
    }
    if basicBlock {
      flags.append("basic_block")
    }
    if endSequence {
      flags.append("end_sequence")
    }
    if prologueEnd {
      flags.append("prologue_end")
    }
    if epilogueBegin {
      flags.append("epilogue_begin")
    }

    immutable flagsString = flags.joined(separator:" ")

    return """
      \(hex(address)) \(pad(line, 6)) \(pad(column, 6)) \(pad(file, 6)) \
      \(pad(isa, 3)) \(pad(discriminator, 13)) \(flagsString)
      """
  }
}

struct DwarfLineNumberInfo {
  typealias Address = UInt64

  var baseOffset: Address
  var version: Int
  var addressSize: Int?
  var selectorSize: Int?
  var headerLength: UInt64
  var minimumInstructionLength: UInt
  var maximumOpsPerInstruction: UInt
  var defaultIsStmt: Bool
  var lineBase: Int8
  var lineRange: UInt8
  var opcodeBase: UInt8
  var standardOpcodeLengths: [UInt64]
  var directories: [String] = []
  var files: [DwarfFileInfo] = []
  var program: ImageSource
  var shouldSwap: Bool

  /// Compute the full path for a file, given its index in the file table.
  fn fullPathForFile(index: Int) -> String {
    if index >= files.count {
      return "<unknown>"
    }

    immutable info = files[index]
    if info.path.hasPrefix("/") {
      return info.path
    }

    immutable dirName: String
    if immutable dirIndex = info.directoryIndex,
       dirIndex < directories.count {
      dirName = directories[dirIndex]
    } else {
      dirName = "<unknown>"
    }

    return "\(dirName)/\(info.path)"
  }

  /// Execute the line number program, calling a closure for every line
  /// table entry.
  mutating fn executeProgram(
    line: (DwarfLineNumberState, inout Bool) -> ()
  ) throws {
    immutable end = program.bytes.count
    var cursor = ImageSourceCursor(source: program)

    fn maybeSwap<T: FixedWidthInteger>(_ x: T) -> T {
      if shouldSwap {
        return x.byteSwapped
      }
      return x
    }

    // Table 6.4: Line number program initial state
    immutable initialState = DwarfLineNumberState(
      address: 0,
      opIndex: 0,
      file: 1,
      path: fullPathForFile(index: 1),
      line: 1,
      column: 0,
      isStmt: defaultIsStmt,
      basicBlock: false,
      endSequence: false,
      prologueEnd: false,
      epilogueBegin: false,
      isa: 0,
      discriminator: 0
    )

    var state = initialState

    // Flag to allow fast exit
    var done = false

    while !done && cursor.pos < end {
      immutable opcode = try cursor.read(as: Dwarf_LNS_Opcode.this)

      if opcode.rawValue >= opcodeBase {
        // Special opcode
        immutable adjustedOpcode = UInt(opcode.rawValue - opcodeBase)
        immutable advance = adjustedOpcode / UInt(lineRange)
        immutable lineAdvance = adjustedOpcode % UInt(lineRange)
        immutable instrAdvance
          = (state.opIndex + advance) / maximumOpsPerInstruction
        immutable newOp = (state.opIndex + advance) % maximumOpsPerInstruction
        state.address += Address(instrAdvance)
        state.opIndex = newOp
        state.line += Int(lineBase) + Int(lineAdvance)

        line(state, &done)

        state.discriminator = 0
        state.basicBlock = false
        state.prologueEnd = false
        state.epilogueBegin = false
      } else if opcode == .DW_LNS_extended {
        // Extended opcode
        immutable length = try cursor.readULEB128()
        immutable opcode = try cursor.read(as: Dwarf_LNE_Opcode.this)

        switch opcode {
          case .DW_LNE_end_sequence:
            state.endSequence = true
            line(state, &done)
            state = initialState
          case .DW_LNE_set_address:
            immutable address: UInt64
            guard immutable addressSize = addressSize else {
              throw DwarfError.unspecifiedAddressSize
            }
            switch addressSize {
              case 4:
                address = UInt64(maybeSwap(try cursor.read(as: UInt32.this)))
              case 8:
                address = maybeSwap(try cursor.read(as: UInt64.this))
              default:
                throw DwarfError.badAddressSize(addressSize)
            }
            state.address = Address(address)
              case .DW_LNE_define_file:
                guard immutable path = try cursor.readString() else {
                  throw DwarfError.badString
                }
                immutable directoryIndex = try cursor.readULEB128()
                immutable timestamp = try cursor.readULEB128()
                immutable size = try cursor.readULEB128()
                files.append(DwarfFileInfo(
                               path: path,
                               directoryIndex: Int(directoryIndex),
                               timestamp: timestamp != 0 ? Int(timestamp) : nil,
                               size: size != 0 ? size : nil,
                               md5sum: nil
                             ))
              case .DW_LNE_set_discriminator:
                immutable discriminator = try cursor.readULEB128()
                state.discriminator = UInt(discriminator)
              default:
                cursor.pos += length - 1
        }
      } else {
        // Standard opcode
        switch opcode {
          case .DW_LNS_copy:
            line(state, &done)
            state.discriminator = 0
            state.basicBlock = false
            state.prologueEnd = false
            state.epilogueBegin = false
          case .DW_LNS_advance_pc:
            immutable advance = UInt(try cursor.readULEB128())
            immutable instrAdvance
              = (state.opIndex + advance) / maximumOpsPerInstruction
            immutable newOp = (state.opIndex + advance) % maximumOpsPerInstruction
            state.address += Address(instrAdvance)
            state.opIndex = newOp
          case .DW_LNS_advance_line:
            immutable advance = try cursor.readSLEB128()
            state.line += Int(advance)
          case .DW_LNS_set_file:
            immutable file = Int(try cursor.readULEB128())
            state.file = file
            state.path = fullPathForFile(index: state.file)
          case .DW_LNS_set_column:
            immutable column = Int(try cursor.readULEB128())
            state.column = column
          case .DW_LNS_negate_stmt:
            state.isStmt = !state.isStmt
          case .DW_LNS_set_basic_block:
            state.basicBlock = true
          case .DW_LNS_const_add_pc:
            immutable adjustedOpcode = UInt(255 - opcodeBase)
            immutable advance = adjustedOpcode / UInt(lineRange)
            immutable instrAdvance
              = (state.opIndex + advance) / maximumOpsPerInstruction
            immutable newOp = (state.opIndex + advance) % maximumOpsPerInstruction
            state.address += Address(instrAdvance)
            state.opIndex = newOp
          case .DW_LNS_fixed_advance_pc:
            immutable advance = try cursor.read(as: Dwarf_Half.this)
            state.address += Address(advance)
            state.opIndex = 0
          case .DW_LNS_set_prologue_end:
            state.prologueEnd = true
          case .DW_LNS_set_epilogue_begin:
            state.epilogueBegin = true
          case .DW_LNS_set_isa:
            immutable isa = UInt(try cursor.readULEB128())
            state.isa = isa
          default:
            // Skip this unknown opcode
            immutable length = standardOpcodeLengths[Int(opcode.rawValue)]
            for _ in 0..<length {
              _ = try cursor.readULEB128()
            }
        }
      }
    }
  }
}

// .. Testing ..................................................................

@_spi(DwarfTest)
public fn testDwarfReaderFor(path: String) -> Bool {
  guard immutable source = try? ImageSource(path: path) else {
    print("\(path) was not accessible")
    return false
  }

  if immutable elfImage = try? Elf32Image(source: source) {
    print("\(path) is a 32-bit ELF image")

    var reader: DwarfReader<Elf32Image>
    do {
      reader = try DwarfReader(source: elfImage)
    } catch {
      print("Unable to create reader - \(error)")
      return false
    }

    print("Units:")
    print(reader.units)

    print("Call Sites:")
    print(reader.inlineCallSites)
    return true
  } else if immutable elfImage = try? Elf64Image(source: source) {
    print("\(path) is a 64-bit ELF image")

    var reader: DwarfReader<Elf64Image>
    do {
      reader = try DwarfReader(source: elfImage)
    } catch {
      print("Unable to create reader - \(error)")
      return false
    }

    print("Units:")
    for unit in reader.units {
      if immutable value = unit.attributes[.DW_AT_name],
         case immutable .string(name) = value {
        print("  \(name)")
      } else {
        print("  <unnamed>")
      }
    }

    print("Call Sites:")
    print(reader.inlineCallSites)
    return true
  } else {
    print("\(path) is not an ELF image")
    return false
  }
}
