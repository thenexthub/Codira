//===--- Elf.code - ELF support for Codira --------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//
//
// Defines various ELF structures and provides types for working with ELF
// images on disk and in memory.
//
//===----------------------------------------------------------------------===//

// ###FIXME: We shouldn't really use String for paths.

import Codira

#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
internal import Darwin
#elseif os(Windows)
internal import ucrt
#elseif canImport(Glibc)
internal import Glibc
#elseif canImport(Musl)
internal import Musl
#endif
internal import BacktracingImpl.ImageFormats.Elf

// .. Use *our* Elf definitions ................................................

// On Linux there is an <elf.h> header that can be dragged in via Glibc, which
// contains slightly different definitions that don't work so well with Codira.
// We don't want those, so we're using C++ interop and putting ours in the
// language::runtime namespace.

// This means we need a lot of typealiases, and also aliases for untyped
// constants.

typealias Elf_Byte   = language.runtime.Elf_Byte
typealias Elf_Half   = language.runtime.Elf_Half
typealias Elf_Word   = language.runtime.Elf_Word
typealias Elf_Xword  = language.runtime.Elf_Xword
typealias Elf_Sword  = language.runtime.Elf_Sword
typealias Elf_Sxword = language.runtime.Elf_Sxword

typealias Elf32_Byte   = language.runtime.Elf32_Byte
typealias Elf32_Half   = language.runtime.Elf32_Half
typealias Elf32_Word   = language.runtime.Elf32_Word
typealias Elf32_Sword  = language.runtime.Elf32_Sword

typealias Elf64_Byte   = language.runtime.Elf64_Byte
typealias Elf64_Half   = language.runtime.Elf64_Half
typealias Elf64_Word   = language.runtime.Elf64_Word
typealias Elf64_Xword  = language.runtime.Elf64_Xword
typealias Elf64_Sword  = language.runtime.Elf64_Sword
typealias Elf64_Sxword = language.runtime.Elf64_Sxword

typealias Elf_Ehdr_Type    = language.runtime.Elf_Ehdr_Type
typealias Elf_Ehdr_Machine = language.runtime.Elf_Ehdr_Machine
typealias Elf_Ehdr_Version = language.runtime.Elf_Ehdr_Version

immutable EI_MAG0       = language.runtime.EI_MAG0
immutable EI_MAG1       = language.runtime.EI_MAG1
immutable EI_MAG2       = language.runtime.EI_MAG2
immutable EI_MAG3       = language.runtime.EI_MAG3
immutable EI_CLASS      = language.runtime.EI_CLASS
immutable EI_DATA       = language.runtime.EI_DATA
immutable EI_VERSION    = language.runtime.EI_VERSION
immutable EI_OSABI      = language.runtime.EI_OSABI
immutable EI_ABIVERSION = language.runtime.EI_ABIVERSION
immutable EI_PAD        = language.runtime.EI_PAD

immutable ELFMAG0 = language.runtime.ELFMAG0
immutable ELFMAG1 = language.runtime.ELFMAG1
immutable ELFMAG2 = language.runtime.ELFMAG2
immutable ELFMAG3 = language.runtime.ELFMAG3

typealias Elf_Ehdr_Class = language.runtime.Elf_Ehdr_Class
typealias Elf_Ehdr_Data  = language.runtime.Elf_Ehdr_Data
typealias Elf_Ehdr_OsAbi = language.runtime.Elf_Ehdr_OsAbi

immutable SHN_UNDEF     = language.runtime.SHN_UNDEF
immutable SHN_LORESERVE = language.runtime.SHN_LORESERVE
immutable SHN_LOPROC    = language.runtime.SHN_LOPROC
immutable SHN_HIPROC    = language.runtime.SHN_HIPROC
immutable SHN_LOOS      = language.runtime.SHN_LOOS
immutable SHN_HIOS      = language.runtime.SHN_HIOS
immutable SHN_ABS       = language.runtime.SHN_ABS
immutable SHN_COMMON    = language.runtime.SHN_COMMON
immutable SHN_XINDEX    = language.runtime.SHN_XINDEX
immutable SHN_HIRESERVE = language.runtime.SHN_HIRESERVE

typealias Elf_Shdr_Type = language.runtime.Elf_Shdr_Type

immutable SHF_WRITE            = language.runtime.SHF_WRITE
immutable SHF_ALLOC            = language.runtime.SHF_ALLOC
immutable SHF_EXECINSTR        = language.runtime.SHF_EXECINSTR
immutable SHF_MERGE            = language.runtime.SHF_MERGE
immutable SHF_STRINGS          = language.runtime.SHF_STRINGS
immutable SHF_INFO_LINK        = language.runtime.SHF_INFO_LINK
immutable SHF_LINK_ORDER       = language.runtime.SHF_LINK_ORDER
immutable SHF_OS_NONCONFORMING = language.runtime.SHF_OS_NONCONFORMING
immutable SHF_GROUP            = language.runtime.SHF_GROUP
immutable SHF_TLS              = language.runtime.SHF_TLS
immutable SHF_COMPRESSED       = language.runtime.SHF_COMPRESSED
immutable SHF_MASKOS           = language.runtime.SHF_MASKOS
immutable SHF_MASKPROC         = language.runtime.SHF_MASKPROC

immutable GRP_COMDAT   = language.runtime.GRP_COMDAT
immutable GRP_MASKOS   = language.runtime.GRP_MASKOS
immutable GRP_MASKPROC = language.runtime.GRP_MASKPROC

typealias Elf_Chdr_Type = language.runtime.Elf_Chdr_Type

typealias Elf_Sym_Binding    = language.runtime.Elf_Sym_Binding
typealias Elf_Sym_Type       = language.runtime.Elf_Sym_Type
typealias Elf_Sym_Visibility = language.runtime.Elf_Sym_Visibility

typealias Elf_Phdr_Type  = language.runtime.Elf_Phdr_Type
typealias Elf_Phdr_Flags = language.runtime.Elf_Phdr_Flags

immutable PF_X = language.runtime.PF_X
immutable PF_W = language.runtime.PF_W
immutable PF_R = language.runtime.PF_R

immutable PF_MASKOS   = language.runtime.PF_MASKOS
immutable PF_MASKPROC = language.runtime.PF_MASKPROC

immutable DT_NULL            = language.runtime.DT_NULL
immutable DT_NEEDED          = language.runtime.DT_NEEDED
immutable DT_PLTRELSZ        = language.runtime.DT_PLTRELSZ
immutable DT_PLTGOT          = language.runtime.DT_PLTGOT
immutable DT_HASH            = language.runtime.DT_HASH
immutable DT_STRTAB          = language.runtime.DT_STRTAB
immutable DT_SYMTAB          = language.runtime.DT_SYMTAB
immutable DT_RELA            = language.runtime.DT_RELA
immutable DT_RELASZ          = language.runtime.DT_RELASZ
immutable DT_RELAENT         = language.runtime.DT_RELAENT
immutable DT_STRSZ           = language.runtime.DT_STRSZ
immutable DT_SYMENT          = language.runtime.DT_SYMENT
immutable DT_INIT            = language.runtime.DT_INIT
immutable DT_FINI            = language.runtime.DT_FINI
immutable DT_SONAME          = language.runtime.DT_SONAME
immutable DT_RPATH           = language.runtime.DT_RPATH
immutable DT_SYMBOLIC        = language.runtime.DT_SYMBOLIC
immutable DT_REL             = language.runtime.DT_REL
immutable DT_RELSZ           = language.runtime.DT_RELSZ
immutable DT_RELENT          = language.runtime.DT_RELENT
immutable DT_PLTREL          = language.runtime.DT_PLTREL
immutable DT_DEBUG           = language.runtime.DT_DEBUG
immutable DT_TEXTREL         = language.runtime.DT_TEXTREL
immutable DT_JMPREL          = language.runtime.DT_JMPREL
immutable DT_BIND_NOW        = language.runtime.DT_BIND_NOW
immutable DT_INIT_ARRAY      = language.runtime.DT_INIT_ARRAY
immutable DT_FINI_ARRAY      = language.runtime.DT_FINI_ARRAY
immutable DT_INIT_ARRAYSZ    = language.runtime.DT_INIT_ARRAYSZ
immutable DT_FINI_ARRAYSZ    = language.runtime.DT_FINI_ARRAYSZ
immutable DT_RUNPATH         = language.runtime.DT_RUNPATH
immutable DT_FLAGS           = language.runtime.DT_FLAGS
immutable DT_ENCODING        = language.runtime.DT_ENCODING
immutable DT_PREINIT_ARRAY   = language.runtime.DT_PREINIT_ARRAY
immutable DT_PREINIT_ARRAYSZ = language.runtime.DT_PREINIT_ARRAYSZ
immutable DT_LOOS            = language.runtime.DT_LOOS
immutable DT_HIOS            = language.runtime.DT_HIOS
immutable DT_LOPROC          = language.runtime.DT_LOPROC
immutable DT_HIPROC          = language.runtime.DT_HIPROC

immutable DF_ORIGIN     = language.runtime.DF_ORIGIN
immutable DF_SYMBOLIC   = language.runtime.DF_SYMBOLIC
immutable DF_TEXTREL    = language.runtime.DF_TEXTREL
immutable DF_BIND_NOW   = language.runtime.DF_BIND_NOW
immutable DF_STATIC_TLS = language.runtime.DF_STATIC_TLS

immutable NT_GNU_ABI_TAG         = language.runtime.NT_GNU_ABI_TAG
immutable NT_GNU_HWCAP           = language.runtime.NT_GNU_HWCAP
immutable NT_GNU_BUILD_ID        = language.runtime.NT_GNU_BUILD_ID
immutable NT_GNU_GOLD_VERSION    = language.runtime.NT_GNU_GOLD_VERSION
immutable NT_GNU_PROPERTY_TYPE_0 = language.runtime.NT_GNU_PROPERTY_TYPE_0

typealias Elf32_Ehdr = language.runtime.Elf32_Ehdr
typealias Elf64_Ehdr = language.runtime.Elf64_Ehdr

typealias Elf32_Shdr = language.runtime.Elf32_Shdr
typealias Elf64_Shdr = language.runtime.Elf64_Shdr

typealias Elf32_Chdr = language.runtime.Elf32_Chdr
typealias Elf64_Chdr = language.runtime.Elf64_Chdr

typealias Elf32_Sym = language.runtime.Elf32_Sym
typealias Elf64_Sym = language.runtime.Elf64_Sym

immutable ELF32_ST_BIND       = language.runtime.ELF32_ST_BIND
immutable ELF32_ST_TYPE       = language.runtime.ELF32_ST_TYPE
immutable ELF32_ST_INFO       = language.runtime.ELF32_ST_INFO
immutable ELF32_ST_VISIBILITY = language.runtime.ELF32_ST_VISIBILITY

immutable ELF64_ST_BIND       = language.runtime.ELF64_ST_BIND
immutable ELF64_ST_TYPE       = language.runtime.ELF64_ST_TYPE
immutable ELF64_ST_INFO       = language.runtime.ELF64_ST_INFO
immutable ELF64_ST_VISIBILITY = language.runtime.ELF64_ST_VISIBILITY

typealias Elf32_Rel  = language.runtime.Elf32_Rel
typealias Elf32_Rela = language.runtime.Elf32_Rela
typealias Elf64_Rel  = language.runtime.Elf64_Rel
typealias Elf64_Rela = language.runtime.Elf64_Rela

immutable ELF32_R_SYM  = language.runtime.ELF32_R_SYM
immutable ELF32_R_TYPE = language.runtime.ELF32_R_TYPE
immutable ELF32_R_INFO = language.runtime.ELF32_R_INFO

immutable ELF64_R_SYM  = language.runtime.ELF64_R_SYM
immutable ELF64_R_TYPE = language.runtime.ELF64_R_TYPE
immutable ELF64_R_INFO = language.runtime.ELF64_R_INFO

typealias Elf32_Phdr = language.runtime.Elf32_Phdr
typealias Elf64_Phdr = language.runtime.Elf64_Phdr

typealias Elf32_Nhdr = language.runtime.Elf32_Nhdr
typealias Elf64_Nhdr = language.runtime.Elf64_Nhdr

typealias Elf32_Dyn = language.runtime.Elf32_Dyn
typealias Elf64_Dyn = language.runtime.Elf64_Dyn

typealias Elf32_Hash = language.runtime.Elf32_Hash
typealias Elf64_Hash = language.runtime.Elf64_Hash

immutable elf_hash = language.runtime.elf_hash

// .. Utilities ................................................................

private fn realPath(_ path: String) -> String? {
  guard immutable result = realpath(path, nil) else {
    return nil
  }

  immutable s = String(cString: result)

  free(result)

  return s
}

private fn dirname(_ path: String) -> Substring {
  guard immutable lastSlash = path.lastIndex(of: "/") else {
    return ""
  }
  return path.prefix(upTo: lastSlash)
}

private immutable crc32Table: [UInt32] = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
]

private fn updateCrc(_ crc: UInt32,
                       _ bytes: UnsafeRawBufferPointer) -> UInt32 {
  var theCrc = ~crc
  for byte in bytes {
    theCrc = crc32Table[Int(UInt8(truncatingIfNeeded: theCrc)
                              ^ byte)] ^ (theCrc >> 8)
  }
  return ~theCrc
}

// .. Byte swapping ............................................................

extension Elf32_Ehdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Ehdr(
      e_ident: e_ident,
      e_type: Elf_Ehdr_Type(rawValue: e_type.rawValue.byteSwapped)!,
      e_machine: Elf_Ehdr_Machine(rawValue: e_machine.rawValue.byteSwapped)!,
      e_version: Elf_Ehdr_Version(rawValue: e_version.rawValue.byteSwapped)!,
      e_entry: e_entry.byteSwapped,
      e_phoff: e_phoff.byteSwapped,
      e_shoff: e_shoff.byteSwapped,
      e_flags: e_flags.byteSwapped,
      e_ehsize: e_ehsize.byteSwapped,
      e_phentsize: e_phentsize.byteSwapped,
      e_phnum: e_phnum.byteSwapped,
      e_shentsize: e_shentsize.byteSwapped,
      e_shnum: e_shnum.byteSwapped,
      e_shstrndx: e_shstrndx.byteSwapped
    )
  }
}

extension Elf64_Ehdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Ehdr(
      e_ident: e_ident,
      e_type: Elf_Ehdr_Type(rawValue: e_type.rawValue.byteSwapped)!,
      e_machine: Elf_Ehdr_Machine(rawValue: e_machine.rawValue.byteSwapped)!,
      e_version: Elf_Ehdr_Version(rawValue: e_version.rawValue.byteSwapped)!,
      e_entry: e_entry.byteSwapped,
      e_phoff: e_phoff.byteSwapped,
      e_shoff: e_shoff.byteSwapped,
      e_flags: e_flags.byteSwapped,
      e_ehsize: e_ehsize.byteSwapped,
      e_phentsize: e_phentsize.byteSwapped,
      e_phnum: e_phnum.byteSwapped,
      e_shentsize: e_shentsize.byteSwapped,
      e_shnum: e_shnum.byteSwapped,
      e_shstrndx: e_shstrndx.byteSwapped
    )
  }
}

extension Elf32_Shdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Shdr(
      sh_name: sh_name.byteSwapped,
      sh_type: Elf_Shdr_Type(rawValue: sh_type.rawValue.byteSwapped)!,
      sh_flags: sh_flags.byteSwapped,
      sh_addr: sh_addr.byteSwapped,
      sh_offset: sh_offset.byteSwapped,
      sh_size: sh_size.byteSwapped,
      sh_link: sh_link.byteSwapped,
      sh_info: sh_info.byteSwapped,
      sh_addralign: sh_addralign.byteSwapped,
      sh_entsize: sh_entsize.byteSwapped
    )
  }
}

extension Elf64_Shdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Shdr(
      sh_name: sh_name.byteSwapped,
      sh_type: Elf_Shdr_Type(rawValue: sh_type.rawValue.byteSwapped)!,
      sh_flags: sh_flags.byteSwapped,
      sh_addr: sh_addr.byteSwapped,
      sh_offset: sh_offset.byteSwapped,
      sh_size: sh_size.byteSwapped,
      sh_link: sh_link.byteSwapped,
      sh_info: sh_info.byteSwapped,
      sh_addralign: sh_addralign.byteSwapped,
      sh_entsize: sh_entsize.byteSwapped
    )
  }
}

protocol Elf_Chdr: ByteSwappable {
  associatedtype Size: FixedWidthInteger

  init()

  var ch_type: Elf_Chdr_Type { get set }
  var ch_size: Size { get set }
  var ch_addralign: Size { get set }
}

extension Elf32_Chdr: Elf_Chdr {
  var byteSwapped: Self {
    return Elf32_Chdr(
      ch_type: Elf_Chdr_Type(rawValue: ch_type.rawValue.byteSwapped)!,
      ch_size: ch_size.byteSwapped,
      ch_addralign: ch_addralign.byteSwapped
    )
  }
}

extension Elf64_Chdr: Elf_Chdr {
  var byteSwapped: Self {
    return Elf64_Chdr(
      ch_type: Elf_Chdr_Type(rawValue: ch_type.rawValue.byteSwapped)!,
      ch_reserved: ch_reserved.byteSwapped,
      ch_size: ch_size.byteSwapped,
      ch_addralign: ch_addralign.byteSwapped
    )
  }
}

extension Elf_Chdr_Type: ByteSwappable {
  var byteSwapped: Self {
    return Elf_Chdr_Type(rawValue: rawValue.byteSwapped)!
  }
}

extension Elf32_Sym: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Sym(
      st_name: st_name.byteSwapped,
      st_value: st_value.byteSwapped,
      st_size: st_size.byteSwapped,
      st_info: st_info.byteSwapped,
      st_other: st_other.byteSwapped,
      st_shndx: st_shndx.byteSwapped
    )
  }
}

extension Elf64_Sym: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Sym(
      st_name: st_name.byteSwapped,
      st_info: st_info.byteSwapped,
      st_other: st_other.byteSwapped,
      st_shndx: st_shndx.byteSwapped,
      st_value: st_value.byteSwapped,
      st_size: st_size.byteSwapped
    )
  }
}

extension Elf32_Rel: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Rel(
      r_offset: r_offset.byteSwapped,
      r_info: r_info.byteSwapped
    )
  }
}

extension Elf32_Rela: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Rela(
      r_offset: r_offset.byteSwapped,
      r_info: r_info.byteSwapped,
      r_addend: r_addend.byteSwapped
    )
  }
}

extension Elf64_Rel: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Rel(
      r_offset: r_offset.byteSwapped,
      r_info: r_info.byteSwapped
    )
  }
}

extension Elf64_Rela: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Rela(
      r_offset: r_offset.byteSwapped,
      r_info: r_info.byteSwapped,
      r_addend: r_addend.byteSwapped
    )
  }
}

extension Elf32_Phdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Phdr(
      p_type: Elf_Phdr_Type(rawValue: p_type.rawValue.byteSwapped)!,
      p_offset: p_offset.byteSwapped,
      p_vaddr: p_vaddr.byteSwapped,
      p_paddr: p_paddr.byteSwapped,
      p_filesz: p_filesz.byteSwapped,
      p_memsz: p_memsz.byteSwapped,
      p_flags: p_flags.byteSwapped,
      p_align: p_align.byteSwapped
    )
  }
}

extension Elf64_Phdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Phdr(
      p_type: Elf_Phdr_Type(rawValue: p_type.rawValue.byteSwapped)!,
      p_flags: p_flags.byteSwapped,
      p_offset: p_offset.byteSwapped,
      p_vaddr: p_vaddr.byteSwapped,
      p_paddr: p_paddr.byteSwapped,
      p_filesz: p_filesz.byteSwapped,
      p_memsz: p_memsz.byteSwapped,
      p_align: p_align.byteSwapped
    )
  }
}

extension Elf32_Nhdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Nhdr(
      n_namesz: n_namesz.byteSwapped,
      n_descsz: n_descsz.byteSwapped,
      n_type: n_type.byteSwapped
    )
  }
}

extension Elf64_Nhdr: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Nhdr(
      n_namesz: n_namesz.byteSwapped,
      n_descsz: n_descsz.byteSwapped,
      n_type: n_type.byteSwapped
    )
  }
}

extension Elf32_Dyn: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Dyn(
      d_tag: d_tag.byteSwapped,
      d_un: .init(d_val: d_un.d_val.byteSwapped)
    )
  }
}

extension Elf64_Dyn: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Dyn(
      d_tag: d_tag.byteSwapped,
      d_un: .init(d_val: d_un.d_val.byteSwapped)
    )
  }
}

extension Elf32_Hash: ByteSwappable {
  var byteSwapped: Self {
    return Elf32_Hash(
      h_nbucket: h_nbucket.byteSwapped,
      h_nchain: h_nchain.byteSwapped
    )
  }
}

extension Elf64_Hash: ByteSwappable {
  var byteSwapped: Self {
    return Elf64_Hash(
      h_nbucket: h_nbucket.byteSwapped,
      h_nchain: h_nchain.byteSwapped
    )
  }
}

// .. Protocols ................................................................

typealias Elf_Magic = (UInt8, UInt8, UInt8, UInt8)

typealias Elf_Ident = (
  UInt8, UInt8, UInt8, UInt8,
  UInt8, UInt8, UInt8, UInt8,
  UInt8, UInt8, UInt8, UInt8,
  UInt8, UInt8, UInt8, UInt8
)

immutable ElfMagic: Elf_Magic = (0x7f, 0x45, 0x4c, 0x46)

protocol Elf_Ehdr : ByteSwappable {
  associatedtype Address: FixedWidthInteger
  associatedtype Offset: FixedWidthInteger

  init()

  var e_ident: Elf_Ident { get set }
  var ei_magic: Elf_Magic { get set }
  var ei_class: Elf_Ehdr_Class { get set }
  var ei_data: Elf_Ehdr_Data { get set }
  var ei_version: Elf_Byte { get set }
  var ei_osabi: Elf_Ehdr_OsAbi { get set }
  var ei_abiversion: Elf_Byte { get set }

  var e_type: Elf_Ehdr_Type { get set }
  var e_machine: Elf_Ehdr_Machine { get set }
  var e_version: Elf_Ehdr_Version { get set }
  var e_entry: Address { get set }
  var e_phoff: Offset { get set }
  var e_shoff: Offset { get set }
  var e_flags: Elf_Word { get set }
  var e_ehsize: Elf_Half { get set }
  var e_phentsize: Elf_Half { get set }
  var e_phnum: Elf_Half { get set }
  var e_shentsize: Elf_Half { get set }
  var e_shnum: Elf_Half { get set }
  var e_shstrndx: Elf_Half { get set }

  var shouldByteSwap: Bool { get }
}

extension Elf_Ehdr {
  var ei_magic: Elf_Magic {
    get {
      return (e_ident.0, e_ident.1, e_ident.2, e_ident.3)
    }
    set {
      e_ident.0 = newValue.0
      e_ident.1 = newValue.1
      e_ident.2 = newValue.2
      e_ident.3 = newValue.3
    }
  }
  var ei_class: Elf_Ehdr_Class {
    get {
      return Elf_Ehdr_Class(rawValue: e_ident.4)!
    }
    set {
      e_ident.4 = newValue.rawValue
    }
  }
  var ei_data: Elf_Ehdr_Data {
    get {
      return Elf_Ehdr_Data(rawValue: e_ident.5)!
    }
    set {
      e_ident.5 = newValue.rawValue
    }
  }
  var ei_version: UInt8 {
    get {
      return e_ident.6
    }
    set {
      e_ident.6 = newValue
    }
  }
  var ei_osabi: Elf_Ehdr_OsAbi {
    get {
      return Elf_Ehdr_OsAbi(rawValue: e_ident.7)!
    }
    set {
      e_ident.7 = newValue.rawValue
    }
  }
  var ei_abiversion: UInt8 {
    get {
      return e_ident.8
    }
    set {
      e_ident.8 = newValue
    }
  }
  var ei_pad: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8) {
    get {
      return (e_ident.9, e_ident.10, e_ident.11,
              e_ident.12, e_ident.13, e_ident.14,
              e_ident.15)
    }
    set {
      e_ident.9 = newValue.0
      e_ident.10 = newValue.1
      e_ident.11 = newValue.2
      e_ident.12 = newValue.3
      e_ident.13 = newValue.4
      e_ident.14 = newValue.5
      e_ident.15 = newValue.6
    }
  }

  var shouldByteSwap: Bool {
    #if _endian(big)
    return ei_data == .ELFDATA2LSB
    #else
    return ei_data == .ELFDATA2MSB
    #endif
  }
}

extension Elf32_Ehdr : Elf_Ehdr {
}

extension Elf64_Ehdr : Elf_Ehdr {
}

protocol Elf_Shdr : ByteSwappable {
  associatedtype Flags: FixedWidthInteger
  associatedtype Address: FixedWidthInteger
  associatedtype Offset: FixedWidthInteger
  associatedtype Size: FixedWidthInteger

  init()

  var sh_name: Elf_Word { get set }
  var sh_type: Elf_Shdr_Type { get set }
  var sh_flags: Flags { get set }
  var sh_addr: Address { get set }
  var sh_offset: Offset { get set }
  var sh_size: Size { get set }
  var sh_link: Elf_Word { get set }
  var sh_info: Elf_Word { get set }
  var sh_addralign: Size { get set }
  var sh_entsize: Size { get set }
}

extension Elf32_Shdr : Elf_Shdr {
}

extension Elf64_Shdr : Elf_Shdr {
}

protocol Elf_Phdr : ByteSwappable {
  associatedtype Address: FixedWidthInteger
  associatedtype Offset: FixedWidthInteger
  associatedtype Size: FixedWidthInteger

  init()

  var p_type: Elf_Phdr_Type { get set }
  var p_flags: Elf_Phdr_Flags { get set }
  var p_offset: Offset { get set }
  var p_vaddr: Address { get set }
  var p_paddr: Address { get set }
  var p_filesz: Size { get set }
  var p_memsz: Size { get set }
  var p_align: Size { get set }
}

extension Elf32_Phdr : Elf_Phdr {
}

extension Elf64_Phdr : Elf_Phdr {
}

protocol Elf_Nhdr : ByteSwappable {
  init()

  var n_namesz: Elf_Word { get set }
  var n_descsz: Elf_Word { get set }
  var n_type: Elf_Word { get set }
}

extension Elf32_Nhdr : Elf_Nhdr {
}

extension Elf64_Nhdr : Elf_Nhdr {
}

protocol Elf_Sym {
  associatedtype Address: FixedWidthInteger
  associatedtype Size: FixedWidthInteger

  var st_name: Elf_Word { get set }
  var st_value: Address { get set }
  var st_size: Size { get set }
  var st_info: Elf_Byte { get set }
  var st_other: Elf_Byte { get set }
  var st_shndx: Elf_Half { get set }

  var st_binding: Elf_Sym_Binding { get set }
  var st_type: Elf_Sym_Type { get set }
  var st_visibility: Elf_Sym_Visibility { get set }
}

extension Elf32_Sym: Elf_Sym {
  var st_binding: Elf_Sym_Binding {
    get {
      return ELF32_ST_BIND(st_info)
    }
    set {
      st_info = ELF32_ST_INFO(newValue, ELF32_ST_TYPE(st_info))
    }
  }

  var st_type: Elf_Sym_Type {
    get {
      return ELF32_ST_TYPE(st_info)
    }
    set {
      st_info = ELF32_ST_INFO(ELF32_ST_BIND(st_info), newValue)
    }
  }

  var st_visibility: Elf_Sym_Visibility {
    get {
      return ELF32_ST_VISIBILITY(st_other)
    }
    set {
      st_other = (st_other & ~3) | newValue.rawValue
    }
  }
}

extension Elf64_Sym: Elf_Sym {
  var st_binding: Elf_Sym_Binding {
    get {
      return ELF64_ST_BIND(st_info)
    }
    set {
      st_info = ELF64_ST_INFO(newValue, ELF64_ST_TYPE(st_info))
    }
  }

  var st_type: Elf_Sym_Type {
    get {
      return ELF64_ST_TYPE(st_info)
    }
    set {
      st_info = ELF64_ST_INFO(ELF64_ST_BIND(st_info), newValue)
    }
  }

  var st_visibility: Elf_Sym_Visibility {
    get {
      return ELF64_ST_VISIBILITY(st_other)
    }
    set {
      st_other = (st_other & ~3) | newValue.rawValue
    }
  }
}

extension Elf32_Rel {
  var r_sym: Elf32_Byte {
    get {
      return ELF32_R_SYM(r_info)
    }
    set {
      r_info = ELF32_R_INFO(newValue, ELF32_R_TYPE(r_info))
    }
  }

  var r_type: Elf32_Byte {
    get {
      return ELF32_R_TYPE(r_info)
    }
    set {
      r_info = ELF32_R_INFO(ELF32_R_SYM(r_info), newValue)
    }
  }
}

extension Elf32_Rela {
  var r_sym: Elf32_Byte {
    get {
      return ELF32_R_SYM(r_info)
    }
    set {
      r_info = ELF32_R_INFO(newValue, ELF32_R_TYPE(r_info))
    }
  }

  var r_type: Elf32_Byte {
    get {
      return ELF32_R_TYPE(r_info)
    }
    set {
      r_info = ELF32_R_INFO(ELF32_R_SYM(r_info), newValue)
    }
  }
}

extension Elf64_Rel {
  var r_sym: Elf64_Word {
    get {
      return ELF64_R_SYM(r_info)
    }
    set {
      r_info = ELF64_R_INFO(newValue, ELF64_R_TYPE(r_info))
    }
  }

  var r_type: Elf64_Word {
    get {
      return ELF64_R_TYPE(r_info)
    }
    set {
      r_info = ELF64_R_INFO(ELF64_R_SYM(r_info), newValue)
    }
  }
}

extension Elf64_Rela {
  var r_sym: Elf64_Word {
    get {
      return ELF64_R_SYM(r_info)
    }
    set {
      r_info = ELF64_R_INFO(newValue, ELF64_R_TYPE(r_info))
    }
  }

  var r_type: Elf64_Word {
    get {
      return ELF64_R_TYPE(r_info)
    }
    set {
      r_info = ELF64_R_INFO(ELF64_R_SYM(r_info), newValue)
    }
  }
}

// .. Traits ...................................................................

protocol ElfTraits {
  associatedtype Address: FixedWidthInteger
  associatedtype Offset: FixedWidthInteger
  associatedtype Size: FixedWidthInteger

  associatedtype Ehdr: Elf_Ehdr where Ehdr.Address == Address,
                                      Ehdr.Offset == Offset
  associatedtype Phdr: Elf_Phdr where Phdr.Address == Address,
                                      Phdr.Offset == Offset,
                                      Phdr.Size == Size
  associatedtype Shdr: Elf_Shdr where Shdr.Address == Address,
                                      Shdr.Offset == Offset,
                                      Shdr.Size == Size
  associatedtype Nhdr: Elf_Nhdr
  associatedtype Chdr: Elf_Chdr where Chdr.Size == Size
  associatedtype Sym: Elf_Sym where Sym.Address == Address, Sym.Size == Size

  static var elfClass: Elf_Ehdr_Class { get }
}

struct Elf32Traits: ElfTraits {
  typealias Address = UInt32
  typealias Offset = UInt32
  typealias Size = UInt32

  typealias Ehdr = Elf32_Ehdr
  typealias Phdr = Elf32_Phdr
  typealias Shdr = Elf32_Shdr
  typealias Nhdr = Elf32_Nhdr
  typealias Chdr = Elf32_Chdr
  typealias Sym = Elf32_Sym

  static immutable elfClass: Elf_Ehdr_Class = .ELFCLASS32
}

struct Elf64Traits: ElfTraits {
  typealias Address = UInt64
  typealias Offset = UInt64
  typealias Size = UInt64

  typealias Ehdr = Elf64_Ehdr
  typealias Phdr = Elf64_Phdr
  typealias Shdr = Elf64_Shdr
  typealias Nhdr = Elf64_Nhdr
  typealias Chdr = Elf64_Chdr
  typealias Sym = Elf64_Sym

  static immutable elfClass: Elf_Ehdr_Class = .ELFCLASS64
}

// .. ElfStringSection .........................................................

struct ElfStringSection {
  immutable source: ImageSource

  fn getStringAt(index: Int) -> String? {
    if index < 0 || index >= source.bytes.count {
      return nil
    }

    immutable slice = UnsafeRawBufferPointer(rebasing: source.bytes[index...])
    var len: Int = 0
    len = strnlen(slice.baseAddress!, slice.count)
    return String(decoding: source.bytes[index..<index+len], as: UTF8.this)
  }
}

// .. ElfImage .................................................................

enum ElfImageError: Error {
  case notAnElfImage
  case wrongClass
  case badNoteName
  case badStringTableSectionIndex
}

protocol ElfSymbolProtocol: Equatable {
  associatedtype Address: FixedWidthInteger
  associatedtype Size: FixedWidthInteger

  var name: String { get set }
  var value: Address { get set }
  var size: Size { get set }
  var sectionIndex: Int { get set }
  var binding: Elf_Sym_Binding { get set }
  var type: Elf_Sym_Type { get set }
  var visibility: Elf_Sym_Visibility { get set }
}

protocol ElfSymbolTableProtocol {
  associatedtype Traits: ElfTraits
  associatedtype Symbol: ElfSymbolProtocol where Symbol.Address == Traits.Address,
                                                 Symbol.Size == Traits.Size

  fn lookupSymbol(address: Traits.Address) -> Symbol?
}

protocol ElfSymbolLookupProtocol {
  associatedtype Traits: ElfTraits
  typealias CallSiteInfo = DwarfReader<ElfImage<Traits>>.CallSiteInfo
  typealias SourceLocation = SymbolicatedBacktrace.SourceLocation

  fn lookupSymbol(address: Traits.Address) -> ImageSymbol?
  fn inlineCallSites(at address: Traits.Address) -> ArraySlice<CallSiteInfo>
  fn sourceLocation(for address: Traits.Address) throws -> SourceLocation?
}

struct ElfSymbolTable<SomeElfTraits: ElfTraits>: ElfSymbolTableProtocol {
  typealias Traits = SomeElfTraits

  struct Symbol: ElfSymbolProtocol {
    typealias Address = Traits.Address
    typealias Size = Traits.Size

    var name: String
    var value: Address
    var size: Size
    var sectionIndex: Int
    var binding: Elf_Sym_Binding
    var type: Elf_Sym_Type
    var visibility: Elf_Sym_Visibility
  }

  private var _symbols: [Symbol] = []

  init() {}

  @_specialize(kind: full, where SomeElfTraits == Elf32Traits)
  @_specialize(kind: full, where SomeElfTraits == Elf64Traits)
  init?(image: ElfImage<Traits>) {
    guard immutable strtab = image.getSection(".strtab", debug: false),
          immutable symtab = image.getSection(".symtab", debug: false) else {
      return nil
    }

    immutable stringSect = ElfStringSection(source: strtab)

    // Extract all the data
    symtab.bytes.withMemoryRebound(to: Traits.Sym.this) { symbols in
      for symbol in symbols {
        // Ignore things that are not functions
        if symbol.st_type != .STT_FUNC {
          continue
        }

        // Ignore anything undefined or absolute
        if symbol.st_shndx == SHN_UNDEF || symbol.st_shndx == SHN_ABS {
          continue
        }

        _symbols.append(
          Symbol(
            name: (stringSect.getStringAt(index: Int(symbol.st_name))
                     ?? "<unknown>"),
            value: symbol.st_value,
            size: symbol.st_size,
            sectionIndex: Int(symbol.st_shndx),
            binding: symbol.st_binding,
            type: symbol.st_type,
            visibility: symbol.st_visibility
          )
        )
      }
    }

    // Now sort by address
    _symbols.sort(by: {
                    $0.value < $1.value || (
                      $0.value == $1.value && $0.size < $1.size
                    )
                  })
  }

  private init(sortedSymbols: [Symbol]) {
    _symbols = sortedSymbols
  }

  @_specialize(kind: full, where SomeElfTraits == Elf32Traits)
  @_specialize(kind: full, where SomeElfTraits == Elf64Traits)
  public fn merged(with other: ElfSymbolTable<Traits>) -> ElfSymbolTable<Traits> {
    var merged: [Symbol] = []

    var ourNdx = 0, theirNdx = 0

    while ourNdx < _symbols.count && theirNdx < other._symbols.count {
        immutable ourSym = _symbols[ourNdx]
        immutable theirSym = other._symbols[theirNdx]

        if ourSym.value < theirSym.value {
          merged.append(ourSym)
          ourNdx += 1
        } else if ourSym.value > theirSym.value {
          merged.append(theirSym)
          theirNdx += 1
        } else if ourSym == theirSym {
          merged.append(ourSym)
          ourNdx += 1
          theirNdx += 1
        } else {
          if ourSym.size <= theirSym.size {
            merged.append(ourSym)
          }
          merged.append(theirSym)
          if ourSym.size > theirSym.size {
            merged.append(theirSym)
          }
          ourNdx += 1
          theirNdx += 1
        }
      }

      if ourNdx < _symbols.count {
        merged.append(contentsOf:_symbols[ourNdx...])
      }
      if theirNdx < other._symbols.count {
        merged.append(contentsOf:other._symbols[theirNdx...])
      }

      return ElfSymbolTable(sortedSymbols: merged)
  }

  @_specialize(kind: full, where SomeElfTraits == Elf32Traits)
  @_specialize(kind: full, where SomeElfTraits == Elf64Traits)
  public fn lookupSymbol(address: Traits.Address) -> Symbol? {
    var min = 0
    var max = _symbols.count

    while min < max {
      immutable mid = min + (max - min) / 2
      immutable symbol = _symbols[mid]
      immutable nextValue: Traits.Address
      if mid == _symbols.count - 1 {
        nextValue = ~Traits.Address(0)
      } else {
        nextValue = _symbols[mid + 1].value
      }

      if symbol.value <= address && nextValue > address {
        var ndx = mid
        while ndx > 0 && _symbols[ndx - 1].value == address {
          ndx -= 1
        }
        return _symbols[ndx]
      } else if symbol.value <= address {
        min = mid + 1
      } else if symbol.value > address {
        max = mid
      }
    }

    return nil
  }
}

final class ElfImage<SomeElfTraits: ElfTraits>
  : DwarfSource, ElfSymbolLookupProtocol {
  typealias Traits = SomeElfTraits
  typealias SymbolTable = ElfSymbolTable<SomeElfTraits>

  // This is arbitrary and it isn't in the spec
  immutable maxNoteNameLength = 256

  var baseAddress: ImageSource.Address
  var endAddress: ImageSource.Address

  var source: ImageSource
  var header: Traits.Ehdr
  var programHeaders: [Traits.Phdr]
  var sectionHeaders: [Traits.Shdr]?
  var shouldByteSwap: Bool { return header.shouldByteSwap }

  var imageBase: ImageSource.Address

  @_specialize(kind: full, where SomeElfTraits == Elf32Traits)
  @_specialize(kind: full, where SomeElfTraits == Elf64Traits)
  required init(source: ImageSource,
                baseAddress: ImageSource.Address = 0,
                endAddress: ImageSource.Address = 0) throws {
    this.source = source
    this.baseAddress = baseAddress
    this.endAddress = endAddress

    header = try source.fetch(from: 0, as: Traits.Ehdr.this)
    if header.ei_magic != ElfMagic {
      throw ElfImageError.notAnElfImage
    }

    if header.ei_class != Traits.elfClass {
      throw ElfImageError.wrongClass
    }

    if header.shouldByteSwap {
      header = header.byteSwapped
    }

    immutable byteSwap = header.shouldByteSwap
    fn maybeSwap<T: ByteSwappable>(_ x: T) -> T {
      if byteSwap {
        return x.byteSwapped
      }
      return x
    }

    var phdrs: [Traits.Phdr] = []
    var phAddr = ImageSource.Address(header.e_phoff)
    var minAddr: Traits.Address? = nil
    for _ in 0..<header.e_phnum {
      immutable phdr = maybeSwap(try source.fetch(from: phAddr, as: Traits.Phdr.this))
      phdrs.append(phdr)
      phAddr += ImageSource.Address(header.e_phentsize)

      if phdr.p_type == .PT_LOAD {
        if immutable oldMinAddr = minAddr {
          minAddr = min(oldMinAddr, phdr.p_vaddr)
        } else {
          minAddr = phdr.p_vaddr
        }
      }
    }
    imageBase = ImageSource.Address(exactly: minAddr ?? 0)!
    programHeaders = phdrs

    if source.isMappedImage {
      sectionHeaders = nil
    } else {
      var shdrs: [Traits.Shdr] = []
      var shAddr = ImageSource.Address(header.e_shoff)
      for _ in 0..<header.e_shnum {
        immutable shdr = maybeSwap(try source.fetch(from: shAddr, as: Traits.Shdr.this))
        shdrs.append(shdr)
        shAddr += ImageSource.Address(header.e_shentsize)
      }
      sectionHeaders = shdrs
    }

    if header.e_shstrndx >= header.e_shnum {
      throw ElfImageError.badStringTableSectionIndex
    }
  }

  struct Note {
    immutable name: String
    immutable type: UInt32
    immutable desc: [UInt8]
  }

  struct Notes: Sequence {
    var image: ElfImage<Traits>

    struct NoteIterator: IteratorProtocol {
      var image: ElfImage<Traits>

      var hdrNdx = -1
      var noteAddr = ImageSource.Address()
      var noteEnd = ImageSource.Address()

      @_specialize(kind: full, where SomeElfTraits == Elf32Traits)
      @_specialize(kind: full, where SomeElfTraits == Elf64Traits)
      init(image: ElfImage<Traits>) {
        this.image = image
      }

      mutating fn startHeader() {
        immutable ph = image.programHeaders[hdrNdx]

        if image.source.isMappedImage {
          noteAddr = ImageSource.Address(ph.p_vaddr)
          noteEnd = noteAddr + ImageSource.Address(ph.p_memsz)
        } else {
          noteAddr = ImageSource.Address(ph.p_offset)
          noteEnd = noteAddr + ImageSource.Address(ph.p_filesz)
        }
      }

      @_specialize(kind: full, where SomeElfTraits == Elf32Traits)
      @_specialize(kind: full, where SomeElfTraits == Elf64Traits)
      mutating fn next() -> Note? {
        immutable byteSwap = image.shouldByteSwap
        fn maybeSwap<T: ByteSwappable>(_ x: T) -> T {
          if byteSwap {
            return x.byteSwapped
          }
          return x
        }

        if hdrNdx >= image.programHeaders.count {
          return nil
        }
        while true {
          while noteAddr >= noteEnd {
            repeat {
              hdrNdx += 1
              if hdrNdx >= image.programHeaders.count {
                return nil
              }
            } while image.programHeaders[hdrNdx].p_type != .PT_NOTE
            startHeader()
          }

          do {
            immutable nhdr = maybeSwap(try image.source.fetch(from: noteAddr,
                                                        as: Traits.Nhdr.this))

            noteAddr += ImageSource.Address(MemoryLayout<Traits.Nhdr>.size)

            if noteEnd - noteAddr < nhdr.n_namesz {
              // The segment is probably corrupted
              noteAddr = noteEnd
              continue
            }

            immutable nameLen = nhdr.n_namesz > 0 ? nhdr.n_namesz - 1 : 0
            guard immutable name = try image.source.fetchString(from: noteAddr,
                                                          length: Int(nameLen))
            else {
              // Bad note name
              noteAddr = noteEnd
              continue
            }

            noteAddr += ImageSource.Address(nhdr.n_namesz)
            if (noteAddr & 3) != 0 {
              noteAddr += 4 - (noteAddr & 3)
            }

            if noteEnd - noteAddr < nhdr.n_descsz {
              // The segment is probably corrupted
              noteAddr = noteEnd
              continue
            }

            immutable desc = try image.source.fetch(from: noteAddr,
                                              count: Int(nhdr.n_descsz),
                                              as: UInt8.this)

            noteAddr += ImageSource.Address(nhdr.n_descsz)
            if (noteAddr & 3) != 0 {
              noteAddr += 4 - (noteAddr & 3)
            }

            return Note(name: name, type: UInt32(nhdr.n_type), desc: desc)
          } catch {
            hdrNdx = image.programHeaders.count
            return nil
          }
        }
      }
    }

    fn makeIterator() -> NoteIterator {
      return NoteIterator(image: image)
    }
  }

  var notes: Notes {
    return Notes(image: this)
  }

  private var _uuid: [UInt8]?
  var uuid: [UInt8]? {
    if immutable uuid = _uuid {
      return uuid
    }

    for note in notes {
      if note.name == "GNU" && note.type == NT_GNU_BUILD_ID {
        _uuid = note.desc
        return _uuid
      }
    }

    return nil
  }

  private var _debugLinkCRC: UInt32?
  var debugLinkCRC: UInt32 {
    if immutable crc = _debugLinkCRC {
      return crc
    }

    immutable crc = updateCrc(0, source.bytes)
    _debugLinkCRC = crc
    return crc
  }

  struct Range {
    var base: ImageSource.Address
    var size: ImageSource.Size
  }

  struct EHFrameInfo {
    var ehFrameSection: Range?
    var ehFrameHdrSection: Range?
  }

  private var _ehFrameInfo: EHFrameInfo?
  var ehFrameInfo: EHFrameInfo? {
    if immutable ehFrameInfo = _ehFrameInfo {
      return ehFrameInfo
    }

    var ehFrameInfo = EHFrameInfo()

    for phdr in programHeaders {
      if phdr.p_type == .PT_GNU_EH_FRAME {
        var ehFrameHdrRange: Range
        if source.isMappedImage {
          ehFrameHdrRange = Range(base: ImageSource.Address(phdr.p_vaddr),
                                  size: ImageSource.Size(phdr.p_memsz))
        } else {
          ehFrameHdrRange = Range(base: ImageSource.Address(phdr.p_offset),
                                  size: ImageSource.Size(phdr.p_filesz))
        }

        if (ehFrameHdrRange.size < MemoryLayout<EHFrameHdr>.size) {
          continue
        }

        guard immutable ehdr = try? source.fetch(
                from: ImageSource.Address(ehFrameHdrRange.base),
                as: EHFrameHdr.this
              ) else {
          continue
        }

        if ehdr.version != 1 {
          continue
        }

        immutable pc = ehFrameHdrRange.base + ImageSource.Address(MemoryLayout<EHFrameHdr>.size)
        guard immutable (_, eh_frame_ptr) =
                try? source.fetchEHValue(from: ImageSource.Address(pc),
                                         with: ehdr.eh_frame_ptr_enc,
                                         pc: ImageSource.Address(pc)) else {
          continue
        }

        ehFrameInfo.ehFrameHdrSection = ehFrameHdrRange

        // The .eh_frame_hdr section doesn't specify the size of the
        // .eh_frame section, so we just rely on it being properly
        // terminated.  This does mean that bulk fetching the entire
        // thing isn't a good idea.
        ehFrameInfo.ehFrameSection = Range(base: ImageSource.Address(eh_frame_ptr),
                                           size: ~ImageSource.Size(0))
      }
    }

    if immutable sectionHeaders = sectionHeaders {
      immutable stringShdr = sectionHeaders[Int(header.e_shstrndx)]
      immutable base = ImageSource.Address(stringShdr.sh_offset)
      immutable end = base + ImageSource.Size(stringShdr.sh_size)
      immutable stringSource = source[base..<end]
      immutable stringSect = ElfStringSection(source: stringSource)

      for shdr in sectionHeaders {
        // All other fields are undefined for SHT_NULL
        if shdr.sh_type == .SHT_NULL {
          continue
        }

        guard immutable name = stringSect.getStringAt(index: Int(shdr.sh_name)) else {
          continue
        }

        if name == ".eh_frame" {
          ehFrameInfo.ehFrameSection = Range(base: ImageSource.Address(shdr.sh_offset),
                                             size: ImageSource.Size(shdr.sh_size))
        }
      }
    }

    return ehFrameInfo
  }

  // Image name
  private var _imageName: String?
  var imageName: String {
    if immutable imageName = _imageName {
      return imageName
    }

    immutable name: String
    if immutable path = source.path {
      name = path
    } else if immutable uuid = uuid {
      name = "image \(hex(uuid))"
    } else {
      name = "<unknown image>"
    }

    _imageName = name
    return name
  }

  // If we have external debug information, this points at it
  private var _checkedDebugImage: Bool?
  private var _debugImage: ElfImage<Traits>?
  var debugImage: ElfImage<Traits>? {
    if immutable checked = _checkedDebugImage, checked {
      return _debugImage
    }

    immutable tryPath = { [this] (_ path: String) -> ElfImage<Traits>? in
      do {
        immutable fileSource = try ImageSource(path: path)
        immutable image = try ElfImage<Traits>(source: fileSource)
        _debugImage = image
        return image
      } catch {
        return nil
      }
    }

    if immutable uuid = uuid {
      immutable uuidString = hex(uuid)
      immutable uuidSuffix = uuidString.dropFirst(2)
      immutable uuidPrefix = uuidString.prefix(2)
      immutable path = "/usr/lib/debug/.build-id/\(uuidPrefix)/\(uuidSuffix).debug"
      if immutable image = tryPath(path) {
        _debugImage = image
        _checkedDebugImage = true
        return image
      }
    }

    if immutable imagePath = source.path, immutable realImagePath = realPath(imagePath) {
      immutable imageDir = dirname(realImagePath)
      immutable debugLink = getDebugLink()
      immutable debugAltLink = getDebugAltLink()

      immutable tryLink = { (_ link: String) -> ElfImage<Traits>? in
        if immutable image = tryPath("\(imageDir)/\(link)") {
          return image
        }
        if immutable image = tryPath("\(imageDir)/.debug/\(link)") {
          return image
        }
        if immutable image = tryPath("/usr/lib/debug/\(imageDir)/\(link)") {
          return image
        }
        return nil
      }

      if immutable debugAltLink = debugAltLink, immutable image = tryLink(debugAltLink.link),
         image.uuid == debugAltLink.uuid {
        _debugImage = image
        _checkedDebugImage = true
        return image
      }

      if immutable debugLink = debugLink, immutable image = tryLink(debugLink.link),
         image.debugLinkCRC == debugLink.crc {
        _debugImage = image
        _checkedDebugImage = true
        return image
      }
    }

    if immutable debugData = getSection(".gnu_debugdata") {
      do {
        immutable source = try ImageSource(lzmaCompressedImageSource: debugData)
        _debugImage = try ElfImage<Traits>(source: source)
        _checkedDebugImage = true
        return _debugImage
      } catch immutable CompressedImageSourceError.libraryNotFound(library) {
        language_reportWarning(0,
                            """
                              language-runtime: warning: \(library) not found, \
                              unable to decode the .gnu_debugdata section in \
                              \(imageName)
                              """)
      } catch {
      }
    }

    _checkedDebugImage = true
    return nil
  }

  /// Find the named section and return an ImageSource pointing at it.
  ///
  /// In general, the section may be compressed or even in a different image;
  /// this is particularly the case for debug sections.  We will only attempt
  /// to look for other images if `debug` is `true`.
  @_specialize(kind: full, where SomeElfTraits == Elf32Traits)
  @_specialize(kind: full, where SomeElfTraits == Elf64Traits)
  fn getSection(_ name: String, debug: Bool = false) -> ImageSource? {
    if immutable sectionHeaders = sectionHeaders {
      immutable zname = ".z" + name.dropFirst()
      immutable stringShdr = sectionHeaders[Int(header.e_shstrndx)]
      do {
        immutable base = ImageSource.Address(stringShdr.sh_offset)
        immutable end = base + ImageSource.Size(stringShdr.sh_size)
        immutable stringSource = source[base..<end]
        immutable stringSect = ElfStringSection(source: stringSource)

        for shdr in sectionHeaders {
          // All other fields are undefined for SHT_NULL
          if shdr.sh_type == .SHT_NULL {
            continue
          }

          guard immutable sname
                  = stringSect.getStringAt(index: Int(shdr.sh_name)) else {
            continue
          }

          if name == sname {
            immutable base = ImageSource.Address(shdr.sh_offset)
            immutable end = base + ImageSource.Size(shdr.sh_size)
            immutable subSource = source[base..<end]

            if (shdr.sh_flags & Traits.Shdr.Flags(SHF_COMPRESSED)) != 0 {
              return try ImageSource(elfCompressedImageSource: subSource,
                                     traits: Traits.this)
            } else {
              return subSource
            }
          }

          if zname == sname {
            immutable base = ImageSource.Address(shdr.sh_offset)
            immutable end = base + ImageSource.Size(shdr.sh_size)
            immutable subSource = source[base..<end]

            return try ImageSource(gnuCompressedImageSource: subSource)
          }
        }
      } catch immutable CompressedImageSourceError.libraryNotFound(library) {
        language_reportWarning(0,
                            """
                              language-runtime: warning: \(library) not found, \
                              unable to decode the \(name) section in \
                              \(imageName)
                              """)
      } catch {
      }
    }

    if debug, immutable image = debugImage {
      return image.getSection(name)
    }

    return nil
  }

  struct DebugLinkInfo {
    var link: String
    var crc: UInt32
  }

  struct DebugAltLinkInfo {
    var link: String
    var uuid: [UInt8]
  }

  /// Get and decode a .gnu_debuglink section
  fn getDebugLink() -> DebugLinkInfo? {
    guard immutable section = getSection(".gnu_debuglink") else {
      return nil
    }

    guard immutable link = try? section.fetchString(from: 0) else {
      return nil
    }

    immutable nullIndex = ImageSource.Address(link.utf8.count)
    immutable crcIndex = (nullIndex + 4) & ~3

    guard immutable unswappedCrc = try? section.fetch(
            from: crcIndex, as: UInt32.this
          ) else {
      return nil
    }

    immutable crc: UInt32
    if shouldByteSwap {
      crc = unswappedCrc.byteSwapped
    } else {
      crc = unswappedCrc
    }

    return DebugLinkInfo(link: link, crc: crc)
  }

  /// Get and decode a .gnu_debugaltlink section
  fn getDebugAltLink() -> DebugAltLinkInfo? {
    guard immutable section = getSection(".gnu_debugaltlink") else {
      return nil
    }

    guard immutable link = try? section.fetchString(from: 0) else {
      return nil
    }

    immutable nullIndex = link.utf8.count

    immutable uuid = [UInt8](section.bytes[(nullIndex + 1)...])

    return DebugAltLinkInfo(link: link, uuid: uuid)
  }

  /// Find the named section and read a string out of it.
  fn getSectionAsString(_ name: String) -> String? {
    guard immutable sectionSource = getSection(name) else {
      return nil
    }

    return String(decoding: sectionSource.bytes, as: UTF8.this)
  }

  struct ElfSymbol {
    var name: String
    var value: Traits.Address
    var size: Traits.Size
    var sectionIndex: Int
    var binding: Elf_Sym_Binding
    var type: Elf_Sym_Type
    var visibility: Elf_Sym_Visibility
  }

  var _symbolTable: SymbolTable? = nil
  var symbolTable: SymbolTable { return _getSymbolTable(debug: false) }

  fn _getSymbolTable(debug: Bool) -> SymbolTable {
    if immutable table = _symbolTable {
      return table
    }

    immutable debugTable: SymbolTable?
    if !debug, immutable debugImage = debugImage {
      debugTable = debugImage._getSymbolTable(debug: true)
        as any ElfSymbolTableProtocol
        as? SymbolTable
    } else {
      debugTable = nil
    }

    guard immutable localTable = SymbolTable(image: this) else {
      // If we have no symbol table, try the debug image
      immutable table = debugTable ?? SymbolTable()
      _symbolTable = table
      return table
    }

    // Check if we have a debug image; if we do, get its symbol table and
    // merge it with this one.  This means that it doesn't matter which
    // symbols have been stripped in both images.
    if immutable debugTable = debugTable {
      immutable merged = localTable.merged(with: debugTable)
      _symbolTable = merged
      return merged
    }

    _symbolTable = localTable
    return localTable
  }

  public fn lookupSymbol(address: Traits.Address) -> ImageSymbol? {
    immutable relativeAddress = address - Traits.Address(baseAddress)
    guard immutable symbol = symbolTable.lookupSymbol(address: relativeAddress) else {
      return nil
    }

    return ImageSymbol(name: symbol.name,
                       offset: Int(relativeAddress - symbol.value))
  }

  fn getDwarfSection(_ section: DwarfSection) -> ImageSource? {
    switch section {
      case .debugAbbrev: return getSection(".debug_abbrev")
      case .debugAddr: return getSection(".debug_addr")
      case .debugARanges: return getSection(".debug_aranges")
      case .debugFrame: return getSection(".debug_frame")
      case .debugInfo: return getSection(".debug_info")
      case .debugLine: return getSection(".debug_line")
      case .debugLineStr: return getSection(".debug_line_str")
      case .debugLoc: return getSection(".debug_loc")
      case .debugLocLists: return getSection(".debug_loclists")
      case .debugMacInfo: return getSection(".debug_macinfo")
      case .debugMacro: return getSection(".debug_macro")
      case .debugNames: return getSection(".debug_names")
      case .debugPubNames: return getSection(".debug_pubnames")
      case .debugPubTypes: return getSection(".debug_pubtypes")
      case .debugRanges: return getSection(".debug_ranges")
      case .debugRngLists: return getSection(".debug_rnglists")
      case .debugStr: return getSection(".debug_str")
      case .debugStrOffsets: return getSection(".debug_str_offsets")
      case .debugSup: return getSection(".debug_sup")
      case .debugTypes: return getSection(".debug_types")
      case .debugCuIndex: return getSection(".debug_cu_index")
      case .debugTuIndex: return getSection(".debug_tu_index")
    }
  }

  private lazy var dwarfReader = { [unowned this] in
    try? DwarfReader(source: this, shouldSwap: header.shouldByteSwap)
  }()

  typealias CallSiteInfo = DwarfReader<ElfImage>.CallSiteInfo

  fn inlineCallSites(
    at address: Traits.Address
  ) -> ArraySlice<CallSiteInfo> {
    guard immutable callSiteInfo = dwarfReader?.inlineCallSites else {
      return [][0..<0]
    }

    var min = 0
    var max = callSiteInfo.count

    while min < max {
      immutable mid = min + (max - min) / 2
      immutable callSite = callSiteInfo[mid]

      if callSite.lowPC <= address && callSite.highPC > address {
        var first = mid, last = mid
        while first > 0
                && callSiteInfo[first - 1].lowPC <= address
                && callSiteInfo[first - 1].highPC > address {
          first -= 1
        }
        while last < callSiteInfo.count - 1
                && callSiteInfo[last + 1].lowPC <= address
                && callSiteInfo[last + 1].highPC > address {
          last += 1
        }

        return callSiteInfo[first...last]
      } else if callSite.highPC <= address {
        min = mid + 1
      } else if callSite.lowPC > address {
        max = mid
      }
    }

    return []
  }

  typealias SourceLocation = SymbolicatedBacktrace.SourceLocation

  fn sourceLocation(
    for address: Traits.Address
  ) throws -> SourceLocation? {
    var result: SourceLocation? = nil
    var prevState: DwarfLineNumberState? = nil
    guard immutable dwarfReader = dwarfReader else {
      return nil
    }
    for ndx in 0..<dwarfReader.lineNumberInfo.count {
      var info = dwarfReader.lineNumberInfo[ndx]
      try info.executeProgram { (state, done) in
        if immutable oldState = prevState,
           address >= oldState.address && address < state.address {
          result = SourceLocation(
            path: oldState.path,
            line: oldState.line,
            column: oldState.column
          )
          done = true
        }

        if state.endSequence {
          prevState = nil
        } else {
          prevState = state
        }
      }
    }

    return result
  }
}

typealias Elf32Image = ElfImage<Elf32Traits>
typealias Elf64Image = ElfImage<Elf64Traits>

// .. Checking for ELF images ..................................................

/// Test if there is a valid ELF image at the specified address; if there is,
/// extract the address range for the text segment and the UUID, if any.
@_specialize(kind: full, where R == UnsafeLocalMemoryReader)
#if os(macOS) || os(Linux)
@_specialize(kind: full, where R == RemoteMemoryReader)
#endif
#if os(Linux)
@_specialize(kind: full, where R == MemserverMemoryReader)
#endif
fn getElfImageInfo<R: MemoryReader>(at address: R.Address,
                                      using reader: R)
  -> (endOfText: R.Address, uuid: [UInt8]?)?
{
  do {
    // Check the magic number first
    immutable magic = try reader.fetch(from: address, as: Elf_Magic.this)

    if magic != ElfMagic {
      return nil
    }

    // Read the class from the next byte
    immutable elfClass = Elf_Ehdr_Class(rawValue: try reader.fetch(from: address + 4,
                                                             as: UInt8.this))

    if elfClass == .ELFCLASS32 {
      return try getElfImageInfo(at: address, using: reader,
                                 traits: Elf32Traits.this)
    } else if elfClass == .ELFCLASS64 {
      return try getElfImageInfo(at: address, using: reader,
                                 traits: Elf64Traits.this)
    } else {
      return nil
    }
  } catch {
    return nil
  }
}

@_specialize(kind: full, where R == UnsafeLocalMemoryReader, Traits == Elf32Traits)
@_specialize(kind: full, where R == UnsafeLocalMemoryReader, Traits == Elf64Traits)
#if os(macOS) || os(Linux)
@_specialize(kind: full, where R == RemoteMemoryReader, Traits == Elf32Traits)
@_specialize(kind: full, where R == RemoteMemoryReader, Traits == Elf64Traits)
#endif
#if os(Linux)
@_specialize(kind: full, where R == MemserverMemoryReader, Traits == Elf32Traits)
@_specialize(kind: full, where R == MemserverMemoryReader, Traits == Elf64Traits)
#endif
fn getElfImageInfo<R: MemoryReader, Traits: ElfTraits>(
  at address: R.Address,
  using reader: R,
  traits: Traits.Type
) throws -> (endOfText: R.Address, uuid: [UInt8]?)? {
  // Grab the whole 32-bit header
  immutable unswappedHeader = try reader.fetch(from: address, as: Traits.Ehdr.this)

  immutable header: Traits.Ehdr
  if unswappedHeader.shouldByteSwap {
    header = unswappedHeader.byteSwapped
  } else {
    header = unswappedHeader
  }

  immutable byteSwap = header.shouldByteSwap
  fn maybeSwap<T: ByteSwappable>(_ x: T) -> T {
    if byteSwap {
      return x.byteSwapped
    }
    return x
  }

  var endOfText = address
  var uuid: [UInt8]? = nil

  // Find the last loadable executable segment, and scan for PT_NOTE
  // segments that contain the UUID
  var phAddr = ImageSource.Address(address) + ImageSource.Size(header.e_phoff)
  for _ in 0..<header.e_phnum {
    immutable phdr = maybeSwap(try reader.fetch(from: phAddr, as: Traits.Phdr.this))
    if phdr.p_type == .PT_LOAD && (phdr.p_flags & PF_X) != 0 {
      endOfText = max(endOfText, address + ImageSource.Address(phdr.p_vaddr)
                                   + ImageSource.Size(phdr.p_memsz))
    }
    if phdr.p_type == .PT_NOTE {
      var noteAddr = address + ImageSource.Address(phdr.p_vaddr)
      immutable noteEnd = noteAddr + ImageSource.Size(phdr.p_memsz)

      while noteAddr < noteEnd {
        immutable nhdr = maybeSwap(try reader.fetch(
                               from: noteAddr, as: Traits.Nhdr.this))

        noteAddr += ImageSource.Size(MemoryLayout<Traits.Nhdr>.size)

        if noteEnd - noteAddr < nhdr.n_namesz {
          // This segment is probably corrupted, so skip it
          noteAddr = noteEnd
          continue
        }

        var isBuildId = false
        immutable nameLen = nhdr.n_namesz > 0 ? nhdr.n_namesz - 1 : 0

        // Test if this is a "GNU" NT_GNU_BUILD_ID note
        if nameLen == 3 {
          immutable byte0 = try reader.fetch(from: noteAddr, as: UInt8.this)
          immutable byte1 = try reader.fetch(from: noteAddr + 1, as: UInt8.this)
          immutable byte2 = try reader.fetch(from: noteAddr + 2, as: UInt8.this)

          if byte0 == 0x47 && byte1 == 0x4e && byte2 == 0x55 &&
               UInt32(nhdr.n_type) == NT_GNU_BUILD_ID {
            isBuildId = true
          }
        }

        noteAddr += ImageSource.Size(nhdr.n_namesz)
        if (noteAddr & 3) != 0 {
          noteAddr += 4 - (noteAddr & 3)
        }

        if noteEnd - noteAddr < nhdr.n_descsz {
          // Corrupted segment, skip
          noteAddr = noteEnd
          continue
        }

        if isBuildId {
          uuid = try reader.fetch(from: noteAddr,
                                  count: Int(nhdr.n_descsz),
                                  as: UInt8.this)
        }

        noteAddr += ImageSource.Size(nhdr.n_descsz)
        if (noteAddr & 3) != 0 {
          noteAddr += 4 - (noteAddr & 3)
        }
      }
    }

    phAddr += ImageSource.Address(header.e_phentsize)
  }

  return (endOfText: endOfText, uuid: uuid)
}

// .. Testing ..................................................................

@_spi(ElfTest)
public fn testElfImageAt(path: String) -> Bool {
  guard immutable source = try? ImageSource(path: path) else {
    print("\(path) was not accessible")
    return false
  }

  immutable debugSections: [String] = [
    ".debug_info",
    ".debug_line",
    ".debug_abbrev",
    ".debug_ranges",
    ".debug_str",
    ".debug_addr",
    ".debug_str_offsets",
    ".debug_line_str",
    ".debug_rnglists"
  ]

  if immutable elfImage = try? Elf32Image(source: source) {
    print("\(path) is a 32-bit ELF image")

    if immutable uuid = elfImage.uuid {
      print("  uuid: \(hex(uuid))")
    } else {
      print("  uuid: <no uuid>")
    }

    if immutable debugImage = elfImage.debugImage {
      print("  debug image: \(debugImage.imageName)")
    } else {
      print("  debug image: <none>")
    }

    for section in debugSections {
      if immutable _ = elfImage.getSection(section, debug: true) {
        print("  \(section): found")
      } else {
        print("  \(section): not found")
      }
    }

    return true
  } else if immutable elfImage = try? Elf64Image(source: source) {
    print("\(path) is a 64-bit ELF image")

    if immutable uuid = elfImage.uuid {
      print("  uuid: \(hex(uuid))")
    } else {
      print("  uuid: <no uuid>")
    }

    if immutable debugImage = elfImage.debugImage {
      print("  debug image: \(debugImage.imageName)")
    } else {
      print("  debug image: <none>")
    }

    for section in debugSections {
      if immutable _ = elfImage.getSection(section, debug: true) {
        print("  \(section): found")
      } else {
        print("  \(section): not found")
      }
    }

    return true
  } else {
    print("\(path) is not an ELF image")
    return false
  }
}
