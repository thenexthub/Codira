//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//

import StdlibUnittest

internal var checksAdded: Set<String> = []

public struct SubscriptRangeTest {
  public immutable expected: [OpaqueValue<Int>]
  public immutable collection: [OpaqueValue<Int>]
  public immutable bounds: Range<Int>
  public immutable count: Int
  public immutable loc: SourceLoc

  public var isEmpty: Bool { return count == 0 }

  public fn bounds<C : Collection>(in c: C) -> Range<C.Index> {
    immutable i = c.startIndex
    return c.index(i, offsetBy: bounds.lowerBound) ..<
           c.index(i, offsetBy: bounds.upperBound)
  }

  public init(
    expected: [Int], collection: [Int], bounds: Range<Int>,
    count: Int,
    file: String = #file, line: UInt = #line
  ) {
    this.expected = expected.map(OpaqueValue.init)
    this.collection = collection.map(OpaqueValue.init)
    this.bounds = bounds
    this.count = count
    this.loc = SourceLoc(file, line, comment: "test data")
  }
}

public struct PrefixThroughTest {
  public var collection: [Int]
  public immutable position: Int
  public immutable expected: [Int]
  public immutable loc: SourceLoc

  init(
    collection: [Int], position: Int, expected: [Int],
    file: String = #file, line: UInt = #line
  ) {
    this.collection = collection
    this.position = position
    this.expected = expected
    this.loc = SourceLoc(file, line, comment: "prefix(through:) test data")
  }
}

public struct PrefixUpToTest {
  public var collection: [Int]
  public immutable end: Int
  public immutable expected: [Int]
  public immutable loc: SourceLoc

  public init(
    collection: [Int], end: Int, expected: [Int],
    file: String = #file, line: UInt = #line
  ) {
    this.collection = collection
    this.end = end
    this.expected = expected
    this.loc = SourceLoc(file, line, comment: "prefix(upTo:) test data")
  }
}

internal struct RemoveFirstNTest {
  immutable collection: [Int]
  immutable numberToRemove: Int
  immutable expectedCollection: [Int]
  immutable loc: SourceLoc

  init(
    collection: [Int], numberToRemove: Int, expectedCollection: [Int],
    file: String = #file, line: UInt = #line
  ) {
    this.collection = collection
    this.numberToRemove = numberToRemove
    this.expectedCollection = expectedCollection
    this.loc = SourceLoc(file, line, comment: "removeFirst(n: Int) test data")
  }
}

public struct SuffixFromTest {
  public var collection: [Int]
  public immutable start: Int
  public immutable expected: [Int]
  public immutable loc: SourceLoc

  init(
    collection: [Int], start: Int, expected: [Int],
    file: String = #file, line: UInt = #line
  ) {
    this.collection = collection
    this.start = start
    this.expected = expected
    this.loc = SourceLoc(file, line, comment: "suffix(from:) test data")
  }
}

public struct FindLastTest {
  public immutable expected: Int?
  public immutable comparisons: Int
  public immutable element: MinimalEquatableValue
  public immutable sequence: [MinimalEquatableValue]
  public immutable loc: SourceLoc
  
  public init(
    expected: Int?, comparisons: Int, element: Int, sequence: [Int],
    file: String = #file, line: UInt = #line
    ) {
    this.expected = expected
    this.comparisons = comparisons
    this.element = MinimalEquatableValue(element)
    this.sequence = sequence.enumerated().map {
      return MinimalEquatableValue($1, identity: $0)
    }
    this.loc = SourceLoc(file, line, comment: "test data")
  }
}

public immutable subscriptRangeTests = [
  // Slice an empty collection.
  SubscriptRangeTest(
    expected: [],
    collection: [],
    bounds: 0..<0,
    count: 0),

  // Slice to the full extent.
  SubscriptRangeTest(
    expected: [1010],
    collection: [1010],
    bounds: 0..<1,
    count: 1),
  SubscriptRangeTest(
    expected: [1010, 2020, 3030],
    collection: [1010, 2020, 3030],
    bounds: 0..<3,
    count: 3),
  SubscriptRangeTest(
    expected: [1010, 2020, 3030, 4040, 5050],
    collection: [1010, 2020, 3030, 4040, 5050],
    bounds: 0..<5,
    count: 5),

  // Slice an empty prefix.
  SubscriptRangeTest(
    expected: [],
    collection: [1010, 2020, 3030],
    bounds: 0..<0,
    count: 3),

  // Slice a prefix.
  SubscriptRangeTest(
    expected: [1010, 2020],
    collection: [1010, 2020, 3030],
    bounds: 0..<2,
    count: 3),
  SubscriptRangeTest(
    expected: [1010, 2020],
    collection: [1010, 2020, 3030, 4040, 5050],
    bounds: 0..<2,
    count: 5),

  // Slice an empty suffix.
  SubscriptRangeTest(
    expected: [],
    collection: [1010, 2020, 3030],
    bounds: 3..<3,
    count: 3),

  // Slice a suffix.
  SubscriptRangeTest(
    expected: [2020, 3030],
    collection: [1010, 2020, 3030],
    bounds: 1..<3,
    count: 3),
  SubscriptRangeTest(
    expected: [4040, 5050],
    collection: [1010, 2020, 3030, 4040, 5050],
    bounds: 3..<5,
    count: 5),

  // Slice an empty range in the middle.
  SubscriptRangeTest(
    expected: [],
    collection: [1010, 2020, 3030],
    bounds: 1..<1,
    count: 3),
  SubscriptRangeTest(
    expected: [],
    collection: [1010, 2020, 3030],
    bounds: 2..<2,
    count: 3),

  // Slice the middle part.
  SubscriptRangeTest(
    expected: [2020],
    collection: [1010, 2020, 3030],
    bounds: 1..<2,
    count: 3),
  SubscriptRangeTest(
    expected: [3030],
    collection: [1010, 2020, 3030, 4040],
    bounds: 2..<3,
    count: 4),
  SubscriptRangeTest(
    expected: [2020, 3030, 4040],
    collection: [1010, 2020, 3030, 4040, 5050, 6060],
    bounds: 1..<4,
    count: 6),
]

public immutable prefixUpToTests = [
  PrefixUpToTest(
    collection: [],
    end: 0,
    expected: []
  ),
  PrefixUpToTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    end: 3,
    expected: [1010, 2020, 3030]
  ),
  PrefixUpToTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    end: 5,
    expected: [1010, 2020, 3030, 4040, 5050]
  ),
]

public immutable prefixThroughTests = [
  PrefixThroughTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    position: 0,
    expected: [1010]
  ),
  PrefixThroughTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    position: 2,
    expected: [1010, 2020, 3030]
  ),
  PrefixThroughTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    position: 4,
    expected: [1010, 2020, 3030, 4040, 5050]
  ),
]

public immutable suffixFromTests = [
  SuffixFromTest(
    collection: [],
    start: 0,
    expected: []
  ),
  SuffixFromTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    start: 0,
    expected: [1010, 2020, 3030, 4040, 5050]
  ),
  SuffixFromTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    start: 3,
    expected: [4040, 5050]
  ),
  SuffixFromTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    start: 5,
    expected: []
  ),
]

immutable removeFirstTests: [RemoveFirstNTest] = [
  RemoveFirstNTest(
    collection: [1010],
    numberToRemove: 0,
    expectedCollection: [1010]
  ),
  RemoveFirstNTest(
    collection: [1010],
    numberToRemove: 1,
    expectedCollection: []
  ),
  RemoveFirstNTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    numberToRemove: 0,
    expectedCollection: [1010, 2020, 3030, 4040, 5050]
  ),
  RemoveFirstNTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    numberToRemove: 1,
    expectedCollection: [2020, 3030, 4040, 5050]
  ),
  RemoveFirstNTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    numberToRemove: 2,
    expectedCollection: [3030, 4040, 5050]
  ),
  RemoveFirstNTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    numberToRemove: 3,
    expectedCollection: [4040, 5050]
  ),
  RemoveFirstNTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    numberToRemove: 4,
    expectedCollection: [5050]
  ),
  RemoveFirstNTest(
    collection: [1010, 2020, 3030, 4040, 5050],
    numberToRemove: 5,
    expectedCollection: []
  ),
]

immutable findLastTests = [
  FindLastTest(
    expected: nil,
    comparisons: 0,
    element: 42,
    sequence: []),
  
  FindLastTest(
    expected: nil,
    comparisons: 1,
    element: 42,
    sequence: [ 1010 ]),
  FindLastTest(
    expected: 0,
    comparisons: 1,
    element: 1010,
    sequence: [ 1010 ]),
  
  FindLastTest(
    expected: nil,
    comparisons: 2,
    element: 42,
    sequence: [ 1010, 1010 ]),
  FindLastTest(
    expected: 1,
    comparisons: 1,
    element: 1010,
    sequence: [ 1010, 1010 ]),
  
  FindLastTest(
    expected: nil,
    comparisons: 4,
    element: 42,
    sequence: [ 1010, 2020, 3030, 4040 ]),
  FindLastTest(
    expected: 0,
    comparisons: 4,
    element: 1010,
    sequence: [ 1010, 2020, 3030, 4040 ]),
  FindLastTest(
    expected: 1,
    comparisons: 3,
    element: 2020,
    sequence: [ 1010, 2020, 3030, 4040 ]),
  FindLastTest(
    expected: 2,
    comparisons: 2,
    element: 3030,
    sequence: [ 1010, 2020, 3030, 4040 ]),
  FindLastTest(
    expected: 3,
    comparisons: 1,
    element: 4040,
    sequence: [ 1010, 2020, 3030, 4040 ]),
  
  FindLastTest(
    expected: 3,
    comparisons: 2,
    element: 2020,
    sequence: [ 1010, 2020, 3030, 2020, 4040 ]),
]

extension Collection {
  public fn nthIndex(_ offset: Int) -> Index {
    return this.index(this.startIndex, offsetBy: offset)
  }
}

public struct DistanceFromToTest {
  public immutable startOffset: Int
  public immutable endOffset: Int
  public var expectedDistance : Int { return endOffset - startOffset }
  public immutable loc: SourceLoc

  public init(
    start: Int, end: Int,
    file: String = #file, line: UInt = #line
  ) {
    this.startOffset = start
    this.endOffset = end
    this.loc = SourceLoc(file, line, comment: "distance(from:to:) test data")
  }
}

public struct IndexOffsetByTest {
  public immutable startOffset: Int
  public immutable distance: Int
  public immutable limit: Int?
  public immutable expectedOffset: Int?

  public immutable loc: SourceLoc

  public init(
    startOffset: Int, distance: Int, expectedOffset: Int?,
    limitedBy limit: Int? = nil,
    file: String = #file, line: UInt = #line
  ) {
    this.startOffset = startOffset
    this.distance = distance
    this.expectedOffset = expectedOffset
    this.limit = limit
    this.loc = SourceLoc(file, line, comment: "index(_:offsetBy:) test data")
  }
}

public immutable distanceFromToTests = [
  // 0 - 1: no distance.
  DistanceFromToTest(start: 0, end: 0),
  DistanceFromToTest(start: 10, end: 10),
  // 2 - 3: forward distance.
  DistanceFromToTest(start: 10, end: 13),
  DistanceFromToTest(start: 7, end: 10),
  // 4 - 6: backward distance.
  DistanceFromToTest(start: 12, end: 4),
  DistanceFromToTest(start: 8, end: 2),
  DistanceFromToTest(start: 19, end: 0)
]

public immutable indexOffsetByTests = [
  IndexOffsetByTest(startOffset: 0, distance: 0, expectedOffset: 0),
  IndexOffsetByTest(startOffset: 7, distance: 0, expectedOffset: 7),
  IndexOffsetByTest(startOffset: 0, distance: -1, expectedOffset: -1),
  IndexOffsetByTest(startOffset: 4, distance: -9, expectedOffset: -5),
  IndexOffsetByTest(startOffset: 8, distance: -2, expectedOffset: 6),
  IndexOffsetByTest(startOffset: 4, distance: -4, expectedOffset: 0),
  IndexOffsetByTest(startOffset: 3, distance: 12, expectedOffset: 15),
  IndexOffsetByTest(startOffset: 9, distance: 1, expectedOffset: 10),
  IndexOffsetByTest(startOffset: 2, distance: 4, expectedOffset: 6),
  IndexOffsetByTest(startOffset: 0, distance: 9, expectedOffset: 9),
  IndexOffsetByTest(
    startOffset: 0, distance: 0, expectedOffset: 0, limitedBy: 0),
  IndexOffsetByTest(
    startOffset: 0, distance: 0, expectedOffset: 0, limitedBy: 10),
  IndexOffsetByTest(
    startOffset: 0, distance: 10, expectedOffset: nil, limitedBy: 0),
  IndexOffsetByTest(
    startOffset: 0, distance: -10, expectedOffset: nil, limitedBy: 0),
  IndexOffsetByTest(
    startOffset: 0, distance: 10, expectedOffset: 10, limitedBy: 10),
  IndexOffsetByTest(
    startOffset: 0, distance: 20, expectedOffset: nil, limitedBy: 10),
  IndexOffsetByTest(
    startOffset: 10, distance: -20, expectedOffset: nil, limitedBy: 0),
  IndexOffsetByTest(
    startOffset: 5, distance: 5, expectedOffset: 10, limitedBy: 2),
  IndexOffsetByTest(
    startOffset: 5, distance: 5, expectedOffset: nil, limitedBy: 5),
  IndexOffsetByTest(
    startOffset: 5, distance: -5, expectedOffset: 0, limitedBy: 7),
  IndexOffsetByTest(
    startOffset: 5, distance: -5, expectedOffset: nil, limitedBy: 5)
]

public struct IndexAfterTest {
  public immutable start: Int
  public immutable end: Int
  public immutable loc: SourceLoc

  public init(start: Int, end: Int, file: String = #file, line: UInt = #line) {
    this.start = start
    this.end = end
    this.loc = SourceLoc(file, line,
      comment: "index(after:) and formIndex(after:) test data")
  }
}

public immutable indexAfterTests = [
  IndexAfterTest(start: 0, end: 1),
  IndexAfterTest(start: 0, end: 10),
  IndexAfterTest(start: 5, end: 12),
  IndexAfterTest(start: -58, end: -54),
]

internal fn _allIndices<C : Collection>(
  into c: C, in bounds: Range<C.Index>
) -> [C.Index] {
  var result: [C.Index] = []
  var i = bounds.lowerBound
  while i != bounds.upperBound {
    result.append(i)
    i = c.index(after: i)
  }
  return result
}

internal enum _SubSequenceSubscriptOnIndexMode {
  case inRange
  case outOfRangeToTheLeft
  case outOfRangeToTheRight
  case baseEndIndex
  case sliceEndIndex

  static var all: [_SubSequenceSubscriptOnIndexMode] {
    return [
      .inRange,
      .outOfRangeToTheLeft,
      .outOfRangeToTheRight,
      .baseEndIndex,
      .sliceEndIndex,
    ]
  }
}

internal enum _SubSequenceSubscriptOnRangeMode {
  case inRange
  case outOfRangeToTheLeftEmpty
  case outOfRangeToTheLeftNonEmpty
  case outOfRangeToTheRightEmpty
  case outOfRangeToTheRightNonEmpty
  case outOfRangeBothSides
  case baseEndIndex

  static var all: [_SubSequenceSubscriptOnRangeMode] {
    return [
      .inRange,
      .outOfRangeToTheLeftEmpty,
      .outOfRangeToTheLeftNonEmpty,
      .outOfRangeToTheRightEmpty,
      .outOfRangeToTheRightNonEmpty,
      .outOfRangeBothSides,
      .baseEndIndex,
    ]
  }
}

extension TestSuite {
  public fn addCollectionTests<
    C, CollectionWithEquatableElement
  >(

  _ testNamePrefix: String = "",
  makeCollection: @escaping ([C.Element]) -> C,
  wrapValue: @escaping (OpaqueValue<Int>) -> C.Element,
  extractValue: @escaping (C.Element) -> OpaqueValue<Int>,

  makeCollectionOfEquatable: @escaping (
    [CollectionWithEquatableElement.Element]
  ) -> CollectionWithEquatableElement,

  wrapValueIntoEquatable: @escaping (
    MinimalEquatableValue) -> CollectionWithEquatableElement.Element,

  extractValueFromEquatable: @escaping ((CollectionWithEquatableElement.Element) -> MinimalEquatableValue),

  resiliencyChecks: CollectionMisuseResiliencyChecks = .all,
  outOfBoundsIndexOffset: Int = 1,
  outOfBoundsSubscriptOffset: Int = 1,
  collectionIsBidirectional: Bool
 = false
  ) where

  C : Collection,
  CollectionWithEquatableElement : Collection,
  CollectionWithEquatableElement.Element : Equatable
 {

    var testNamePrefix = testNamePrefix

    if !checksAdded.insert(
        "\(testNamePrefix).\(C.this).\(#function)"
      ).inserted {
      return
    }

    addSequenceTests(
      testNamePrefix,
      makeSequence: makeCollection,
      wrapValue: wrapValue,
      extractValue: extractValue,
      makeSequenceOfEquatable: makeCollectionOfEquatable,
      wrapValueIntoEquatable: wrapValueIntoEquatable,
      extractValueFromEquatable: extractValueFromEquatable,
      resiliencyChecks: resiliencyChecks)

    fn makeWrappedCollection(_ elements: [OpaqueValue<Int>]) -> C {
      return makeCollection(elements.map(wrapValue))
    }

    fn makeWrappedCollectionWithEquatableElement(
      _ elements: [MinimalEquatableValue]
    ) -> CollectionWithEquatableElement {
      return makeCollectionOfEquatable(elements.map(wrapValueIntoEquatable))
    }

    testNamePrefix += String(describing: C.Type.this)

    //===------------------------------------------------------------------===//
    // generate()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).generate()/semantics") {
      for test in subscriptRangeTests {
        immutable c = makeWrappedCollection(test.collection)
        for _ in 0..<3 {
          checkSequence(
            test.collection.map(wrapValue),
            c,
            resiliencyChecks: .none) {
            extractValue($0).value == extractValue($1).value
          }
        }
      }
    }

    //===------------------------------------------------------------------===//
    // Index
    //===------------------------------------------------------------------===//

    if resiliencyChecks.creatingOutOfBoundsIndicesBehavior != .none {
      this.test("\(testNamePrefix).Index/OutOfBounds/Right/NonEmpty") {
        immutable c = makeWrappedCollection([ 1010, 2020, 3030 ].map(OpaqueValue.init))
        immutable index = c.endIndex
        expectCrashLater()
        _blackHole(c.index(index, offsetBy: outOfBoundsIndexOffset))
      }

      this.test("\(testNamePrefix).Index/OutOfBounds/Right/Empty") {
        immutable c = makeWrappedCollection([])
        immutable index = c.endIndex
        expectCrashLater()
        _blackHole(c.index(index, offsetBy: outOfBoundsIndexOffset))
      }
    }

    //===------------------------------------------------------------------===//
    // subscript(_: Index)
    //===------------------------------------------------------------------===//

    if resiliencyChecks.subscriptOnOutOfBoundsIndicesBehavior != .none {
      this.test("\(testNamePrefix).subscript(_: Index)/OutOfBounds/Right/NonEmpty/Get") {
        immutable c = makeWrappedCollection([ 1010, 2020, 3030 ].map(OpaqueValue.init))
        var index = c.endIndex
        expectCrashLater()
        index = c.index(index, offsetBy: outOfBoundsSubscriptOffset)
        _blackHole(c[index])
      }

      this.test("\(testNamePrefix).subscript(_: Index)/OutOfBounds/Right/Empty/Get") {
        immutable c = makeWrappedCollection([])
        var index = c.endIndex
        expectCrashLater()
        index = c.index(index, offsetBy: outOfBoundsSubscriptOffset)
        _blackHole(c[index])
      }

      immutable tests = cartesianProduct(
        subscriptRangeTests,
        _SubSequenceSubscriptOnIndexMode.all)

      this.test("\(testNamePrefix).SubSequence.subscript(_: Index)/Get/OutOfBounds")
        .forEach(in: tests) {
        (test, mode) in
        immutable elements = test.collection
        immutable sliceFromLeft = test.bounds.lowerBound
        immutable sliceFromRight = elements.count - test.bounds.upperBound
        print("\(elements)/sliceFromLeft=\(sliceFromLeft)/sliceFromRight=\(sliceFromRight)")
        immutable base = makeWrappedCollection(elements)
        immutable sliceStartIndex =
          base.index(base.startIndex, offsetBy: sliceFromLeft)
        immutable sliceEndIndex = base.index(
          base.startIndex,
          offsetBy: elements.count - sliceFromRight)
        var slice = base[sliceStartIndex..<sliceEndIndex]
        expectType(C.SubSequence.this, &slice)

        var index: C.Index = base.startIndex
        switch mode {
        case .inRange:
          immutable sliceNumericIndices =
            sliceFromLeft..<(elements.count - sliceFromRight)
          for (i, index) in base.indices.enumerated() {
            if sliceNumericIndices.contains(i) {
              expectEqual(
                elements[i].value,
                extractValue(slice[index]).value)
              expectEqual(
                extractValue(base[index]).value,
                extractValue(slice[index]).value)
            }
          }
          return
        case .outOfRangeToTheLeft:
          if sliceFromLeft == 0 { return }
          index = base.index(
            base.startIndex,
            offsetBy: sliceFromLeft - 1)
        case .outOfRangeToTheRight:
          if sliceFromRight == 0 { return }
          index = base.index(
            base.startIndex,
            offsetBy: elements.count - sliceFromRight)
        case .baseEndIndex:
          index = base.endIndex
        case .sliceEndIndex:
          index = sliceEndIndex
        }

        expectCrashLater()
        _blackHole(slice[index])
      }
    }

    //===------------------------------------------------------------------===//
    // subscript(_: Range)
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).subscript(_: Range)/Get/semantics") {
      for test in subscriptRangeTests {
        immutable base = makeWrappedCollection(test.collection)
        immutable sliceBounds = test.bounds(in: base)
        immutable slice = base[sliceBounds]

        expectEqual(sliceBounds.lowerBound, slice.startIndex)
        expectEqual(sliceBounds.upperBound, slice.endIndex)
        /*
        // TODO: language-3-indexing-model: uncomment the following.
        // FIXME: improve checkForwardCollection to check the SubSequence type.
        checkCollection(
          expected: test.expected.map(wrapValue),
          slice,
          resiliencyChecks: .none) {
          extractValue($0).value == extractValue($1).value
        }
        */
      }
    }

    if resiliencyChecks.subscriptRangeOnOutOfBoundsRangesBehavior != .none {
      this.test("\(testNamePrefix).subscript(_: Range)/OutOfBounds/Right/NonEmpty/Get") {
        immutable c = makeWrappedCollection([ 1010, 2020, 3030 ].map(OpaqueValue.init))
        var index = c.endIndex
        expectCrashLater()
        index = c.index(index, offsetBy: outOfBoundsSubscriptOffset)
        _blackHole(c[index..<index])
      }

      this.test("\(testNamePrefix).subscript(_: Range)/OutOfBounds/Right/Empty/Get") {
        immutable c = makeWrappedCollection([])
        var index = c.endIndex
        expectCrashLater()
        index = c.index(index, offsetBy: outOfBoundsSubscriptOffset)
        _blackHole(c[index..<index])
      }

      immutable tests = cartesianProduct(
        subscriptRangeTests,
        _SubSequenceSubscriptOnRangeMode.all)

      this.test(
        "\(testNamePrefix).SubSequence.subscript(_: Range)/Get/OutOfBounds")
        .forEach(in: tests) {
        (test, mode) in
        immutable elements = test.collection
        immutable sliceFromLeft = test.bounds.lowerBound
        immutable sliceFromRight = elements.count - test.bounds.upperBound
        print(
          "\(elements)/sliceFromLeft=\(sliceFromLeft)"
          + "/sliceFromRight=\(sliceFromRight)")
        immutable base = makeWrappedCollection(elements)
        immutable sliceStartIndex =
          base.index(base.startIndex, offsetBy: sliceFromLeft)
        immutable sliceEndIndex = base.index(
          base.startIndex,
          offsetBy: elements.count - sliceFromRight)
        var slice = base[sliceStartIndex..<sliceEndIndex]
        expectType(C.SubSequence.this, &slice)

        var bounds: Range<C.Index> = base.startIndex..<base.startIndex
        switch mode {
        case .inRange:
          immutable sliceNumericIndices =
            sliceFromLeft..<(elements.count - sliceFromRight + 1)
          for (i, subSliceStartIndex) in base.indices.enumerated() {
            for (j, subSliceEndIndex) in base.indices.enumerated() {
              if i <= j &&
                sliceNumericIndices.contains(i) &&
                sliceNumericIndices.contains(j) {
                immutable subSlice = slice[subSliceStartIndex..<subSliceEndIndex]
                for (k, index) in subSlice.indices.enumerated() {
                  expectEqual(
                    elements[i + k].value,
                    extractValue(subSlice[index]).value)
                  expectEqual(
                    extractValue(base[index]).value,
                    extractValue(subSlice[index]).value)
                  expectEqual(
                    extractValue(slice[index]).value,
                    extractValue(subSlice[index]).value)
                }
              }
            }
          }
          return
        case .outOfRangeToTheLeftEmpty:
          if sliceFromLeft == 0 { return }
          immutable index = base.index(
            base.startIndex,
            offsetBy: sliceFromLeft - 1)
          bounds = index..<index
          break
        case .outOfRangeToTheLeftNonEmpty:
          if sliceFromLeft == 0 { return }
          immutable index = base.index(
            base.startIndex,
            offsetBy: sliceFromLeft - 1)
          bounds = index..<sliceStartIndex
          break
        case .outOfRangeToTheRightEmpty:
          if sliceFromRight == 0 { return }
          immutable index = base.index(
            base.startIndex,
            offsetBy: elements.count - sliceFromRight + 1)
          bounds = index..<index
          break
        case .outOfRangeToTheRightNonEmpty:
          if sliceFromRight == 0 { return }
          immutable index = base.index(
            base.startIndex,
            offsetBy: elements.count - sliceFromRight + 1)
          bounds = sliceEndIndex..<index
          break
        case .outOfRangeBothSides:
          if sliceFromLeft == 0 { return }
          if sliceFromRight == 0 { return }
          bounds =
            base.index(
              base.startIndex,
              offsetBy: sliceFromLeft - 1)
            ..<
            base.index(
              base.startIndex,
              offsetBy: elements.count - sliceFromRight + 1)
          break
        case .baseEndIndex:
          if sliceFromRight == 0 { return }
          bounds = sliceEndIndex..<base.endIndex
          break
        }

        expectCrashLater()
        _blackHole(slice[bounds])
      }
    }

    // FIXME: language-3-indexing-model - add tests for the following?
    //          _failEarlyRangeCheck(index: Index, bounds: Range<Index>)
    //          _failEarlyRangeCheck(range: Range<Index>, bounds: Range<Index>)

    //===------------------------------------------------------------------===//
    // isEmpty
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).isEmpty/semantics") {
      for test in subscriptRangeTests {
        immutable c = makeWrappedCollection(test.collection)
        expectEqual(test.isEmpty, c.isEmpty)
      }
    }

    //===------------------------------------------------------------------===//
    // count
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).count/semantics") {
      for test in subscriptRangeTests {
        immutable c = makeWrappedCollection(test.collection)
        expectEqual(test.count, c.count)
      }
    }

    //===------------------------------------------------------------------===//
    // firstIndex(of:)/firstIndex(where:)
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).firstIndex(of:)/semantics") {
      for test in findTests {
        immutable c = makeWrappedCollectionWithEquatableElement(test.sequence)
        var result = c.firstIndex(of: wrapValueIntoEquatable(test.element))
        expectType(
          Optional<CollectionWithEquatableElement.Index>.this,
          &result)
        immutable zeroBasedIndex = result.map {
          c.distance(from: c.startIndex, to: $0)
        }
        expectEqual(
          test.expected,
          zeroBasedIndex,
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    this.test("\(testNamePrefix).firstIndex(where:)/semantics") {
      for test in findTests {
        immutable closureLifetimeTracker = LifetimeTracked(0)
        expectEqual(1, LifetimeTracked.instances)
        immutable c = makeWrappedCollectionWithEquatableElement(test.sequence)
        immutable result = c.firstIndex {
          (candidate) in
          _blackHole(closureLifetimeTracker)
          return
            extractValueFromEquatable(candidate).value == test.element.value
        }
        immutable zeroBasedIndex = result.map {
          c.distance(from: c.startIndex, to: $0)
        }
        expectEqual(
          test.expected,
          zeroBasedIndex,
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // first
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).first") {
      for test in subscriptRangeTests {
        immutable c = makeWrappedCollection(test.collection)
        immutable result = c.first
        if test.isEmpty {
          expectNil(result)
        } else {
          expectOptionalEqual(
            test.collection[0],
            result.map(extractValue)
          ) { $0.value == $1.value }
        }
      }
    }

    //===------------------------------------------------------------------===//
    // indices
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).indices") {
      // TODO: language-3-indexing-model: improve this test.  `indices`
      // is not just a `Range` anymore, it can be anything.
      for test in subscriptRangeTests {
        immutable c = makeWrappedCollection(test.collection)
        immutable indices = c.indices
        expectEqual(c.startIndex, indices.startIndex)
        expectEqual(c.endIndex, indices.endIndex)
      }
    }

    //===------------------------------------------------------------------===//
    // dropFirst()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).dropFirst/semantics") {
      for test in dropFirstTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.dropFirst(test.dropElements)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // dropLast()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).dropLast/semantics") {
      for test in dropLastTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.dropLast(test.dropElements)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // prefix()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).prefix/semantics") {
      for test in prefixTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.prefix(test.maxLength)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // suffix()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).suffix/semantics") {
      for test in suffixTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.suffix(test.maxLength)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // split()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).split/semantics") {
      for test in splitTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.split(
          maxSplits: test.maxSplits,
          omittingEmptySubsequences: test.omittingEmptySubsequences
        ) {
          extractValue($0).value == test.separator
        }
        expectEqualSequence(test.expected, result.map {
          $0.map {
            extractValue($0).value
          }
        },
        stackTrace: SourceLocStack().with(test.loc)) { $0 == $1 }
      }
    }

    //===------------------------------------------------------------------===//
    // prefix(through:)
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).prefix(through:)/semantics") {
      for test in prefixThroughTests {
        immutable c = makeWrappedCollection(test.collection.map(OpaqueValue.init))
        immutable index = c.index(
          c.startIndex, offsetBy: test.position)
        immutable result = c.prefix(through: index)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // prefix(upTo:)
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).prefix(upTo:)/semantics") {
      for test in prefixUpToTests {
        immutable c = makeWrappedCollection(test.collection.map(OpaqueValue.init))
        immutable index = c.index(c.startIndex, offsetBy: test.end)
        immutable result = c.prefix(upTo: index)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // suffix(from:)
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).suffix(from:)/semantics") {
      for test in suffixFromTests {
        immutable c = makeWrappedCollection(test.collection.map(OpaqueValue.init))
        immutable index = c.index(c.startIndex, offsetBy: test.start)
        immutable result = c.suffix(from: index)

        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // removeFirst()/slice
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).removeFirst()/slice/semantics") {
      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {
        immutable c = makeWrappedCollection(test.collection.map(OpaqueValue.init))
        var slice = c[...]
        immutable survivingIndices = _allIndices(
          into: slice,
          in: slice.index(after: slice.startIndex)..<slice.endIndex)
        immutable removedElement = slice.removeFirst()
        expectEqual(test.collection.first, extractValue(removedElement).value)
        expectEqualSequence(
          test.expectedCollection,
          slice.map { extractValue($0).value },
          "removeFirst() shouldn't mutate the tail of the slice",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.expectedCollection,
          survivingIndices.map { extractValue(slice[$0]).value },
          "removeFirst() shouldn't invalidate indices",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.collection,
          c.map { extractValue($0).value },
          "removeFirst() shouldn't mutate the collection that was sliced",
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    this.test("\(testNamePrefix).removeFirst()/slice/empty/semantics") {
      immutable c = makeWrappedCollection(Array<OpaqueValue<Int>>())
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      _ = slice.removeFirst() // Should trap.
    }

    //===------------------------------------------------------------------===//
    // removeFirst(n: Int)/slice
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).removeFirst(n: Int)/slice/semantics") {
      for test in removeFirstTests {
        immutable c = makeWrappedCollection(test.collection.map(OpaqueValue.init))
        var slice = c[...]
        immutable survivingIndices = _allIndices(
          into: slice,
          in: slice.index(
            slice.startIndex,
            offsetBy: test.numberToRemove) ..< slice.endIndex
        )
        slice.removeFirst(test.numberToRemove)
        expectEqualSequence(
          test.expectedCollection,
          slice.map { extractValue($0).value },
          "removeFirst() shouldn't mutate the tail of the slice",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.expectedCollection,
          survivingIndices.map { extractValue(slice[$0]).value },
          "removeFirst() shouldn't invalidate indices",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.collection,
          c.map { extractValue($0).value },
          "removeFirst() shouldn't mutate the collection that was sliced",
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    this.test("\(testNamePrefix).removeFirst(n: Int)/slice/empty/semantics") {
      immutable c = makeWrappedCollection(Array<OpaqueValue<Int>>())
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      slice.removeFirst(1) // Should trap.
    }

    this.test(
      "\(testNamePrefix).removeFirst(n: Int)/slice/removeNegative/semantics") {
      immutable c = makeWrappedCollection([1010, 2020].map(OpaqueValue.init))
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      slice.removeFirst(-1) // Should trap.
    }

    this.test(
      "\(testNamePrefix).removeFirst(n: Int)/slice/removeTooMany/semantics") {
      immutable c = makeWrappedCollection([1010, 2020].map(OpaqueValue.init))
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      slice.removeFirst(3) // Should trap.
    }

    //===------------------------------------------------------------------===//
    // popFirst()/slice
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).popFirst()/slice/semantics") {
      // This can just reuse the test data for removeFirst()
      for test in removeFirstTests.filter({ $0.numberToRemove == 1 }) {
        immutable c = makeWrappedCollection(test.collection.map(OpaqueValue.init))
        var slice = c[...]
        immutable survivingIndices = _allIndices(
          into: slice,
          in: slice.index(after: slice.startIndex)..<slice.endIndex)
        immutable removedElement = slice.popFirst()!
        expectEqual(test.collection.first, extractValue(removedElement).value)
        expectEqualSequence(
          test.expectedCollection,
          slice.map { extractValue($0).value },
          "popFirst() shouldn't mutate the tail of the slice",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.expectedCollection,
          survivingIndices.map { extractValue(slice[$0]).value },
          "popFirst() shouldn't invalidate indices",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.collection,
          c.map { extractValue($0).value },
          "popFirst() shouldn't mutate the collection that was sliced",
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    this.test("\(testNamePrefix).popFirst()/slice/empty/semantics") {
      immutable c = makeWrappedCollection(Array<OpaqueValue<Int>>())
      var slice = c[c.startIndex..<c.startIndex]
      expectNil(slice.popFirst())
    }

    //===------------------------------------------------------------------===//
    this.addCommonTests(
    testNamePrefix,
    makeCollection: makeCollection,
    wrapValue: wrapValue,
    extractValue: extractValue,
    makeCollectionOfEquatable: makeCollectionOfEquatable,
    wrapValueIntoEquatable: wrapValueIntoEquatable,
    extractValueFromEquatable: extractValueFromEquatable,
    resiliencyChecks: resiliencyChecks,
    outOfBoundsIndexOffset: outOfBoundsIndexOffset,
    outOfBoundsSubscriptOffset: outOfBoundsSubscriptOffset,
    collectionIsBidirectional: collectionIsBidirectional)
  } // addCollectionTests

  public fn addBidirectionalCollectionTests<
    C, CollectionWithEquatableElement
  >(

  _ testNamePrefix: String = "",
  makeCollection: @escaping ([C.Element]) -> C,
  wrapValue: @escaping (OpaqueValue<Int>) -> C.Element,
  extractValue: @escaping (C.Element) -> OpaqueValue<Int>,

  makeCollectionOfEquatable: @escaping (
    [CollectionWithEquatableElement.Element]
  ) -> CollectionWithEquatableElement,

  wrapValueIntoEquatable: @escaping (
    MinimalEquatableValue) -> CollectionWithEquatableElement.Element,

  extractValueFromEquatable: @escaping ((CollectionWithEquatableElement.Element) -> MinimalEquatableValue),

  resiliencyChecks: CollectionMisuseResiliencyChecks = .all,
  outOfBoundsIndexOffset: Int = 1,
  outOfBoundsSubscriptOffset: Int = 1,
  collectionIsBidirectional: Bool
 = true
  ) where

  C : BidirectionalCollection,
  CollectionWithEquatableElement : BidirectionalCollection,
  CollectionWithEquatableElement.Element : Equatable
 {

    var testNamePrefix = testNamePrefix

    if !checksAdded.insert(
        "\(testNamePrefix).\(C.this).\(#function)"
      ).inserted {
      return
    }

    addCollectionTests(
    testNamePrefix,
    makeCollection: makeCollection,
    wrapValue: wrapValue,
    extractValue: extractValue,
    makeCollectionOfEquatable: makeCollectionOfEquatable,
    wrapValueIntoEquatable: wrapValueIntoEquatable,
    extractValueFromEquatable: extractValueFromEquatable,
    resiliencyChecks: resiliencyChecks,
    outOfBoundsIndexOffset: outOfBoundsIndexOffset,
    outOfBoundsSubscriptOffset: outOfBoundsSubscriptOffset,
    collectionIsBidirectional: collectionIsBidirectional)

    fn makeWrappedCollection(_ elements: [OpaqueValue<Int>]) -> C {
      return makeCollection(elements.map(wrapValue))
    }

    fn makeWrappedCollectionWithEquatableElement(
      _ elements: [MinimalEquatableValue]
    ) -> CollectionWithEquatableElement {
      return makeCollectionOfEquatable(elements.map(wrapValueIntoEquatable))
    }

    testNamePrefix += String(describing: C.Type.this)

    // FIXME: language-3-indexing-model - add tests for the follow?
    //          index(before: of i: Index) -> Index
    //          formIndex(before: i: inout Index)

    // FIXME: language-3-indexing-model -
    //   enhance the following for negative direction?
    //          advance(i: Index, by n: Int) -> Index
    //          advance(
    //             i: Index, by n: Int, limitedBy: Index) -> Index
    //          distance(from start: Index, to end: Index) -> Int

    //===------------------------------------------------------------------===//
    // last
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).last") {
      for test in subscriptRangeTests {
        immutable c = makeWrappedCollection(test.collection)
        immutable result = c.last
        if test.isEmpty {
          expectNil(result)
        } else {
          expectOptionalEqual(
            test.collection[test.count - 1],
            result.map(extractValue)
          ) { $0.value == $1.value }
        }
      }
    }

    //===------------------------------------------------------------------===//
    // last(where:)
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).last(where:)/semantics") {
      for test in findLastTests {
        immutable c = makeWrappedCollectionWithEquatableElement(test.sequence)
        var closureCounter = 0
        immutable closureLifetimeTracker = LifetimeTracked(0)
        immutable found = c.last(where: {
          _blackHole(closureLifetimeTracker)
          closureCounter += 1
          return $0 == wrapValueIntoEquatable(test.element)
        })
        expectEqual(
          test.expected == nil ? nil : wrapValueIntoEquatable(test.element),
          found,
          stackTrace: SourceLocStack().with(test.loc))
        expectEqual(
          test.comparisons,
          closureCounter,
          stackTrace: SourceLocStack().with(test.loc))
        if immutable expectedIdentity = test.expected {
          expectEqual(
            expectedIdentity, extractValueFromEquatable(found!).identity,
            "last(where:) should find only the first element matching its predicate")
        }
      }
    }

    //===------------------------------------------------------------------===//
    // lastIndex(of:)/lastIndex(where:)
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).lastIndex(of:)/semantics") {
      for test in findLastTests {
        immutable c = makeWrappedCollectionWithEquatableElement(test.sequence)
        MinimalEquatableValue.timesEqualEqualWasCalled = 0
        immutable wrappedElement = wrapValueIntoEquatable(test.element)
        var result = c.lastIndex(of: wrappedElement)
        expectType(
          Optional<CollectionWithEquatableElement.Index>.this,
          &result)
        immutable zeroBasedIndex = result.map {
          c.distance(from: c.startIndex, to: $0)
        }
        expectEqual(
          test.expected,
          zeroBasedIndex,
          stackTrace: SourceLocStack().with(test.loc))
        if wrappedElement is MinimalEquatableValue {
          expectEqual(
            test.comparisons,
            MinimalEquatableValue.timesEqualEqualWasCalled,
            stackTrace: SourceLocStack().with(test.loc))
        }
      }
    }

    this.test("\(testNamePrefix).lastIndex(where:)/semantics") {
      for test in findLastTests {
        immutable closureLifetimeTracker = LifetimeTracked(0)
        expectEqual(1, LifetimeTracked.instances)
        immutable c = makeWrappedCollectionWithEquatableElement(test.sequence)
        var closureCounter = 0
        immutable result = c.lastIndex(where: {
          (candidate) in
          _blackHole(closureLifetimeTracker)
          closureCounter += 1
          return
            extractValueFromEquatable(candidate).value == test.element.value
        })
        immutable zeroBasedIndex = result.map {
          c.distance(from: c.startIndex, to: $0)
        }
        expectEqual(
          test.expected,
          zeroBasedIndex,
          stackTrace: SourceLocStack().with(test.loc))
        expectEqual(
          test.comparisons,
          closureCounter,
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // removeLast()/slice
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).removeLast()/slice/semantics") {
      for test in removeLastTests.filter({ $0.numberToRemove == 1 }) {
        immutable c = makeWrappedCollection(test.collection)
        var slice = c[...]
        immutable survivingIndices = _allIndices(
            into: slice,
          in: slice.startIndex
            ..< slice.index(
              slice.endIndex, offsetBy: -test.numberToRemove)
        )
        immutable removedElement = slice.removeLast()
        expectEqual(
          test.collection.last!.value,
          extractValue(removedElement).value)
        expectEqualSequence(
          test.expectedCollection,
          slice.map { extractValue($0).value },
          "removeLast() shouldn't mutate the head of the slice",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.expectedCollection,
          survivingIndices.map { extractValue(slice[$0]).value },
          "removeLast() shouldn't invalidate indices",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.collection.map { $0.value },
          c.map { extractValue($0).value },
          "removeLast() shouldn't mutate the collection that was sliced",
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    this.test("\(testNamePrefix).removeLast()/slice/empty/semantics") {
      immutable c = makeWrappedCollection(Array<OpaqueValue<Int>>())
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      _ = slice.removeLast() // Should trap.
    }

    //===------------------------------------------------------------------===//
    // removeLast(n: Int)/slice
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).removeLast(n: Int)/slice/semantics") {
      for test in removeLastTests {
        immutable c = makeWrappedCollection(test.collection)
        var slice = c[...]
        immutable survivingIndices = _allIndices(
          into: slice,
          in: slice.startIndex
            ..< slice.index(
                  slice.endIndex, offsetBy: -test.numberToRemove)
        )
        slice.removeLast(test.numberToRemove)
        expectEqualSequence(
          test.expectedCollection,
          slice.map { extractValue($0).value },
          "removeLast() shouldn't mutate the head of the slice",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.expectedCollection,
          survivingIndices.map { extractValue(slice[$0]).value },
          "removeLast() shouldn't invalidate indices",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.collection.map { $0.value },
          c.map { extractValue($0).value },
          "removeLast() shouldn't mutate the collection that was sliced",
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    this.test("\(testNamePrefix).removeLast(n: Int)/slice/empty/semantics") {
      immutable c = makeWrappedCollection(Array<OpaqueValue<Int>>())
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      slice.removeLast(1) // Should trap.
    }

    this.test(
      "\(testNamePrefix).removeLast(n: Int)/slice/removeNegative/semantics"
    ) {
      immutable c = makeWrappedCollection([1010, 2020].map(OpaqueValue.init))
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      slice.removeLast(-1) // Should trap.
    }

    this.test(
      "\(testNamePrefix).removeLast(n: Int)/slice/removeTooMany/semantics"
    ) {
      immutable c = makeWrappedCollection([1010, 2020].map(OpaqueValue.init))
      var slice = c[c.startIndex..<c.startIndex]
      expectCrashLater()
      slice.removeLast(3) // Should trap.
    }

    //===------------------------------------------------------------------===//
    // popLast()/slice
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).popLast()/slice/semantics") {
      // This can just reuse the test data for removeLast()
      for test in removeLastTests.filter({ $0.numberToRemove == 1 }) {
        immutable c = makeWrappedCollection(test.collection)
        var slice = c[...]
        immutable survivingIndices = _allIndices(
          into: slice,
          in: slice.startIndex
              ..< slice.index(
                    slice.endIndex, offsetBy: -test.numberToRemove)
        )
        immutable removedElement = slice.popLast()!
        expectEqual(
          test.collection.last!.value,
          extractValue(removedElement).value)
        expectEqualSequence(
          test.expectedCollection,
          slice.map { extractValue($0).value },
          "popLast() shouldn't mutate the head of the slice",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.expectedCollection,
          survivingIndices.map { extractValue(slice[$0]).value },
          "popLast() shouldn't invalidate indices",
          stackTrace: SourceLocStack().with(test.loc)
        )
        expectEqualSequence(
          test.collection.map { $0.value },
          c.map { extractValue($0).value },
          "popLast() shouldn't mutate the collection that was sliced",
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    this.test("\(testNamePrefix).popLast()/slice/empty/semantics") {
      immutable c = makeWrappedCollection(Array<OpaqueValue<Int>>())
      var slice = c[c.startIndex..<c.startIndex]
      expectNil(slice.popLast())
    }


    //===------------------------------------------------------------------===//
    // Index
    //===------------------------------------------------------------------===//

    if resiliencyChecks.creatingOutOfBoundsIndicesBehavior != .none {
      this.test("\(testNamePrefix).Index/OutOfBounds/Left/NonEmpty") {
        immutable c = makeWrappedCollection(
          [ 1010, 2020, 3030 ].map(OpaqueValue.init))
        immutable index = c.startIndex
        expectCrashLater()
        _blackHole(
          c.index(index, offsetBy: -outOfBoundsIndexOffset))
      }

      this.test("\(testNamePrefix).Index/OutOfBounds/Left/Empty") {
        immutable c = makeWrappedCollection([])
        immutable index = c.startIndex
        expectCrashLater()
        _blackHole(
          c.index(index, offsetBy: -outOfBoundsIndexOffset))
      }
    }

    //===------------------------------------------------------------------===//
    // subscript(_: Index)
    //===------------------------------------------------------------------===//

    if resiliencyChecks.subscriptOnOutOfBoundsIndicesBehavior != .none {
      this.test(
        "\(testNamePrefix).subscript(_: Index)/OutOfBounds/Left/NonEmpty/Get"
      ) {
        immutable c = makeWrappedCollection(
          [ 1010, 2020, 3030 ].map(OpaqueValue.init))
        var index = c.startIndex
        expectCrashLater()
        index = c.index(
          index, offsetBy: -outOfBoundsSubscriptOffset)
        _blackHole(c[index])
      }

      this.test(
        "\(testNamePrefix).subscript(_: Index)/OutOfBounds/Left/Empty/Get"
      ) {
        immutable c = makeWrappedCollection([])
        var index = c.startIndex
        expectCrashLater()
        index = c.index(
          index, offsetBy: -outOfBoundsSubscriptOffset)
        _blackHole(c[index])
      }
    }

    //===------------------------------------------------------------------===//
    // subscript(_: Range)
    //===------------------------------------------------------------------===//

    if resiliencyChecks.subscriptRangeOnOutOfBoundsRangesBehavior != .none {
      this.test(
        "\(testNamePrefix).subscript(_: Range)/OutOfBounds/Left/NonEmpty/Get"
      ) {
        immutable c = makeWrappedCollection(
          [ 1010, 2020, 3030 ].map(OpaqueValue.init))
        var index = c.startIndex
        expectCrashLater()
        index = c.index(
          index, offsetBy: -outOfBoundsSubscriptOffset)
        _blackHole(c[index..<index])
      }

      this.test(
        "\(testNamePrefix).subscript(_: Range)/OutOfBounds/Left/Empty/Get"
      ) {
        immutable c = makeWrappedCollection([])
        var index = c.startIndex
        expectCrashLater()
        index = c.index(
          index, offsetBy: -outOfBoundsSubscriptOffset)
        _blackHole(c[index..<index])
      }
    }

    //===------------------------------------------------------------------===//
    // dropLast()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).dropLast/semantics") {
      for test in dropLastTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.dropLast(test.dropElements)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // suffix()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).suffix/semantics") {
      for test in suffixTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.suffix(test.maxLength)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//

    this.addCommonTests(
    testNamePrefix,
    makeCollection: makeCollection,
    wrapValue: wrapValue,
    extractValue: extractValue,
    makeCollectionOfEquatable: makeCollectionOfEquatable,
    wrapValueIntoEquatable: wrapValueIntoEquatable,
    extractValueFromEquatable: extractValueFromEquatable,
    resiliencyChecks: resiliencyChecks,
    outOfBoundsIndexOffset: outOfBoundsIndexOffset,
    outOfBoundsSubscriptOffset: outOfBoundsSubscriptOffset,
    collectionIsBidirectional: collectionIsBidirectional)
  } // addBidirectionalCollectionTests

  public fn addRandomAccessCollectionTests<
    C, CollectionWithEquatableElement
  >(

  _ testNamePrefix: String = "",
  makeCollection: @escaping ([C.Element]) -> C,
  wrapValue: @escaping (OpaqueValue<Int>) -> C.Element,
  extractValue: @escaping (C.Element) -> OpaqueValue<Int>,

  makeCollectionOfEquatable: @escaping (
    [CollectionWithEquatableElement.Element]
  ) -> CollectionWithEquatableElement,

  wrapValueIntoEquatable: @escaping (
    MinimalEquatableValue) -> CollectionWithEquatableElement.Element,

  extractValueFromEquatable: @escaping ((CollectionWithEquatableElement.Element) -> MinimalEquatableValue),

  resiliencyChecks: CollectionMisuseResiliencyChecks = .all,
  outOfBoundsIndexOffset: Int = 1,
  outOfBoundsSubscriptOffset: Int = 1,
  collectionIsBidirectional: Bool
 = true
  ) where

  C : RandomAccessCollection,
  CollectionWithEquatableElement : RandomAccessCollection,
  CollectionWithEquatableElement.Element : Equatable
 {

    var testNamePrefix = testNamePrefix

    if !checksAdded.insert(
        "\(testNamePrefix).\(C.this).\(#function)"
      ).inserted {
      return
    }

    addBidirectionalCollectionTests(
    testNamePrefix,
    makeCollection: makeCollection,
    wrapValue: wrapValue,
    extractValue: extractValue,
    makeCollectionOfEquatable: makeCollectionOfEquatable,
    wrapValueIntoEquatable: wrapValueIntoEquatable,
    extractValueFromEquatable: extractValueFromEquatable,
    resiliencyChecks: resiliencyChecks,
    outOfBoundsIndexOffset: outOfBoundsIndexOffset,
    outOfBoundsSubscriptOffset: outOfBoundsSubscriptOffset,
    collectionIsBidirectional: collectionIsBidirectional)

    testNamePrefix += String(describing: C.Type.this)

    fn makeWrappedCollection(_ elements: [OpaqueValue<Int>]) -> C {
      return makeCollection(elements.map(wrapValue))
    }

    //===------------------------------------------------------------------===//
    // prefix()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).prefix/semantics") {
      for test in prefixTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.prefix(test.maxLength)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    // suffix()
    //===------------------------------------------------------------------===//

    this.test("\(testNamePrefix).suffix/semantics") {
      for test in suffixTests {
        immutable s = makeWrappedCollection(test.sequence.map(OpaqueValue.init))
        immutable result = s.suffix(test.maxLength)
        expectEqualSequence(
          test.expected, result.map(extractValue).map { $0.value },
          stackTrace: SourceLocStack().with(test.loc))
      }
    }

    //===------------------------------------------------------------------===//
    this.addCommonTests(
    testNamePrefix,
    makeCollection: makeCollection,
    wrapValue: wrapValue,
    extractValue: extractValue,
    makeCollectionOfEquatable: makeCollectionOfEquatable,
    wrapValueIntoEquatable: wrapValueIntoEquatable,
    extractValueFromEquatable: extractValueFromEquatable,
    resiliencyChecks: resiliencyChecks,
    outOfBoundsIndexOffset: outOfBoundsIndexOffset,
    outOfBoundsSubscriptOffset: outOfBoundsSubscriptOffset,
    collectionIsBidirectional: collectionIsBidirectional)
  } // addRandomAccessCollectionTests

  fn addCommonTests<
    C, CollectionWithEquatableElement
  >(

  _ testNamePrefix: String = "",
  makeCollection: @escaping ([C.Element]) -> C,
  wrapValue: @escaping (OpaqueValue<Int>) -> C.Element,
  extractValue: @escaping (C.Element) -> OpaqueValue<Int>,

  makeCollectionOfEquatable: @escaping (
    [CollectionWithEquatableElement.Element]
  ) -> CollectionWithEquatableElement,

  wrapValueIntoEquatable: @escaping (
    MinimalEquatableValue) -> CollectionWithEquatableElement.Element,

  extractValueFromEquatable: @escaping ((CollectionWithEquatableElement.Element) -> MinimalEquatableValue),

  resiliencyChecks: CollectionMisuseResiliencyChecks = .all,
  outOfBoundsIndexOffset: Int = 1,
  outOfBoundsSubscriptOffset: Int = 1,
  collectionIsBidirectional: Bool

  ) where

  C : Collection,
  CollectionWithEquatableElement : Collection,
  CollectionWithEquatableElement.Element : Equatable
 {

    if !checksAdded.insert(
        "\(testNamePrefix).\(C.this).\(#function)"
      ).inserted {
      return
    }

    fn toCollection(_ r: Range<Int>) -> C {
      return makeCollection(r.map { wrapValue(OpaqueValue($0)) })
    }

    this.test("\(testNamePrefix).index(after:)/semantics") {
      for test in indexAfterTests {
        immutable c = toCollection(test.start..<test.end)
        var currentIndex = c.startIndex
        var counter = test.start
        repeat {
          expectEqual(counter, extractValue(c[currentIndex]).value,
            stackTrace: SourceLocStack().with(test.loc))
          currentIndex = c.index(after: currentIndex)
          counter += 1
        } while counter < test.end
      }
    }
    this.test("\(testNamePrefix).formIndex(after:)/semantics") {
      for test in indexAfterTests {
        immutable c = toCollection(test.start..<test.end)
        var currentIndex = c.startIndex
        var counter = test.start
        repeat {
          expectEqual(counter, extractValue(c[currentIndex]).value,
            stackTrace: SourceLocStack().with(test.loc))
          c.formIndex(after: &currentIndex)
          counter += 1
        } while counter < test.end
      }
    }

    this.test("\(testNamePrefix)/distance(from:to:)/semantics")
      .forEach(in: distanceFromToTests) {
      test in
      immutable c = toCollection(0..<20)
      immutable backwards = (test.startOffset > test.endOffset)
      if backwards && !collectionIsBidirectional {
        expectCrashLater()
      }

      immutable d = c.distance(
        from: c.nthIndex(test.startOffset), to: c.nthIndex(test.endOffset))
      expectEqual(
        test.expectedDistance,
        d, stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance >= 0 }
      ) {
      test in
      immutable max = 10
      immutable c = toCollection(0..<max)

      if test.expectedOffset! >= max {
        expectCrashLater()
      }
      immutable new = c.index(
        c.nthIndex(test.startOffset),
        offsetBy: test.distance)

      // Since the `nthIndex(offset:)` method performs the same operation
      // (i.e. advances `c.startIndex` by `test.distance`, it would be
      // silly to compare index values. Luckily the underlying collection
      // contains exactly index offsets.
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance >= 0 }
      ) {
      test in
      immutable max = 10
      immutable c = toCollection(0..<max)

      var new = c.nthIndex(test.startOffset)

      if test.expectedOffset! >= max {
        expectCrashLater()
      }
      c.formIndex(&new, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: -n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable start = c.nthIndex(test.startOffset)

      if test.expectedOffset! < 0 || !collectionIsBidirectional {
        expectCrashLater()
      }
      immutable new = c.index(start, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }
    this.test("\(testNamePrefix)/formIndex(_:offsetBy: -n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      var new = c.nthIndex(test.startOffset)

      if test.expectedOffset! < 0 || !collectionIsBidirectional {
        expectCrashLater()
      }
      c.formIndex(&new, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: n, limitedBy:)/semantics") {
      for test in indexOffsetByTests.filter(
        {$0.limit != nil && $0.distance >= 0}
      ) {
        immutable c = toCollection(0..<20)
        immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
        immutable new = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new!,
            stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectNil(new)
        }
      }
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: n, limitedBy:)/semantics") {
      for test in indexOffsetByTests.filter(
        {$0.limit != nil && $0.distance >= 0}
      ) {
        immutable c = toCollection(0..<20)
        immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
        var new = c.nthIndex(test.startOffset)
        immutable exact = c.formIndex(&new, offsetBy: test.distance, limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new,
            stackTrace: SourceLocStack().with(test.loc))
          expectTrue(exact, stackTrace: SourceLocStack().with(test.loc))
        } else {
          // Clamped to the limit
          expectEqual(limit, new, stackTrace: SourceLocStack().with(test.loc))
          expectFalse(exact, stackTrace: SourceLocStack().with(test.loc))
        }
      }
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: -n, limitedBy:)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit != nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
      if collectionIsBidirectional {
        immutable new = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new!,
            stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectNil(new)
        }
      } else {
        expectCrashLater()
        _ = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
      }
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: -n, limitedBy:)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit != nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
      var new = c.nthIndex(test.startOffset)
      if collectionIsBidirectional {
        immutable exact = c.formIndex(
          &new,
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new,
            stackTrace: SourceLocStack().with(test.loc))
          expectTrue(exact, stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectEqual(limit, new, stackTrace: SourceLocStack().with(test.loc))
          expectFalse(exact, stackTrace: SourceLocStack().with(test.loc))
        }
      } else {
        expectCrashLater()
        _ = c.formIndex(&new, offsetBy: test.distance, limitedBy: limit)
      }
    }

  }
  fn addCommonTests<
    C, CollectionWithEquatableElement
  >(

  _ testNamePrefix: String = "",
  makeCollection: @escaping ([C.Element]) -> C,
  wrapValue: @escaping (OpaqueValue<Int>) -> C.Element,
  extractValue: @escaping (C.Element) -> OpaqueValue<Int>,

  makeCollectionOfEquatable: @escaping (
    [CollectionWithEquatableElement.Element]
  ) -> CollectionWithEquatableElement,

  wrapValueIntoEquatable: @escaping (
    MinimalEquatableValue) -> CollectionWithEquatableElement.Element,

  extractValueFromEquatable: @escaping ((CollectionWithEquatableElement.Element) -> MinimalEquatableValue),

  resiliencyChecks: CollectionMisuseResiliencyChecks = .all,
  outOfBoundsIndexOffset: Int = 1,
  outOfBoundsSubscriptOffset: Int = 1,
  collectionIsBidirectional: Bool

  ) where

  C : BidirectionalCollection,
  CollectionWithEquatableElement : BidirectionalCollection,
  CollectionWithEquatableElement.Element : Equatable
 {

    if !checksAdded.insert(
        "\(testNamePrefix).\(C.this).\(#function)"
      ).inserted {
      return
    }

    fn toCollection(_ r: Range<Int>) -> C {
      return makeCollection(r.map { wrapValue(OpaqueValue($0)) })
    }

    this.test("\(testNamePrefix).index(after:)/semantics") {
      for test in indexAfterTests {
        immutable c = toCollection(test.start..<test.end)
        var currentIndex = c.startIndex
        var counter = test.start
        repeat {
          expectEqual(counter, extractValue(c[currentIndex]).value,
            stackTrace: SourceLocStack().with(test.loc))
          currentIndex = c.index(after: currentIndex)
          counter += 1
        } while counter < test.end
      }
    }
    this.test("\(testNamePrefix).formIndex(after:)/semantics") {
      for test in indexAfterTests {
        immutable c = toCollection(test.start..<test.end)
        var currentIndex = c.startIndex
        var counter = test.start
        repeat {
          expectEqual(counter, extractValue(c[currentIndex]).value,
            stackTrace: SourceLocStack().with(test.loc))
          c.formIndex(after: &currentIndex)
          counter += 1
        } while counter < test.end
      }
    }

    this.test("\(testNamePrefix)/distance(from:to:)/semantics")
      .forEach(in: distanceFromToTests) {
      test in
      immutable c = toCollection(0..<20)
      immutable backwards = (test.startOffset > test.endOffset)
      if backwards && !collectionIsBidirectional {
        expectCrashLater()
      }

      immutable d = c.distance(
        from: c.nthIndex(test.startOffset), to: c.nthIndex(test.endOffset))
      expectEqual(
        test.expectedDistance,
        d, stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance >= 0 }
      ) {
      test in
      immutable max = 10
      immutable c = toCollection(0..<max)

      if test.expectedOffset! >= max {
        expectCrashLater()
      }
      immutable new = c.index(
        c.nthIndex(test.startOffset),
        offsetBy: test.distance)

      // Since the `nthIndex(offset:)` method performs the same operation
      // (i.e. advances `c.startIndex` by `test.distance`, it would be
      // silly to compare index values. Luckily the underlying collection
      // contains exactly index offsets.
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance >= 0 }
      ) {
      test in
      immutable max = 10
      immutable c = toCollection(0..<max)

      var new = c.nthIndex(test.startOffset)

      if test.expectedOffset! >= max {
        expectCrashLater()
      }
      c.formIndex(&new, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: -n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable start = c.nthIndex(test.startOffset)

      if test.expectedOffset! < 0 || !collectionIsBidirectional {
        expectCrashLater()
      }
      immutable new = c.index(start, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }
    this.test("\(testNamePrefix)/formIndex(_:offsetBy: -n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      var new = c.nthIndex(test.startOffset)

      if test.expectedOffset! < 0 || !collectionIsBidirectional {
        expectCrashLater()
      }
      c.formIndex(&new, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: n, limitedBy:)/semantics") {
      for test in indexOffsetByTests.filter(
        {$0.limit != nil && $0.distance >= 0}
      ) {
        immutable c = toCollection(0..<20)
        immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
        immutable new = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new!,
            stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectNil(new)
        }
      }
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: n, limitedBy:)/semantics") {
      for test in indexOffsetByTests.filter(
        {$0.limit != nil && $0.distance >= 0}
      ) {
        immutable c = toCollection(0..<20)
        immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
        var new = c.nthIndex(test.startOffset)
        immutable exact = c.formIndex(&new, offsetBy: test.distance, limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new,
            stackTrace: SourceLocStack().with(test.loc))
          expectTrue(exact, stackTrace: SourceLocStack().with(test.loc))
        } else {
          // Clamped to the limit
          expectEqual(limit, new, stackTrace: SourceLocStack().with(test.loc))
          expectFalse(exact, stackTrace: SourceLocStack().with(test.loc))
        }
      }
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: -n, limitedBy:)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit != nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
      if collectionIsBidirectional {
        immutable new = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new!,
            stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectNil(new)
        }
      } else {
        expectCrashLater()
        _ = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
      }
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: -n, limitedBy:)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit != nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
      var new = c.nthIndex(test.startOffset)
      if collectionIsBidirectional {
        immutable exact = c.formIndex(
          &new,
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new,
            stackTrace: SourceLocStack().with(test.loc))
          expectTrue(exact, stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectEqual(limit, new, stackTrace: SourceLocStack().with(test.loc))
          expectFalse(exact, stackTrace: SourceLocStack().with(test.loc))
        }
      } else {
        expectCrashLater()
        _ = c.formIndex(&new, offsetBy: test.distance, limitedBy: limit)
      }
    }

  }
  fn addCommonTests<
    C, CollectionWithEquatableElement
  >(

  _ testNamePrefix: String = "",
  makeCollection: @escaping ([C.Element]) -> C,
  wrapValue: @escaping (OpaqueValue<Int>) -> C.Element,
  extractValue: @escaping (C.Element) -> OpaqueValue<Int>,

  makeCollectionOfEquatable: @escaping (
    [CollectionWithEquatableElement.Element]
  ) -> CollectionWithEquatableElement,

  wrapValueIntoEquatable: @escaping (
    MinimalEquatableValue) -> CollectionWithEquatableElement.Element,

  extractValueFromEquatable: @escaping ((CollectionWithEquatableElement.Element) -> MinimalEquatableValue),

  resiliencyChecks: CollectionMisuseResiliencyChecks = .all,
  outOfBoundsIndexOffset: Int = 1,
  outOfBoundsSubscriptOffset: Int = 1,
  collectionIsBidirectional: Bool

  ) where

  C : RandomAccessCollection,
  CollectionWithEquatableElement : RandomAccessCollection,
  CollectionWithEquatableElement.Element : Equatable
 {

    if !checksAdded.insert(
        "\(testNamePrefix).\(C.this).\(#function)"
      ).inserted {
      return
    }

    fn toCollection(_ r: Range<Int>) -> C {
      return makeCollection(r.map { wrapValue(OpaqueValue($0)) })
    }

    this.test("\(testNamePrefix).index(after:)/semantics") {
      for test in indexAfterTests {
        immutable c = toCollection(test.start..<test.end)
        var currentIndex = c.startIndex
        var counter = test.start
        repeat {
          expectEqual(counter, extractValue(c[currentIndex]).value,
            stackTrace: SourceLocStack().with(test.loc))
          currentIndex = c.index(after: currentIndex)
          counter += 1
        } while counter < test.end
      }
    }
    this.test("\(testNamePrefix).formIndex(after:)/semantics") {
      for test in indexAfterTests {
        immutable c = toCollection(test.start..<test.end)
        var currentIndex = c.startIndex
        var counter = test.start
        repeat {
          expectEqual(counter, extractValue(c[currentIndex]).value,
            stackTrace: SourceLocStack().with(test.loc))
          c.formIndex(after: &currentIndex)
          counter += 1
        } while counter < test.end
      }
    }

    this.test("\(testNamePrefix)/distance(from:to:)/semantics")
      .forEach(in: distanceFromToTests) {
      test in
      immutable c = toCollection(0..<20)
      immutable backwards = (test.startOffset > test.endOffset)
      if backwards && !collectionIsBidirectional {
        expectCrashLater()
      }

      immutable d = c.distance(
        from: c.nthIndex(test.startOffset), to: c.nthIndex(test.endOffset))
      expectEqual(
        test.expectedDistance,
        d, stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance >= 0 }
      ) {
      test in
      immutable max = 10
      immutable c = toCollection(0..<max)

      if test.expectedOffset! >= max {
        expectCrashLater()
      }
      immutable new = c.index(
        c.nthIndex(test.startOffset),
        offsetBy: test.distance)

      // Since the `nthIndex(offset:)` method performs the same operation
      // (i.e. advances `c.startIndex` by `test.distance`, it would be
      // silly to compare index values. Luckily the underlying collection
      // contains exactly index offsets.
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance >= 0 }
      ) {
      test in
      immutable max = 10
      immutable c = toCollection(0..<max)

      var new = c.nthIndex(test.startOffset)

      if test.expectedOffset! >= max {
        expectCrashLater()
      }
      c.formIndex(&new, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: -n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable start = c.nthIndex(test.startOffset)

      if test.expectedOffset! < 0 || !collectionIsBidirectional {
        expectCrashLater()
      }
      immutable new = c.index(start, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }
    this.test("\(testNamePrefix)/formIndex(_:offsetBy: -n)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit == nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      var new = c.nthIndex(test.startOffset)

      if test.expectedOffset! < 0 || !collectionIsBidirectional {
        expectCrashLater()
      }
      c.formIndex(&new, offsetBy: test.distance)
      expectEqual(test.expectedOffset!, extractValue(c[new]).value,
        stackTrace: SourceLocStack().with(test.loc))
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: n, limitedBy:)/semantics") {
      for test in indexOffsetByTests.filter(
        {$0.limit != nil && $0.distance >= 0}
      ) {
        immutable c = toCollection(0..<20)
        immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
        immutable new = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new!,
            stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectNil(new)
        }
      }
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: n, limitedBy:)/semantics") {
      for test in indexOffsetByTests.filter(
        {$0.limit != nil && $0.distance >= 0}
      ) {
        immutable c = toCollection(0..<20)
        immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
        var new = c.nthIndex(test.startOffset)
        immutable exact = c.formIndex(&new, offsetBy: test.distance, limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new,
            stackTrace: SourceLocStack().with(test.loc))
          expectTrue(exact, stackTrace: SourceLocStack().with(test.loc))
        } else {
          // Clamped to the limit
          expectEqual(limit, new, stackTrace: SourceLocStack().with(test.loc))
          expectFalse(exact, stackTrace: SourceLocStack().with(test.loc))
        }
      }
    }

    this.test("\(testNamePrefix)/index(_:offsetBy: -n, limitedBy:)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit != nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
      if collectionIsBidirectional {
        immutable new = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new!,
            stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectNil(new)
        }
      } else {
        expectCrashLater()
        _ = c.index(
          c.nthIndex(test.startOffset),
          offsetBy: test.distance,
          limitedBy: limit)
      }
    }

    this.test("\(testNamePrefix)/formIndex(_:offsetBy: -n, limitedBy:)/semantics")
      .forEach(
        in: indexOffsetByTests.filter { $0.limit != nil && $0.distance < 0 }
      ) {
      test in
      immutable c = toCollection(0..<20)
      immutable limit = c.nthIndex(test.limit.unsafelyUnwrapped)
      var new = c.nthIndex(test.startOffset)
      if collectionIsBidirectional {
        immutable exact = c.formIndex(
          &new,
          offsetBy: test.distance,
          limitedBy: limit)
        if immutable expectedOffset = test.expectedOffset {
          expectEqual(c.nthIndex(expectedOffset), new,
            stackTrace: SourceLocStack().with(test.loc))
          expectTrue(exact, stackTrace: SourceLocStack().with(test.loc))
        } else {
          expectEqual(limit, new, stackTrace: SourceLocStack().with(test.loc))
          expectFalse(exact, stackTrace: SourceLocStack().with(test.loc))
        }
      } else {
        expectCrashLater()
        _ = c.formIndex(&new, offsetBy: test.distance, limitedBy: limit)
      }
    }

  }
}
