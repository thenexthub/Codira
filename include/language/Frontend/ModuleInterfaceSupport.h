//===------ ModuleInterfaceSupport.h - languageinterface files -----*- C++ -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//

#ifndef LANGUAGE_FRONTEND_MODULEINTERFACESUPPORT_H
#define LANGUAGE_FRONTEND_MODULEINTERFACESUPPORT_H

#include "language/AST/PrintOptions.h"
#include "language/Basic/Toolchain.h"
#include "language/Basic/Version.h"
#include "toolchain/Support/Regex.h"

#define LANGUAGE_INTERFACE_FORMAT_VERSION_KEY "language-interface-format-version"
#define LANGUAGE_COMPILER_VERSION_KEY "language-compiler-version"
#define LANGUAGE_MODULE_FLAGS_KEY "language-module-flags"
#define LANGUAGE_MODULE_FLAGS_IGNORABLE_KEY "language-module-flags-ignorable"
#define LANGUAGE_MODULE_FLAGS_IGNORABLE_PRIVATE_KEY                               \
  "language-module-flags-ignorable-private"

namespace language {

class ASTContext;
class ModuleDecl;

/// Options for controlling the generation of the .codeinterface output.
struct ModuleInterfaceOptions {
  /// Should we prefer printing TypeReprs when writing out types in a module
  /// interface, or should we fully-qualify them?
  bool PreserveTypesAsWritten = false;

  /// Use aliases when printing references to modules to avoid ambiguities
  /// with types sharing a name with a module.
  bool AliasModuleNames = false;

  /// See \ref FrontendOptions.PrintFullConvention.
  /// [TODO: Clang-type-plumbing] This check should go away.
  bool PrintFullConvention = false;

  struct InterfaceFlags {
    /// Copy of all the command-line flags passed at .codeinterface
    /// generation time, re-applied to CompilerInvocation when reading
    /// back .codeinterface and reconstructing .codemodule.
    std::string Flags = "";

    /// Flags that should be emitted to the .codeinterface file but are OK to
    /// be ignored by the earlier version of the compiler.
    std::string IgnorableFlags = "";
  };

  /// Flags which appear in all .codeinterface files.
  InterfaceFlags PublicFlags = {};

  /// Flags which appear in both the private and package .codeinterface files,
  /// but not the public interface.
  InterfaceFlags PrivateFlags = {};

  /// Flags which appear only in the .package.codeinterface.
  InterfaceFlags PackageFlags = {};

  /// Print imports that are missing from the source and used in API.
  bool PrintMissingImports = true;

  /// Intentionally print invalid syntax into the file.
  bool DebugPrintInvalidSyntax = false;

  /// A mode which decides whether the printed interface contains package, SPIs, or public/inlinable declarations.
  PrintOptions::InterfaceMode InterfaceContentMode = PrintOptions::InterfaceMode::Public;
  bool printPublicInterface() const {
    return InterfaceContentMode == PrintOptions::InterfaceMode::Public;
  }
  bool printPackageInterface() const {
    return InterfaceContentMode == PrintOptions::InterfaceMode::Package;
  }
  void setInterfaceMode(PrintOptions::InterfaceMode mode) {
    InterfaceContentMode = mode;
  }
};

extern version::Version InterfaceFormatVersion;
std::string getCodiraInterfaceCompilerVersionForCurrentCompiler(ASTContext &ctx);

/// A regex that matches lines like this:
///
///     // language-interface-format-version: 1.0
///
/// and extracts "1.0".
toolchain::Regex getCodiraInterfaceFormatVersionRegex();

/// A regex that matches lines like this:
///
///     // language-compiler-version: Apple Codira version 5.8 (languagelang-5.8.0.117.59)
///
/// and extracts "Apple Codira version 5.8 (languagelang-5.8.0.117.59)".
toolchain::Regex getCodiraInterfaceCompilerVersionRegex();

/// A regex that matches strings like this:
///
///     Apple Codira version 5.8
///
/// and extracts "5.8".
toolchain::Regex getCodiraInterfaceCompilerToolsVersionRegex();

/// Emit a stable module interface for \p M, which can be used by a client
/// source file to import this module, subject to options given by \p Opts.
///
/// Unlike a serialized module, the textual format generated by
/// emitCodiraInterface is intended to be stable across compiler versions while
/// still describing the full ABI of the module in question.
///
/// The initial plan for this format can be found at
/// https://forums.code.org/t/plan-for-module-stability/14551/
///
/// \return true if an error occurred
///
/// \sa language::serialize
bool emitCodiraInterface(raw_ostream &out,
                        ModuleInterfaceOptions const &Opts,
                        ModuleDecl *M);

} // end namespace language

#endif
