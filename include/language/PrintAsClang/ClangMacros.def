//===--- ClangMacros.def - Macros emitted by PrintAsClang ----=--*- C++ -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//
//
// This file defines the database of macros emitted into compatibility headers
// generated by PrintAsClang.
//
//===----------------------------------------------------------------------===//

// CLANG_MACRO(NAME, ARGS, VALUE)
// A simple name/value macro that does not depend on a condition.
#ifndef CLANG_MACRO
#define CLANG_MACRO(NAME, ARGS, VALUE)
#endif

// CLANG_MACRO_BODY(NAME, BODY)
// A macro conditionalized on the name, but that defines a helper macro or
// other kind of additional definitions other than the macro itself.
#ifndef CLANG_MACRO_BODY
#define CLANG_MACRO_BODY(NAME, BODY)
#endif

// CLANG_MACRO_DEFINED(NAME)
// Used to signal that a macro is defined by another CLANG_MACRO_BODY call.
// This is included so that these macros can be included in the generated
// `compatibility_symbols` file.
#ifndef CLANG_MACRO_DEFINED
#define CLANG_MACRO_DEFINED(NAME)
#endif

// CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, ALTERNATIVE)
// A simple name/value macro that evaluates to the given value when the given
// condition is true, or to the alternative value when it is false.
#ifndef CLANG_MACRO_ALTERNATIVE
#define CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, ALTERNATIVE)
#endif

// CLANG_MACRO_CONDITIONAL(NAME, ARGS, CONDITION, VALUE)
// A simple name/value macro that only evaluates to the given value when the
// given condition is true. Otherwise the macro will evaluate to nothing.
#ifndef CLANG_MACRO_CONDITIONAL
#define CLANG_MACRO_CONDITIONAL(NAME, ARGS, CONDITION, VALUE) \
    CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, )
#endif

// CLANG_MACRO_OBJC(NAME, ARGS, VALUE)
// A simple name/value macro that is only defined when being compiled as
// Objective-C.
#ifndef CLANG_MACRO_OBJC
#define CLANG_MACRO_OBJC(NAME, ARGS, VALUE)
#endif

// CLANG_MACRO_CXX(NAME, ARGS, VALUE, ALTERNATIVE)
// A simple name/value macro that evaluates to the given value when being
// compiled as C++, or as the alternative when not.
#ifndef CLANG_MACRO_CXX
#define CLANG_MACRO_CXX(NAME, ARGS, VALUE, ALTERNATIVE)
#endif

// CLANG_MACRO_CXX_BODY(NAME, BODY)
// A complex macro conditionalized on whether the source is being compiled as
// C++.
#ifndef CLANG_MACRO_CXX_BODY
#define CLANG_MACRO_CXX_BODY(NAME, BODY)
#endif

CLANG_MACRO_DEFINED("LANGUAGE_TYPEDEFS")
CLANG_MACRO_DEFINED("char8_t")
CLANG_MACRO_DEFINED("char16_t")
CLANG_MACRO_DEFINED("char32_t")

#define MAP_SIMD_TYPE(C_TYPE, SCALAR_TYPE, _) \
    CLANG_MACRO_DEFINED("language_" #C_TYPE "2") \
    CLANG_MACRO_DEFINED("language_" #C_TYPE "3") \
    CLANG_MACRO_DEFINED("language_" #C_TYPE "4")
#include "language/ClangImporter/SIMDMappedTypes.def"

CLANG_MACRO_BODY("LANGUAGE_PASTE", \
    "# define LANGUAGE_PASTE_HELPER(x, y) x##y\n" \
    "# define LANGUAGE_PASTE(x, y) LANGUAGE_PASTE_HELPER(x, y)")
CLANG_MACRO_DEFINED("LANGUAGE_PASTE_HELPER")

CLANG_MACRO("LANGUAGE_METATYPE", "(X)", "Class")

CLANG_MACRO_CONDITIONAL("LANGUAGE_CLASS_PROPERTY", \
                        "(...)", \
                        "__has_feature(objc_class_property)", \
                        "__VA_ARGS__")

CLANG_MACRO_CONDITIONAL("LANGUAGE_RUNTIME_NAME", \
                        "(X)", \
                        "__has_attribute(objc_runtime_name)", \
                        "__attribute__((objc_runtime_name(X)))")

CLANG_MACRO_CONDITIONAL("LANGUAGE_COMPILE_NAME", \
                        "(X)", \
                        "__has_attribute(language_name)", \
                        "__attribute__((language_name(X)))")

CLANG_MACRO_CONDITIONAL("LANGUAGE_METHOD_FAMILY", \
                        "(X)", \
                        "__has_attribute(objc_method_family)",
                        "__attribute__((objc_method_family(X)))")

CLANG_MACRO_CONDITIONAL("LANGUAGE_NOESCAPE", , \
                        "__has_attribute(noescape)", \
                        "__attribute__((noescape))")

CLANG_MACRO_CONDITIONAL("LANGUAGE_RELEASES_ARGUMENT", , \
                        "__has_attribute(ns_consumed)", \
                        "__attribute__((ns_consumed))")

CLANG_MACRO_CONDITIONAL("LANGUAGE_WARN_UNUSED_RESULT", , \
                        "__has_attribute(warn_unused_result)", \
                        "__attribute__((warn_unused_result))")

CLANG_MACRO_CONDITIONAL("LANGUAGE_NORETURN", , \
                        "__has_attribute(noreturn)", \
                        "__attribute__((noreturn))")

CLANG_MACRO("LANGUAGE_CLASS_EXTRA", , )
CLANG_MACRO("LANGUAGE_PROTOCOL_EXTRA", , )
CLANG_MACRO("LANGUAGE_ENUM_EXTRA", , )

CLANG_MACRO_BODY("LANGUAGE_CLASS", \
    "# if __has_attribute(objc_subclassing_restricted)\n" \
    "#  define LANGUAGE_CLASS(LANGUAGE_NAME) " \
        "LANGUAGE_RUNTIME_NAME(LANGUAGE_NAME) __attribute__((objc_subclassing_restricted)) " \
        "LANGUAGE_CLASS_EXTRA\n" \
    "#  define LANGUAGE_CLASS_NAMED(LANGUAGE_NAME) " \
        "__attribute__((objc_subclassing_restricted)) LANGUAGE_COMPILE_NAME(LANGUAGE_NAME) " \
        "LANGUAGE_CLASS_EXTRA\n" \
    "# else\n" \
    "#  define LANGUAGE_CLASS(LANGUAGE_NAME) " \
        "LANGUAGE_RUNTIME_NAME(LANGUAGE_NAME) LANGUAGE_CLASS_EXTRA\n" \
    "#  define LANGUAGE_CLASS_NAMED(LANGUAGE_NAME) " \
        "LANGUAGE_COMPILE_NAME(LANGUAGE_NAME) LANGUAGE_CLASS_EXTRA\n" \
    "# endif")
CLANG_MACRO_DEFINED("LANGUAGE_CLASS_NAMED")

CLANG_MACRO_BODY("LANGUAGE_RESILIENT_CLASS", \
    "# if __has_attribute(objc_class_stub)\n" \
    "#  define LANGUAGE_RESILIENT_CLASS(LANGUAGE_NAME) " \
        "LANGUAGE_CLASS(LANGUAGE_NAME) __attribute__((objc_class_stub))\n" \
    "#  define LANGUAGE_RESILIENT_CLASS_NAMED(LANGUAGE_NAME) " \
        "__attribute__((objc_class_stub)) LANGUAGE_CLASS_NAMED(LANGUAGE_NAME)\n" \
    "# else\n" \
    "#  define LANGUAGE_RESILIENT_CLASS(LANGUAGE_NAME) LANGUAGE_CLASS(LANGUAGE_NAME)\n" \
    "#  define LANGUAGE_RESILIENT_CLASS_NAMED(LANGUAGE_NAME) LANGUAGE_CLASS_NAMED(LANGUAGE_NAME)\n" \
    "# endif")
CLANG_MACRO_DEFINED("LANGUAGE_RESILIENT_CLASS_NAMED")

CLANG_MACRO_BODY("LANGUAGE_PROTOCOL", \
    "# define LANGUAGE_PROTOCOL(LANGUAGE_NAME) " \
        "LANGUAGE_RUNTIME_NAME(LANGUAGE_NAME) LANGUAGE_PROTOCOL_EXTRA\n" \
    "# define LANGUAGE_PROTOCOL_NAMED(LANGUAGE_NAME) " \
        "LANGUAGE_COMPILE_NAME(LANGUAGE_NAME) LANGUAGE_PROTOCOL_EXTRA")
CLANG_MACRO_DEFINED("LANGUAGE_PROTOCOL_NAMED")

CLANG_MACRO("LANGUAGE_EXTENSION", "(M)", "LANGUAGE_PASTE(M##_Codira_, __LINE__)")

CLANG_MACRO_CONDITIONAL("OBJC_DESIGNATED_INITIALIZER", , \
                        "__has_attribute(objc_designated_initializer)", \
                        "__attribute__((objc_designated_initializer))")

CLANG_MACRO_CONDITIONAL("LANGUAGE_ENUM_ATTR", "(_extensibility)", \
                        "__has_attribute(enum_extensibility)", \
                        "__attribute__((enum_extensibility(_extensibility)))")

CLANG_MACRO_BODY("LANGUAGE_ENUM", \
    "# if (defined(__cplusplus) && __cplusplus >= 201103L) || " \
    "     (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L) || " \
    "     __has_feature(objc_fixed_enum)\n" \
    "#  define LANGUAGE_ENUM(_type, _name, _extensibility) " \
        "enum _name : _type _name; " \
        "enum LANGUAGE_ENUM_ATTR(_extensibility) LANGUAGE_ENUM_EXTRA _name : _type\n" \
    "#  if __has_feature(generalized_language_name)\n" \
    "#   define LANGUAGE_ENUM_NAMED(_type, _name, LANGUAGE_NAME, _extensibility) " \
         "enum _name : _type _name LANGUAGE_COMPILE_NAME(LANGUAGE_NAME); " \
         "enum LANGUAGE_COMPILE_NAME(LANGUAGE_NAME) LANGUAGE_ENUM_ATTR(_extensibility) " \
             "LANGUAGE_ENUM_EXTRA _name : _type\n" \
    "#  else\n" \
    "#   define LANGUAGE_ENUM_NAMED(_type, _name, LANGUAGE_NAME, _extensibility) " \
         "LANGUAGE_ENUM(_type, _name, _extensibility)\n" \
    "#  endif\n" \
    "# else\n" \
    "#  define LANGUAGE_ENUM(_type, _name, _extensibility) _type _name; enum \n" \
    "#  define LANGUAGE_ENUM_NAMED(_type, _name, LANGUAGE_NAME, _extensibility) " \
        "LANGUAGE_ENUM(_type, _name, _extensibility)\n" \
    "# endif")
CLANG_MACRO_DEFINED("LANGUAGE_ENUM_NAMED")

CLANG_MACRO_BODY("LANGUAGE_ENUM_TAG", \
    "# if (defined(__cplusplus) && __cplusplus >= 201103L) || " \
    "     (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L) || " \
    "     __has_feature(objc_fixed_enum)\n" \
    "#  define LANGUAGE_ENUM_TAG enum\n" \
    "# else\n" \
    "#  define LANGUAGE_ENUM_TAG\n" \
    "# endif")

CLANG_MACRO_BODY("LANGUAGE_ENUM_FWD_DECL", \
    "# if (defined(__cplusplus) && __cplusplus >= 201103L) || " \
    "     (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L) || " \
    "     __has_feature(objc_fixed_enum)\n" \
    "#  define LANGUAGE_ENUM_FWD_DECL(_type, _name) enum _name : _type _name;\n" \
    "# else\n" \
    "#  define LANGUAGE_ENUM_FWD_DECL(_type, _name) _type _name;\n" \
    "# endif")

CLANG_MACRO("LANGUAGE_UNAVAILABLE", , "__attribute__((unavailable))")
CLANG_MACRO("LANGUAGE_UNAVAILABLE_MSG", "(msg)", "__attribute__((unavailable(msg)))")

CLANG_MACRO("LANGUAGE_AVAILABILITY", "(plat, ...)", "__attribute__((availability(plat, __VA_ARGS__)))")

CLANG_MACRO("LANGUAGE_WEAK_IMPORT", , "__attribute__((weak_import))")

CLANG_MACRO("LANGUAGE_DEPRECATED", , "__attribute__((deprecated))")
CLANG_MACRO("LANGUAGE_DEPRECATED_MSG", "(...)", "__attribute__((deprecated(__VA_ARGS__)))")

CLANG_MACRO_ALTERNATIVE("LANGUAGE_DEPRECATED_OBJC", "(Msg)", \
                        "__has_feature(attribute_diagnose_if_objc)", \
                        "__attribute__((diagnose_if(1, Msg, \"warning\")))", \
                        "LANGUAGE_DEPRECATED_MSG(Msg)")

CLANG_MACRO_OBJC("IBSegueAction", , )

CLANG_MACRO_BODY("LANGUAGE_EXTERN", \
    "# if defined(__cplusplus)\n" \
    "#  define LANGUAGE_EXTERN extern \"C\"\n" \
    "# else\n" \
    "#  define LANGUAGE_EXTERN extern\n"
    "# endif")

CLANG_MACRO("LANGUAGE_CALL", , "__attribute__((languagecall))")

CLANG_MACRO("LANGUAGE_INDIRECT_RESULT", , "__attribute__((language_indirect_result))")

CLANG_MACRO("LANGUAGE_CONTEXT", , "__attribute__((language_context))")

CLANG_MACRO("LANGUAGE_ERROR_RESULT", , "__attribute__((language_error_result))")

// The expansion of this depends on whether stdlib is built as a dynamic library, so do that print
// in PrintAsClang.cpp instead of here since it can't be done in a preprocessor macro
CLANG_MACRO_DEFINED("LANGUAGE_IMPORT_STDLIB_SYMBOL")

CLANG_MACRO_CXX("LANGUAGE_NOEXCEPT", , "noexcept", )

CLANG_MACRO_BODY("LANGUAGE_C_INLINE_THUNK", \
    "# if __has_attribute(always_inline)\n" \
    "# if __has_attribute(nodebug)\n" \
    "#  define LANGUAGE_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))\n" \
    "# else\n" \
    "#  define LANGUAGE_C_INLINE_THUNK inline __attribute__((always_inline))\n" \
    "# endif\n" \
    "# else\n" \
    "#  define LANGUAGE_C_INLINE_THUNK inline\n"\
    "# endif")

#undef CLANG_MACRO
#undef CLANG_MACRO_BODY
#undef CLANG_MACRO_DEFINED
#undef CLANG_MACRO_ALTERNATIVE
#undef CLANG_MACRO_CONDITIONAL
#undef CLANG_MACRO_OBJC
#undef CLANG_MACRO_CXX
#undef CLANG_MACRO_CXX_BODY
