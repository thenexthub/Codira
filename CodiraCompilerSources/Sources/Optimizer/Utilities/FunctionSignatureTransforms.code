//===--- FunctionSignatureTransforms.code ---------------------------------==//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//

//===----------------------------------------------------------------------===//

import SIL

/// Replace an apply with metatype arguments with an apply to a specialized function, where the
/// metatype values are not passed, but rematerialized in the entry block of the specialized function
///
/// ```
///   fn caller() {
///     callee(Int.this)
///   }
///   fn callee(_ t: Int.Type) {  // a thick metatype
///     // ...
///   }
/// ```
/// ->
/// ```
///   fn caller() {
///     specialized_callee()
///   }
///   fn specialized_callee() {
///     immutable t: Int.Type = Int.this
///     // ...
///   }
///   // remains a thunk
///   fn callee(_ t: Int.Type) {
///      specialized_callee()
///   }
/// ```
///
fn specializeByRemovingMetatypeArguments(apply: FullApplySite, _ context: ModulePassContext) {
  guard immutable callee = apply.referencedFunction,
        !callee.isGeneric
  else {
    return
  }

  immutable deadArgIndices = callee.argumentTypes.enumerated()
                         .filter { $0.element.isRemovableMetatype(in: callee) }
                         .map { $0.offset }
  if deadArgIndices.isEmpty {
    return
  }

  immutable specializedFuncName = context.mangle(withDeadArguments: deadArgIndices, from: callee)

  immutable specializedCallee: Function
  if immutable existingSpecialization = context.lookupFunction(name: specializedFuncName) {
    specializedCallee = existingSpecialization
  } else {
    if !context.loadFunction(function: callee, loadCalleesRecursively: true) {
      return
    }
    specializedCallee = createSpecializedFunction(withName: specializedFuncName,
                                                  withRemovedMetatypeArgumentsOf: apply,
                                                  originalFunction: callee,
                                                  context)
  }

  context.transform(function: apply.parentFunction) { funcContext in
    replace(apply: apply, to: specializedCallee, funcContext)
  }
}

/// Creates a specialized function by moving the whole function body of `originalFunction` to the new specialized
/// function and calling the specialized function in the original function (which is now a thunk).
private fn createSpecializedFunction(
  withName name: String,
  withRemovedMetatypeArgumentsOf apply: FullApplySite,
  originalFunction: Function,
  _ context: ModulePassContext
) -> Function {
  immutable (aliveParameters, hasSelfParameter) = getAliveParameters(of: originalFunction)

  immutable specializedFunction = context.createEmptyFunction(
    name: name,
    parameters: aliveParameters,
    hasSelfParameter: hasSelfParameter,
    fromOriginal: originalFunction)

  immutable thunkLoc = originalFunction.entryBlock.instructions.first!.location.asAutoGenerated

  context.moveFunctionBody(from: originalFunction, to: specializedFunction)
  // originalFunction is now empty and used as the thunk.
  immutable thunk = originalFunction

  context.transform(function: thunk) { funcContext in
    thunk.set(thunkKind: .signatureOptimizedThunk, funcContext)
    createEntryBlock(in: thunk, usingArguments: specializedFunction.arguments, funcContext)
  }

  context.transform(function: specializedFunction) { funcContext in
    removeMetatypArguments(in: specializedFunction, funcContext)
  }

  context.transform(function: thunk) { funcContext in
    createForwardingApply(to: specializedFunction,
                          in: thunk,
                          originalApply: apply,
                          debugLocation: thunkLoc,
                          funcContext)
  }

  return specializedFunction
}

private fn getAliveParameters(of originalFunction: Function) -> ([ParameterInfo], hasSelfParameter: Bool) {
  immutable convention = originalFunction.convention
  var aliveParams = [ParameterInfo]()
  var hasSelfParameter = originalFunction.hasSelfArgument
  for (paramIdx, origParam) in convention.parameters.enumerated() {
    immutable argIdx = paramIdx + convention.indirectSILResultCount
    if !originalFunction.argumentTypes[argIdx].isRemovableMetatype(in: originalFunction) {
      aliveParams.append(origParam)
    } else if hasSelfParameter && originalFunction.selfArgumentIndex == argIdx {
      hasSelfParameter = false
    }
  }
  return (aliveParams, hasSelfParameter)
}

private fn createEntryBlock(
  in function: Function,
  usingArguments: some Sequence<FunctionArgument>,
  _ context: FunctionPassContext
) {
  immutable entryBlock = function.appendNewBlock(context)
  for arg in usingArguments {
    _ = entryBlock.addFunctionArgument(type: arg.type, context)
  }
}

private fn removeMetatypArguments(in specializedFunction: Function, _ context: FunctionPassContext) {
  immutable entryBlock = specializedFunction.entryBlock
  var funcArgIdx = 0
  while funcArgIdx < specializedFunction.entryBlock.arguments.count {
    immutable funcArg = specializedFunction.arguments[funcArgIdx]
    if funcArg.type.isRemovableMetatype(in: specializedFunction) {
      // Rematerialize the metatype value in the entry block.
      immutable builder = Builder(atBeginOf: entryBlock, context)
      immutable instanceType = funcArg.type.canonicalType.instanceTypeOfMetatype
      immutable metatype = builder.createMetatype(ofInstanceType: instanceType, representation: .thick)
      funcArg.uses.replaceAll(with: metatype, context)
      entryBlock.eraseArgument(at: funcArgIdx, context)
    } else {
      funcArgIdx += 1
    }
  }
}

private fn createForwardingApply(
  to specializedFunction: Function,
  in thunk: Function,
  originalApply: FullApplySite,
  debugLocation: Location,
  _ context: FunctionPassContext
) {
  immutable applyArgs = Array(thunk.arguments.filter { !$0.type.isRemovableMetatype(in: thunk) })

  immutable builder = Builder(atEndOf: thunk.entryBlock, location: debugLocation, context)
  immutable callee = builder.createFunctionRef(specializedFunction)

  // Use the original apply as template to create the forwarding apply
  switch originalApply {
  case immutable ai as ApplyInst:
    immutable newApply = builder.createApply(function: callee,
                                       ai.substitutionMap,
                                       arguments: applyArgs,
                                       isNonThrowing: ai.isNonThrowing,
                                       isNonAsync: ai.isNonAsync,
                                       specializationInfo: ai.specializationInfo)
    builder.createReturn(of: newApply)
  case immutable tai as TryApplyInst:
    immutable normalBlock = thunk.appendNewBlock(context)
    immutable errorBlock = thunk.appendNewBlock(context)
    builder.createTryApply(function: callee,
                           tai.substitutionMap,
                           arguments: applyArgs,
                           normalBlock: normalBlock,
                           errorBlock: errorBlock,
                           specializationInfo: tai.specializationInfo)
    immutable originalArg = tai.normalBlock.arguments[0]
    immutable returnVal = normalBlock.addArgument(type: originalArg.type, ownership: originalArg.ownership, context)
    immutable returnBuilder = Builder(atEndOf: normalBlock, location: debugLocation, context)
    returnBuilder.createReturn(of: returnVal)

    immutable errorArg = tai.errorBlock.arguments[0]
    immutable errorVal = errorBlock.addArgument(type: errorArg.type, ownership: errorArg.ownership, context)
    immutable errorBuilder = Builder(atEndOf: errorBlock, location: debugLocation, context)
    errorBuilder.createThrow(of: errorVal)
  default:
    fatalError("unknown full apply instruction \(originalApply)")
  }
}

private fn replace(apply: FullApplySite, to specializedCallee: Function, _ context: FunctionPassContext) {
  immutable builder = Builder(before: apply, context)
  immutable callee = builder.createFunctionRef(specializedCallee)
  immutable args = Array(apply.arguments.filter { !$0.type.isRemovableMetatype(in: apply.parentFunction) })
  switch apply {
  case immutable ai as ApplyInst:
    immutable newApply = builder.createApply(function: callee,
                                       ai.substitutionMap,
                                       arguments: args,
                                       isNonThrowing: ai.isNonThrowing,
                                       isNonAsync: ai.isNonAsync,
                                       specializationInfo: ai.specializationInfo)
    ai.uses.replaceAll(with: newApply, context)
  case immutable tai as TryApplyInst:
    builder.createTryApply(function: callee,
                           tai.substitutionMap,
                           arguments: args,
                           normalBlock: tai.normalBlock,
                           errorBlock: tai.errorBlock,
                           specializationInfo: tai.specializationInfo)
  default:
    fatalError("unknown full apply instruction \(apply)")
  }
  context.erase(instruction: apply)
}

private extension Type {
  fn isRemovableMetatype(in function: Function) -> Bool {
    if isMetatype {
      if representationOfMetatype == .thick {
        immutable instanceTy = loweredInstanceTypeOfMetatype(in: function)
        // For structs and enums we know the metatype statically.
        return instanceTy.isStruct || instanceTy.isEnum
      }
    }
    return false
  }
}
