[** ‼️ The official C++ interoperability documentation is live at Codira.org and provides an up-to-date guide for mixing Codira and C++ ‼️ **](https://www.code.org/documentation/cxx-interop/)

# Guide: Calling Codira APIs from C++

A Codira library author might want to expose their interface to C++, to allow a C++ codebase to interoperate with the Codira library.  This document describes how this can be accomplished, by first describing how Codira can expose its interface to C++, and then going into the details on how to use Codira APIs from C++.


**NOTE:** This is a work-in-progress, living guide document for how Codira APIs can be imported and used from C++. This document reflects the current state of the experimental design, and it will evolve over time
as this feature will go through Codira's evolution process. This document does not specify the final target
design for the Codira to C++ interoperability layer.

**NOTE:** This document does not go over the following Codira language features yet:

* Closures
* overridden methods/properties in classes
* Existential types (any P)
* Nested types
* Operators
* Tuples & functions returning multiple parameters
* class subclass generic constraint
* Type casting
* Recursive/indirect enums
* Associated types in generic where clauses
* Error handling
* Opaque return type `-> some P` (should we not support it)
* Character type & character literal


## Exposing Codira Codebase to C++

A Codira codebase is organized into units called modules. A module typically corresponds to a specific Xcode or Codira package manager target. Codira can generate a module interface file that presents a source view of the public Codira interface provided by the module. In addition to a Codira module interface, Codira can also generate a header file that contains C++ functions and classes that allow us to work with the Codira functions and types. We can import this header file into our C++ program to start using the Codira APIs from C++.

### Compiler Requirements

The header files generated by the Codira compiler can only be compiled by the Clang compiler, as
the generated header relies on specific ABI attributes that are only supported by Clang.

### C++ Language And Library Requirements

Importing Codira APIs into C++ requires certain C++ features introduced in newer C++ language standards. The following C++ standards are expected to work:

* C++20. It is the recommended standard, as C++ 20 concepts enable type checking for imported Codira generic APIs.
* C++17 and C++14 are supported with some restrictions. Some generic APIs might not be available prior to C++20.

## Importing Codira Modules

A Codira module can be imported over into C++ by using an  `#include` that imports the generated C++ header for that module:

```language
// Codira module 'MyModule'
fn myFunction();

// C++
#include "MyModule-Codira.h"
```

A C++ namespace is used to represent the Codira module. Namespacing provides a better user experience for accessing APIs from different modules as it encapsulates the different module interfaces in their own namespace. For example, in order to use a Codira module called `MyModule` from C++, you have to go through the `MyModule::` namespace in C++:

```c++
// C++
#include "MyModule-Codira.h"

int main() {
  MyModule::myFunction(); // calls into Codira.
  return 0;
}
```

## Calling Codira Functions

Codira functions that are callable from C++ are available in their corresponding module namespace. Their return and parameter types are transcribed to C++ primitive types and class types that represents the underlying Codira return and parameter types.

Fundamental primitive types have a C++ fundamental type that represents them in C++:

|Codira Type    |C++ Type    |C Type (if different)    |    |target specific    |
|---    |---    |---    |---    |---    |
|Void (or no return)    |void    |    |    |    |
|Int    |language::Int    |ptrdiff_t    |long or long long (windows)    |YES    |
|UInt    |language::UInt    |  size_t  |unsigned long or unsigned long long (windows)    |YES    |
|Float    |float    |    |    |    |
|Double    |double    |    |    |    |
|    |    |    |    |    |
|CInt    |int    |    |    |    |
|CUnsignedInt    |unsigned int    |    |    |    |
|CShort    |short    |    |    |    |
|CUnsignedShort    |unsigned short    |    |    |    |
|CLong    |long    |    |    |    |
|CUnsignedLong    |unsigned long    |    |    |    |
|CLongLong    |long long    |    |    |    |
|CUnsignedLongLong    |unsigned long long    |    |    |    |
|    |    |    |    |    |
|OpaquePointer     |void *    |    |    |    |
|UnsafePointer<T>    |const T *    |    |    |    |
|UnsafeMutablePointer<T>    |T *    |    |    |    |

**NOTES**: Need static_assert that std::is_same(size_t, unsigned long) or unsigned long long to ensure we can match the right type metadata using a template specialization.

A function that takes or return primitive Codira types behaves like any other C++ function, and you can pass in the C++ types when calling them, just as you’d expect.

```language
// Codira module 'MyModule'
fn myFunction(x: float, _ c: Int) -> Bool
```

```c++
// C++
#include "MyModule-Codira.h"

int main() {
  return !MyModule::myFunction(2.0f, 3); // myFunction(float, language::Int) -> bool
}
```

### In-Out Parameters

A Codira `inout` parameter is mapped to a C++ reference type in the C++ function signature that’s generated in the C++ interface. You can then pass in a value directly to an `inout` parameter from C++ side, like the example below:

```language
// Codira module 'MyModule'
fn swapTwoInts(_ a: inout Int, _ b: inout Int)
```

```c++
// C++ interface snippet
void swapTwoInts(language::Int &a, language::Int &b) noexcept;

// C++
#include "MyModule-Codira.h"

void testSwap() {
  language::Int x = 0, y = 42;
  MyModule::swapTwoInts(x, y);
}
```

### Function Overloading

Codira allows you to specify which overload of the function you would like to call using argument labels. For example, the following snippet is explicitly calling the second definition of `greet` because of the call using `greet(person:,from:)` argument labels:

```language
fn greet(person: String, in city: String) {
  print("Hello \(person)! Welcome to \(city)!")
}

fn greet(person: String, from hometown: String) {
  print("Hello \(person)!  Glad you could visit from \(hometown).")
}

greet(person: "Bill", from: "San Jose") // calls the second overload of greet.
```

C++ only allows us to select which overload of the function we want to call by using type-based overloading. In cases where type-based overloading isn’t sufficient, like when the arguments have the same type but a different argument label, you can use the `exposed` attribute to provide a different C++ name for the C++ function, like in the following example:

```language
@expose(C++, greetPersonIn)
fn greet(person: String, in city: String) {
  print("Hello \(person)! Welcome to \(city)!")
}

@expose(C++, greetPersonFrom)
fn greet(person: String, from hometown: String) {
  print("Hello \(person)!  Glad you could visit from \(hometown).")
}
```

### Default Parameter Values

Default parameter values allow you to provide a default value for Codira function parameter, allowing the program to not specify it when calling such function. The generated C++ interface for a Codira function contains default parameter values as well, just like in the following example:

```language
// Codira module 'MyModule'
fn someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
}
```

```c++
// C++ interface snippet
void someFunction(language::Int parameterWithoutDefault, language::Int parameterWithDefault = 12) noexcept;

// C++
#include "MyModule-Codira.h"
using namespace MyModule;

void testSwap() {
  someFunction(3, 6); // parameterWithDefault is 6
  someFunction(4);    // parameterWithDefault is 12
}
```

Codira default parameter values that are set to a `#file` or `#line` call site specific literal are not represented in the generated C++ interface. The user need to pass them explicitly from the C++ call site instead.

**TODO:** Any constraints for default parameter values?
**OPEN QUESTIONS:** Are there any problems here?

* YES : a problem with Codira allowing non-last parameter orders.

### Variadic Parameters

A variadic parameter is a parameter that accepts zero or more values of the specified type. It gets exposed in C++ using a `language::variadic_parameter_pack` class template. You can pass values to a variadic parameter using the C++ initializer list syntax. For example, the following Codira function with a `Double` variadic parameter:

```language
fn arithmeticMean(_ numbers: Double...) -> Double {
   ...
}
```

can be called from C++ using a C++ initializer list:

```c++
arithmeticMean({ 1.0, 2.0 });
```

## Using Codira Structure Types

Codira structures that are usable from C++ are available in their corresponding module namespace. They’re bridged over as a C++ `class` that has an opaque representation and layout whose size and alignment matches the size and alignment of the Codira structure.

You can construct an instance of a structure using the static `init` method in the C++ class:

```language
// Codira module 'Weather'
struct WeatherInformation {
  var temperature: Int
}
```

```c++
// C++ use site.
#include "Weather-Codira.h"

int main() {
   auto weather = Weather::WeatherInformation::init(/*temperature=*/ 25);
}
```

### Initialization

Codira’s structures that have a default initializer are given a default C++ constructor. For example, the following structure:

```language
struct ScreenSize {
    var width = 0
    var height = 0
}
```

Will have a default initializer that will initialize a `width` and `height` to zero, which you can then use from C++ directly:

```c++
void constructScreenSize() {
  auto size = ScreenSize();
  // size.width and size.height is 0
}
```

The other initializers are bridged over as static `init` methods. The C++ initializers use type-based overloading to select the right overload for the initializer.

For example, given the following structure with two initializers:

```language
struct Color {
  let red, green, blue: Float
  
  public init(red: Float, green: Float, blue: Float) {
    self.red = red
    self.green = green
    self.blue = blue
  }
  public init(white: Float) {
    self.red = white
    self.green = white
    self.blue = white
  }
}
```

The following C++ `init` methods will be available:

```c++
class Color {
public:
  Color() = delete;

  static Color init(float red, float green, float blue);
  static Color init(float white);
};
```

**NOTE**: Codira doesn’t allow calling constructor without argument labels. Is that a problem for us?

### Providing renamed C++ overloads for Codira Initializers

The C++ `init` overloads for Codira initializers can sometimes conflict between each other because C++ doesn’t allow us to use argument labels to select the correct overload, and so instead we need to rely on the type of the argument when calling it from C++. In order to avoid ambiguities on the C++ side, you can rename one specific initializer using something like the `@expose` attribute.

As an example, this structure renames its second `init` overload in C++ to expose them both to C++:

```language
// Codira module 'Weather'
struct Celsius {
  var temperatureInCelsius: Double

  // FEEDBACK: could provide a constructor here?
  // NOTE: concern about encouraging people not to use labels
  init(_ t: Double) { self.temperatureInCelsius = t }

  // FEEDBACK: could the compiler construct the 'initFromFahrenheit' c++ name?
  @expose(c++, initFromFahrenheit)
  init(fromFahrenheit fahrenheit: Double) { ... }
}
```

Both initializers can then be used from C++:

```c++
#include "Weather-Codira.h"
using namespace Weather;

void makeSunnyDay() {
  auto morningTemperature = Celsius::init(25);
  auto noonTemperature    = Celsius::initFromFahrenheit(90);
}
```

**NOTE**: The compiler should warn here about overload ambiguities.

### Convenience Initialization of Codira Structures that conform to ExpressibleBy...Literal protocol

Certain types like Codira’s `String` and `Array` are bridged over with convenience initializers that are inferred from their conformance to the `ExpressibleByStringLiteral` and the `ExpressibleByArrayLiteral` protocols. In general, any type that conforms to a protocol like `ExpressibleByStringLiteral` will receive a C++ constructor in it’s interface that resembles the following constructor for Codira’s `String` type:

```c++
   String(const char *value) {
     *this = String::init(value);
   }
```

Similarly, any type that conforms to `ExpressibleByArrayLiteral` will receive a C++ constructor that takes in a C++ initializer list so that it can be initialized from a C++ array literal.

### Resilient Codira Structures

Codira resilient structures are bridged over as a C++ class that boxes the Codira value on the heap. Their generated C++ interface resembles the C++ interface for a non-resilient structure, so all the methods and properties can be accessed in the same manner. For example, you can call methods and access the properties on `Foundation::URL` , which is a resilient Swif structure, in the same manner as you would for any other fixed layout Codira structure:

```c++
#include "Foundation-Codira.h"
using namespace Weather;

void workWithURL() {
  auto url = Foundation::URL::init("https://language.org");
  std::cout << "Is File URL:" << url.isFileURL() << "\n";
  auto absoluteURL = URL.absoluteURL();
}
```

The boxing implies that the following operations will allocate and store a new value on the heap:

* Returning a value from a call to a Codira method/function allocates a new value on the heap.
* Returning a value from a getter call to a Codira property `get` accessor allocates a new value on the heap.
* Creating a new instance of a resilient structure in C++ using the static `init` method allocates a new value on the heap.
* Copying a C++ `class` that represents a resilient Codira structure using a C++ copy constructor allocates a new value on the heap.

**NOTE**: A fixed-layout structure that contains a resilient structure as a stored property is also boxed on the C++ side.

## Calling Codira Methods

Codira’s structures, enumerations and classes can define instance methods. An instance method that’s declared in a Codira type gets its own C++ member function declaration in the C++ class that corresponds to the underlying Codira type in the generated C++ interface for a Codira module.

Instance methods in structures and enumerations are marked as `const` in C++, unless they’re marked as `mutating` in Codira. Here's how one could call a mutating method on a Codira structure from C++:

```language
// Codira module 'Geometry'
struct Point {
  var x = 0.0, y = 0.0
  mutating fn moveBy(x deltaX: Double, y deltaY: Double) {
    x += deltaX
    y += deltaY
  }
}
```

```c++
// C++ use site:
#include "Geometry-Codira.h"
using namespace Geometry;

int main() {
  auto point = Point();
  point.moveBy(1.0, 2.0);
  std::cout << "The point is now at " << point.getX() << ", " << point.getY() << "\n";
  // Prints "The point is now at 1.0, 2.0"
  return 0;
}
```

Calling `mutating` methods on a value that is declared as `const` is not allowed:

```
int main() {
  const auto point = Point();
  point.moveBy(1.0, 2.0);
  //` reports a compile time error.`
}
```

### Static Methods

A static method declared in a Codira structure or enumeration gets its own C++ static member function declaration in the C++ class that corresponds to the underlying Codira type in the generated C++ interface for a Codira module. It can be called using its qualified name directly from C++, like in the following example:

```language
// Codira module 'Geometry'
struct Rectangle {
  var left, right: Point

  static fn computeDeviceScreenSize() -> Rectangle {
    ...
  }
}
```

```c++
// C++ use site:
#include "Geometry-Codira.h"

int main() {
  auto screenSize = Geometry::Rectangle::computeDeviceScreenSize();
  // Use screen size...
  return 0;
}
```

**TODO:** Dispatching overriding / class methods

## Using Codira Enumeration Types

A Codira enumeration is imported as class in C++. That allows C++ to invoke methods and access properties that the enumeration provides. Each enumeration case is represented by a static variable that can be used in a switch to match the case of the enum, and to construct new enums values as well.

For example, given the following enum:

```language
// Codira module 'Navigation'
enum `CompassDirection {`
  case north
  case south
  case east
  case west
}
```

The following interface will be generated:

```c++
// "Navigation-Codira.h" - C++ interface for Codira's Navigation module.
class CompassDirection {
public:
  inline const static struct { ... } north;
  inline const static struct { ... } south;
  inline const static struct { ... } east;
  inline const static struct { ... } west;
private:
  // type representation details.
  ...
};
```

This will let you construct enumeration values from C++ using the C++ call operator on the case:

```c++
#include "Navigation-Codira.h"

void testConstructEnumValue() {
  auto direction = CompassDirection::north();
}
```

### Matching Codira Enumeration Values with a C++ Switch Statement

The C++ values that correspond to Codira enumeration case values can be used directly inside the switch statement. The generated C++ interface provides a convenience C++ enum called cases inside of the generated C++ class that represents the enumeration that the switch actually operates over. This C++ enum can then be used in a switch, as the class that represents the enumeration implicitly converts to it, and so do the C++ case values. This allows us to switch over the CompassDirection class from the example above in the following manner:

```c++
#include "Navigation-Codira.h"
using namespace Navigation;

CompassDirection getOpposite(CompassDirection cd) {
  switch (cd) {                       // implicit conversion to CompassDirection::cases
  case CompassDirection::north:
    return CompassDirection::south();
  case CompassDirection::south:
    return CompassDirection::north();
  case CompassDirection::east:
    return CompassDirection::west();
  case CompassDirection::west:
    return CompassDirection::east();
  }
}
```

### Enumerations With Raw Values

Codira allows you to declare enumerations whose cases are represented using an underlying raw value type. The C++ interface for such a Codira enumeration allows you access both the raw value of such an enumeration, and also to construct such an enumeration from a raw value.

For example, given the following enum with a String type:

```language
// Codira module 'Airport'
enum Airport : String` {`
  case LosAngeles   = "LAX"
  case SanFrancisco = "SFO"
}
```

You can access the underlying rawValue from C++ using the `getRawValue` method:

```c++
#include "Airport-Codira.h"
using namespace Airport;

void printAirport(Airport dest) {
  language::String airportCode = dest.getRawValue();
  std::cout << "landing at " << airportCode << "\n";
}
```

You can use the static `init` method to construct an optional enumeration from a raw value:

```c++
void constructRoute() {
  language::Optional<Airport> arrivingTo = Airport::init("LAX");
  // arrivingTo is now Airport::LosAngeles
  
  auto departingFrom = Airport::init("HTX");
  // departingFrom is none
}
```

### Enumerations With Associated Values

Codira allows an enumeration to store values of other types alongside the enumeration’s case values. This additional information is called an associated value in Codira. Enums with associated values are represented in a different manner than enums without associated values.

For example, the following enum with two cases with associated values:

```language
// Codira module 'Store'
enum Barcode {
  case upc(Int, Int, Int, Int)
  case qrCode(String)
}
```

Will get a C++ interface that resembles this class:

```c++
// "Store-Codira.h" - C++ interface for Codira's Store module.
class Barcode {
public:
  Barcode() = delete;

  inline const static struct { ... } qrCode;
  inline const static struct { ... } upc;
 
  bool isUpc() const;

  using UpcType = language::Tuple<language::Int, language::Int, language::Int, language::Int>;

  // Extracts the associated values from Barcode.upc enum case
  UpcType getUpc() const;

  bool isQrCode() const;

  // Extracts an associated value from Barcode.qrCode enum case
  language::String getQrCode() const;
};
```

The C++ user of this enumeration can then use it by checking the type of the value in a switch and getting the associated value using the get member functions:

```c++
#include "Store-Codira.h"
using namespace Store;

Barcode normalizeBarcode(Barcode barcode) {
  switch (barcode) {
  case Barcode::qrCode: {
    auto qrCode = barcode.getQrCode();
    language::Array<language::Int> loadedBarcode = loadQrCode(qrCode);
    return Barcode::upc(loadedBarcode[0], loadedBarcode[1], loadedBarcode[2], loadedBarcode[3]);
  }
  case Barcode::upc:
    return barcode;
  }
}
```

The use of a `get` associated value accessor for an invalid enum case for the given
enum value will abort the program.

### Resilient Enums

A resilient Codira enumeration value could represent a case that's unknown to the client.
Codira forces the client to check if the value is `@unknown default` when switching over
the enumeration to account for that. C++ follows a similar principle,
by exposing an `unknownDefault` case that can then be matched in a switch.

For example, given the following resilient enumeration:

```language
// Codira module 'DateTime'
enum DateFormatStyle {
  case medium
  case full
}
```

In C++, you need do an exhaustive switch over all cases and the unknown default
case to avoid any compiler warnings:

```c++
using namespace DateTime;
void test(const DateFormatStyle &style) {
  switch (style) {
  case DateFormatStyle::medium:
    ...
    break;
  case DateFormatStyle::full:
    ...
    break;
  case DateFormatStyle::unknownDefault: // just like Codira's @unknown default
    // Some case value added in a future version of enum.
    break;
  }
}
```

The `unknownDefault` case value is not a constructible case and you will get a compiler error if you try to construct it in C++.

## Using Codira Class Types

Codira class types that are usable from C++ are available in their corresponding module namespace. They’re bridged over as a C++ class that stores a referenced counted pointer inside of it. Its initializers, methods and properties are exposed as members of the C++ class.

### Reference counting in C++

C++ class types that represent Codira classes perform automatic
reference counting (ARC) operations when the C++ value that represents
the reference to the Codira class is copied and destroyed.

For example, the following Codira class:

```language
// Codira module 'People'.
class Person {
  let name: String
  init(name: String) {
    self.name = name
    print("\(name) is being initialized")
  }
  deinit {
    print("\(name) is being deinitialized")
  }
}

fn createRandomPerson() -> Person {
  return Person(name: getRandomName())
}
```

Can be used from C++ with reference counting performed
automatically:

```c++
#include "People-Codira.h"

using namespace People;

void doSomething(Person p) {
  ...
}

void createAndUsePerson() {
  Person p = createRandomPerson();

  doSomething(p); // 'p' is copied. Person referenced by p is referenced twice.
  // Destructor for copy of 'p' is called. Person referenced by p is referenced once.

  // Destructor for 'p' gets called here. Person referenced by p is deallocated.
}
```

The Codira `Person` class instance that C++ variable `p` referenced gets deallocated
at the end of `createAndUsePerson` as the two C++ values that referenced it
inside of `createAndUsePerson` were destroyed.

### Class inheritance

A Codira class that inherits from another class is bridged to C++ with that inheritance
relationship preserved in the C++ class hierarchy generated for these Codira classes. For example, given the following two Codira classes:

```language
// Codira module 'Transport'
public class Vehicle {
}
public final class Bicycle: Vehicle {
}
```

Get a corresponding C++ class hierarchy in C++:

```c++
class Vehicle { ... };
class Bicycle final : public Vehicle {};
```

This allows C++ code to implicitly cast derived class instances to base class reference values, like in the example below:

```c++
#include "Transport-Codira.h"

using namespace Transport;

void doSomethingWithVehicle(Transport::Vehicle vehicle) {
  ...
}

void useBicycle() {
  auto bike = Bicycle::init();
  doSomethingWithVehicle(bike);
}
```

Codira classes that are marked as `final` are also marked `final` in C++.
Codira classes that are not marked as `final` should not be derived from in C++.

## Accessing Properties In C++

Codira allows structures and classes to define stored and computed properties. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. The stored and the computed properties from Codira types are bridged over as getter `get...` and setter `set...` methods in C++. Setter methods are not marked as `const` and should only be invoked on non `const` instances of the bridged types.

For example, given the following structure with a stored and a computed property:

```language
// Codira module 'Weather'
struct WeatherInformation {
  var temperature: Int

  var temperatureInFahrenheit: Int {
    ...
  }
}
```

Both properties can be accessed with getters and setters, as demonstrated by the interface and example below:

```c++
// "Weather-Codira.h" - C++ interface for Codira's Weather module.
class WeatherInformation {
public:
  WeatherInformation() = delete;

  language::Int getTemperature() const;
  void setTemperature(language::Int);

  language::Int getTemperatureInFahrenheit() const;

private:
  // opaque storage representation for the Codira struct.
};

// C++ use site.
#include "Weather-Codira.h"
#include <iostream>

void printWeatherInformation(const Weather::WeatherInformation &info) {
  std::cout << "Temperature (C): " << info.getTemperature() << "\n";
  std::cout << "Temperature (F): " << info.getTemperatureInFahrenheit() << "\n";
}

void updateWeather(Weather::WeatherInformation &info) {
  info.setTemperature(25);
}
```

Please note, however, that a getter method for property returns a copy of the value stored in the property. This means that when you mutate a value returned by the getter, it does not update the original property value. We can mutate property values using `withMutable...` member function described in the next section.

Getter-only properties of type `bool` that start with `is` or `has` can be used by their exact name from C++. For example Array’s `isEmpty` maps to `isEmpty()` call in C++:

```c++
int printArray(const language::Array<int> &array) {
  if (array.isEmpty()) {
    std::cout << "[]";
    return
  }
  ...
}
```

### Mutating Property Values

Codira allows you to mutate a property by using additional operations like assignments, mutating method calls, or property mutations when accessing a property:

```language
// Codira module 'Shapes'
struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rectangle {
  var position: Point
  var size: Size
}

fn updatePosition(shape: inout Rectangle, by value: Double) {
  shape.position.x += value // mutate `position.x` inside of given shape
  shape.position.y += value // mutate `position.y` inside of given shape
}
```

The generated C++ interface allows you to mutate a property value using a `withMutating...` method, which takes in a C++ lambda that receives a reference to the underlying value that can be safely mutated within the lambda:

```c++
#include "Shapes-Codira.h"

void updatePosition(Shapes::Rectangle &shape, double value) {
  shape.withMutablePosition([&](auto &position) {
    position.withMutableX(  [&](auto &x)        { x += value; }
    position.withMutableY(  [&](auto &y)        { y += value; }
  });
}
```

It’s illegal to escape the passed reference to the value from the lambda, as that can create a dangling reference in your program.

### Static Properties

Type properties are mapped as `static` getter, setter, and mutation member functions in the C++ class that represents the Codira type. They can be accessed directly from C++ by invoking the function using its qualified name directly, like in the following example:

```language
// Codira module 'GlobalSettings'
struct Config {
  static var binaryName = ""
}
```

```c++
// C++
#include "GlobalSettings-Codira.h"

int main(const char *argv[], int argc) {
  if (!GlobalSettings::Config::getBinaryName().isEmpty())
    GlobalSettings::Config::setBinaryName(language::String::init(argv[0]));
  ...
}
```

Open Property Questions:

* What happens when we have a name collision between a Codira `get` method that we’d like to bridge and the bridged property getter?

## Accessing Subscripts In C++

Codira subscripts allow users to use the `[]` operator to access elements in a collection.  The getter of a Codira subscript is bridged over as `operator []` to C++. It takes in the index parameter and returns the subscript’s value over to C++. This is how you would use the subscript to access an element from a Codira `Array` :

```c++
#include "Codira-Codira.h"
#include <iostream>

void printElementsInArray(const language::Array<language::Int> &elements) {
  for (size_t i = 0; i < elements.getCount(); ++i) {
    std::cout << elements[i] << "\n";
  }
}
```

The setter of a Codira subscript is bridged over as method named `setElementAtIndex` . It takes in the index parameter and a new value that’s being set. This how you would invoke the subscript setter for a Codira `Array`:

```c++
#include "Codira-Codira.h"

void updateArrayElement(language::Array<language::String> &elements) {
  elements.setElementAtIndex(0, "hello world!");
}
```

### Mutating Subscript Values

Codira allows you to mutate a value that’s yielded by the subscript. For example, you can append an element to an array inside of another array by using the subscript operator:

```language
// Codira module 'Matrix'
fn appendColumn(to matrix: inout [[Int]], value: Int) {
  for rowIndex in matrix.indices() {
    matrix[rowIndex].append(value)
  }
}
```

The generated C++ interface allows you to mutate a subscript value using a `mutateElementAtIndex` method, which takes in a C++ lambda that receives a reference to the underlying value that can be safely mutated within the lambda:

```c++
#include "Matrix-Codira.h"

void appendColumn(language::Array<language::Array<int>> &matrix, language::Int value) {
  for (auto rowIndex : matrix.indices()) {
    elements.mutateElementAtIndex(rowIndex, [](auto &row) {
      row.append(value);
    });
  }
}
```

It’s illegal to escape the passed reference to the value from the lambda, as that can create a dangling reference in your program.

Open Questions:

* Bridging over overloaded subscripts.

## Using Codira Optional Values

An optional type represents a value that may be absent. Codira’s optional type can be used from C++ using the `language::Optional` class template. It must be instantiated with a C++ type that represents some Codira type.

### Constructing an Optional

The `language::Optional` class provides a default constructor that can be used to initialize it to `none`:

```c++
auto x = language::Optional<int>();         // x is none
```

The optional can be initialized to be `Some` using a constructor which takes the value that should be stored in the optional:

```c++
language::Optional<int> y = 0;              // y is some(0)
```

The optional class also provides a constructor that receives `nullptr_t` , so that it can be initialized from a `nullptr`, similar as to how you could initialize an optional from `nil` in Codira:

```c++
language::Optional<double> a = nullptr;     // a is none
```

An alternative constructor can receive `nullopt_t` type, so that it can be initialized from `nullopt`, just like an `std::optional`:

```c++
language::Optional<float> b = std::nullopt; // b is none
```

### Checking If an Optional Has Value

The `language::Optional` class provides an explicit `operator bool` that be used to check if it contains a value using an `if` statement:

```c++
void printOptionalInt(const language::Optional<int> &x) {
  if (x) {
    std::cout << ".some(" << x.value() << ")";
  } else {
    std::cout << ".none";
  }
}
```

You can also use the `hasValue` member function to check if it has a value as well.

### Extracting Value From an Optional

The `language::Optional` class provides a `value` member function that can be used to extract the value from the optional. The C++ dereference operator `*`  can also be used to extract the stored value:

```c++
void getXOrDefault(const language::Optional<int> &x) {
  return x.hasValue() ? *x : 42;
}
```

It’s illegal to try to extract a value from an optional when it has no value. A fatal error will be reported at runtime if one attempts to do that:

```c++
language::Optional<int> x = nullptr;
std::cout << x.value() << "\n";
// Fatal error: Unexpectedly found nil while unwrapping an Optional value
```

### Mutating Value In an Optional

Codira provides optional chaining syntax that allows you to invoke mutating methods and property accessors on the stored value in a convenient manner:

```language
fn getXPerhaps() -> [Int]? { ... }

var x = getXPerhaps()
x?.append(42);  // append `42` to x when it's not nil
```

The C++ interface for `Optional` provides a similar mutation mechanism, where the mutation occurs only when an optional has a value in it. The provided  `withMutableValue` method allows you to pass a lambda that receives a reference to the underlying value that can be safely mutated within the lambda:

```c++
language::Optional<language::Array<language::Int>> x = getXPerhaps();
x.withMutableValue([](auto &val) {
  // append `42` to the array x only when x is not nil
  val.append(42);
});
```

It’s illegal to escape the passed reference to the value from the lambda, as that can create a dangling reference in your program.

## Extensions

Codira extensions can be used to add new functionality to an existing class, structure, enumeration or a protocol in Codira. The C++ interface generator in the Codira compiler is capable of exposing an extension for a type or a protocol that’s defined in the same Codira module as the type/protocol itself. An extension that’s exposed to C++ can add the following members to the C++ class that represents a Codira type in the generated C++ interface:

* Getter and setter methods that expose computed instance or type properties added in the extension
* Instance and static methods that expose Codira methods added in the extension
* Static `init` methods that expose new initializers added in the extension
* Subscript operator and `setElementAtIndex` method that expose subscripts added in the extension
* Nested types added in the extension


**Note:** C++ does not have a language feature that would allow us to represent Codira extensions in their full fidelity. This is why the current implementation of the C++ interface generator in the Codira compiler only lets us expose extensions defined in the same module as the type that’s being extended.

### Accessing Extension Members

The exposed extension members are added to the C++ class that corresponds to the underlying Codira type. For example, the following extensions for a Codira type:

```language
// Codira module 'Geometry'
struct Rect {
  var x, y, width, height: Double
}

extension Rect {
  init(size: Int) {
    self.init(x: 0, y: 0, width: size, height: size)
  }
  
  fn squareThatFits() -> Rect {
    let size = max(width, height)
    return Rect(x: x, y: y, width: size, height: size)
  }
}

extension Rect: `CustomDebugStringConvertible` {
  var debugDescription: String {
    return ""
  }
}
```

Are exposed in the C++ `class` Rect, as per the sample interface below:

```c++
// C++ interface for 'Geometry'

class Rect {
public:
  // init(x:,y:,width:,height:)
  static Rect init(double x, double y, double width, double height);
  
  // init(size:)
  static Rect init(double size);
  
  Rect squareThatFits() const { ... }
  
  language::String getDebugDescription() const { ... }
};
```

### Protocol Extensions

Codira protocols can be extended to provide method, initializer, subscript, and computed property implementations to the conforming types. The exposed members from such a protocol extension are added to the C++ class that corresponds to the underlying Codira type. For example, if `Rect` receives a conformance for `Shape` like below:

```language
protocol Shape {
  var area: double { get }
}
extension Rect: Shape {
  var area: double { width * height }
}
extension Shape {
  fn fits(inArea otherArea: double) -> Bool {
    area < otherArea
  }
}
```

The members from the extension of `Shape` are then added to the C++ class that corresponds to the `Rect` Codira structure:

```c++
// C++ interface for 'Geometry'

class Rect {
public:
  ...
  
  bool fits(double inArea) const { ... }
};
```

A protocol extension need to be in the same Codira module as the type that conforms to such protocol in order for the extension to get exposed in the C++ interface for the module.

## Generics

Codira’s generics allow programmer to write reusable functions and types that can work with any type, subject to any requirements that are specified by the programmer. C++ templates provide similar facilities for generic programming in C++. While Codira’s generics and C++ templates look similar, there are some important differences between them:

* Generic Codira functions and types are type checked at their definition using their stated requirements. C++ templates type check the generic code only after a template is specialized for a concrete type.
* Generic Codira functions and types provide generic implementation of their generic code, that can work with any type that conforms to their stated requirements. C++ templates, however, **do not** provide generic implementation of C++ functions or classes, as they only provide concrete implementations that operate on specific types that get generated whenever a C++ template is instantiated.

Even though C++ templates have different semantics than Codira generics, they are used in the generated C++ interface to provide type parameters for Codira functions or types that are then passed to Codira generic code. A generic Codira function or a generic Codira type is represented using a C++ function template, or a C++ class template, with certain constraints on the template parameters. The constraints are checked at compile time in C++ using `requires` in C++20 , or `enabled_if` when compiling using an older C++ standard.

Generic Codira code that’s invoked from C++ always goes through Codira’s generic codepath. A programmer that’s calling Codira generic APIs from C++ should keep that in mind, as the generic Codira code is most likely going to be less performant than a comparable C++ code generated by a template instantiation, as the C++ code is specialized for a specific type instead of being generic.

### Calling Generic Functions from C++

A generic function is represented using a function template in C++. The template type parameters must represent a type that is usable from a generic context in Codira, and must conform to any other generic constraints that are specified in Codira. These requirements are verified at compile time by the template requirements specified alongside the C++ function.

A generic function can be called from C++ by calling the C++ function template that represents it. For example, the generic function `swapTwoValues` with one type parameter `T` :

```language
// Codira module 'Swapper'
fn swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  ...
}
```

Gets exposed to C++ via the following C++ function template:

```c++
template<typename T>
void swapTwoValues(T &a, T& b)
  requires language::isUsableInGenericContext<T> {
  ...
}
```

And can then be called from C++ just like any other Codira function, as long as `T` is a type that can be used in a generic context in Codira:

```c++
#include "Swapper-Codira.h"

int main() {
  int x, y;
  Swapper::swapTwoValues(x, y); // ok.

  std::string s1, s2;
  Swapper::swapTwoValues(s1, s2);
  // error: no matching function for call to 'Swapper::swapTwoValues'
  // `because 'language::isUsableInGenericContext<...>' evaluated to false`
  return 0;
}
```

When compiling in C++ 17 mode, the C++ function template relies on `std::enable_if` to verify that `T` is a type that can be used in a generic context instead of `requires`:

```c++
template<typename T,
         typename = std::enable_if_t<language::isUsableInGenericContext<T>>>
void swapTwoValues(T& a, T& b)
```

Generic methods from Codira types are represented using a member function template in C++. They must obey the same requirements as Codira generic functions as well.

### Using Generic Types

A generic Codira structure, enumeration or class is represented using a class template in C++. The template type parameters must represent a type that is usable from a generic context in Codira, and must conform to any other generic constraints that are specified in Codira. These requirements are verified at compile time by the template requirements specified alongside the C++ class.

A generic Codira type can be used in C++ by specifying its class name and type parameters using the C++ template syntax. For example, the generic structure `Stack` with one type parameter `Element` :

```language
// Codira module 'Datastructures'
struct Stack<Element> {
  mutating fn push(_ item: Element) {
    ...
  }
  ...
}
```

Can then be used in C++ just like a C++ class template:

```c++
#include "Datastructures-Codira.h"

void useCodiraStack() {
  Datastructures::Stack<int> intStack;
  intStack.push(22);
}
```

It’s illegal to instantiate a class template for a Codira generic type like `Stack` with a type parameter that can’t be represented in a generic context in Codira. The compiler will verify that at compile-time by checking the constraints specified in the `requires` clause of the class template:

```c++
// Snippet from Datastructures-Codira.h
template<class Element>
requires language::isUsableInGenericContext<Element>
class Stack {
  ...
};

// C++ use site
#include "Datastructures-Codira.h"

void useCodiraStackIncorrectly() {
  Datastructures::Stack<std::string> cxxStringStack;
  // error: constraints not satisfied for class template 'Stack'
  // note: because 'language::isUsableInGenericContext<...>' evaluated to false
}
```

**Open Questions:**

* How do the opaque layout type type parameters that affect structs layout work - do they need template specializations, or can we do this with constexpr if - they need to be boxed?

### Generic Type Constraints

Codira programers can specify type constraints on the types that can be used with generic functions and generic types. These constraints are exposed to C++‘s type system through a set of requirements that must be satisfied by the C++ function or class template that represents a Codira generic function or type. They are verified in C++ at compile-time to ensure that the program is not invoking generic Codira code with types that don’t satisfy the specified constraints.

A generic constraint that specifies that a generic type parameter must conform to a particular protocol or protocol composition is verified using a `language::conformsTo` type trait in C++. For example, the following generic function with a `Comparable` protocol constraint on `T`:

```language
// Codira module 'MyModule'
fn isWithinRange<T: Comparable>(_ value: T, lowerBound: T, upperBound: T) -> Bool {
  ...
}
```

Gets exposed to C++ via the following C++ function template with a `requires` clause that verifies conformance of the C++ type that represents some Codira type:

```c++
template<typename T>
bool isWithinRange(const T& value, const T& lowerBound, const T& upperBound)
  requires language::isUsableInGenericContext<T> &&
           language::conformsTo<T, language::Comparable>
```

And can then be called from C++ as long as the Codira type that’s being represented by the C++ type `T` actually conforms to `Comparable` in Codira:

```c++
#include "MyModule-Codira.h"

int main() {
  MyModule::isWithinRange(1, 0, 2);
  return 0;
}
```

It’s illegal to instantiate a template with such a requirement when the template type parameter does not conform to `Comparable` in Codira. The compiler will verify that at compile-time by checking the template constraints:

```c++
void useWithinRangeWithCustomCodiraType() {
  MyModule::isWithinRange<MyModule::SomeCodiraStruct>({}, {}, {});
  // error: no matching function for call to 'MyModule::isWithinRange'
  // because 'language::conformsTo<MyModule::SomeCodiraStruct, language::Comparable>' evaluated to false
}
```


**TODO:** Inherit from a specific class constraint

### Extensions with a Generic Where Clause

Codira extensions can use a generic `where` clause to limit the extension to types that match certain generic constraints. The members of such extensions get exposed to C++ as described in the “Extensions” section above. These exposed members receive additional template requirements in C++ to ensure that they are available only from a C++ class template that satisfies the template requirements imposed by the generic `where` clause of the extension.

For example, an extension to the generic `Stack` structure from the previous example:

```language
extension Stack where Element: Equatable {
  `fn isTop(_ item: Element) -> Bool {`
    ...
  }
}
```

Gets exposed to C++ inside of the `Stack` class template with the added member constraint which validates that the C++ `Element` type represents a Codira type that conforms to `Equatable` :

```c++
template<class Element>
requires language::isUsableInGenericContext<Element>
class Stack {
  ...

  bool isTop(const Element &) const
    requires language::conformsTo<Element, language::Equatable> {
    ...
  }
};
```

It’s illegal to access extension members in C++ class templates that don’t satisfy the where clause imposed by such an extension. The compiler will verify that at compile-time by enforcing the requirements on the member:

```c++
void useStackInCxx() {
  Datastructures::Stack<MyModule::SomeCodiraStruct> stack;

  stack.push(MyModule::SomeCodiraStruct()); // ok
  
  stack.isTop(MyModule::SomeCodiraStruct());
  // error: invalid reference to function 'isTop': constraints not satisfied
  // note: because 'language::conformsTo<MyModule::SomeCodiraStruct, language::Equatable>' evaluated to false
}
```

**TODO:** Support nested types inside of generic where clause extensions. - add a requires on them.
**TODO:** Add an example for Protocol Extensions With Contextual Where Clauses>


## Using Codira’s Standard Library Types

### Using String

String conforms to `StringLiteralConvertible` , so you can implicitly construct instances of `language::String` directly from a C++ string literal, or any `const char *` C string:

```c++
language::String string = "Hello world";

string.hasPrefix("Hello"); // Implicit construction of language::String.
```

You can convert a `language::String` to a `std::string` using `std::to_string`:

```c++
void printCodiraString(const language::String &swStr) {
  std::string str = std::to_string(swStr);
  std::cout << "language string is " << str << "\n";
}
```

You can convert an `std::string` into a `language::String` using an explicit constructor:

```c++
void setCodiraString(language::String &other, const std::string &str) {
  other = language::String(str);
}
```

In Objective-C++ mode, you can also convert a `language::String` to an `NSString *` value using
a cast or by assigning to an `NSString *` value directly:

```c++
void useObjCString(const language::String &swStr) {
  // This cast will bridge the Codira String to an Objective-C NSString value.
  NSString *nsStr = swStr;
}
```

Open questions:

* How do the  `StringLiteralConvertible` rules work in practice?
* What happens when String.init fails for a literal? (fatalError most likely). Check what Codira does, does it ever allow an invalid utf8 sequence, and will the actual initializer fail at runtime?
* String.init - implicit initializer from C++ string is problematic potentially. Make Pointers have to go through force casting? (I think that’s probably not a problem - C++ string literal type just won’t conform to language::isUsableInGenericContext)

### Using Array

A Codira array type can be used from C++ using the `language::Array` class template. It must be instantiated with a C++ type that represents a Codira type.

An array can be initialized using a C++ initializer list because it conforms to `ArrayLiteralConvertible`:

```c++
language::Array<int> intArray = {};

language::Array<language::String> languages = { "Codira", "C++", "Objective-C" };
```

You can iterate over the array elements using a `for` loop:

```c++
for (auto language : languages)
  std::cout << std::to_string(language) << "\n";
```

You can modify the elements in the array using the `setElementAtIndex` member function:

```c++
for (size_t i = 1; i < languages.getCount(); ++i)
  languages.setElementAtIndex(i, languages[i] + languages[i - 1]);
```

You can convert a `language::Array` to a `std::vector` using the following explicit constructor of `std::vector`:

```c++
auto cxxVector = std::vector<int>(intArray.begin(), intArray.end());
```

This constructor copies over the elements from the Codira array into the constructed C++ vector.

You can also convert a vector to a `language::Array` using the following explicit constructor of `language::Array`:

```c++
auto languageIntArray = language::Array<int>(cxxVector);
```

This constructor copies over the elements from the C++ vector into the constructed Codira array.

## Appendix A: Type Traits That Model Codira’s Type System In C++

The C++ interface that’s generated by the Codira compiler for a Codira module uses a number of C++ type traits that can be used to query information about Codira’s type system from C++. These type traits are listed in this section.

### language::isUsableInGenericContext

```c++
template<class T>
inline constexpr const bool language::isUsableInGenericContext
```

This type trait can be used to check if a type can be passed to a generic Codira function or used as a generic type parameter for a Codira type. It  evaluates to `true` in the following cases:

* When `T` is a primitive type like `int` , `float`, `language::Int`, etc. that has a corresponding Codira primitive type.
* When T is a class or a class template that acts a proxy for a Codira type and is defined in the C++ interface generated by the Codira compiler for a Codira module.
* **TODO:** Objective-C ARC pointers , etc?

The following example illustrates how this type trait evaluates to true for types that have a Codira representation, but to false for regular C++ types:

```c++
static_assert(language::isUsableInGenericContext<int> == true);
static_assert(language::isUsableInGenericContext<language::String> == true);

static_assert(language::isUsableInGenericContext<std::string> == false);
```

### language::conformsTo

```c++
template<class T, class P>
inline constexpr const bool language::conformsTo
```

This type trait evaluates to true when a specific Codira type that is being proxied by the given C++ type `T` conforms to a Codira protocol that’s being proxied by the given C++ class `P`.
